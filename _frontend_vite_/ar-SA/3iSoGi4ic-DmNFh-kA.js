import{n as ur}from"./3iSoGi4ic-ke9ZaMpT.js";function m(r){if(!r)throw new Error("Assertion failed.")}const xr=r=>{const e=(r%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${r}.`)},X=r=>r&&r[r.length-1],_t=r=>r>=0&&r<2**32;class W{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),t=this.bytes[e]??0,i=7-(this.pos&7),s=(t&1<<i)>>i;return this.pos++,s}readBits(e){if(e===1)return this.readBit();let t=0;for(let i=0;i<e;i++)t<<=1,t|=this.readBit();return t}writeBits(e,t){const i=this.pos+e;for(let s=this.pos;s<i;s++){const n=Math.floor(s/8);let a=this.bytes[n];const o=7-(s&7);a&=~(1<<o),a|=(t&1<<i-s-1)>>i-s-1<<o,this.bytes[n]=a}this.pos=i}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,t=this.bytes[e]??0;return this.pos+=8,t}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new W(this.bytes);return e.pos=this.pos,e}}const E=r=>{let e=0;for(;r.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+r.readBits(e)},Ue=r=>{const e=E(r);return(e&1)===0?-(e>>1):e+1>>1},Xn=(r,e,t,i)=>{for(let s=e;s<t;s++){const n=Math.floor(s/8);let a=r[n];const o=7-(s&7);a&=~(1<<o),a|=(i&1<<t-s-1)>>t-s-1<<o,r[n]=a}},K=r=>r.constructor===Uint8Array?r:ArrayBuffer.isView(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):new Uint8Array(r),L=r=>r.constructor===DataView?r:ArrayBuffer.isView(r)?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(r),ke=new TextDecoder,j=new TextEncoder,pt=r=>{for(let e=0;e<r.length;e++)if(r.charCodeAt(e)>255)return!1;return!0},yi=r=>Object.fromEntries(Object.entries(r).map(([e,t])=>[t,e])),vt={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},Fs=yi(vt),It={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pq:16,hlg:18},Bs=yi(It),Et={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},zs=yi(Et),Rs=r=>!!r&&!!r.primaries&&!!r.transfer&&!!r.matrix&&r.fullRange!==void 0,Cr=r=>r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer||ArrayBuffer.isView(r);class At{constructor(){this.currentPromise=Promise.resolve()}async acquire(){let e;const t=new Promise(s=>{e=s}),i=this.currentPromise;return this.currentPromise=t,await i,e}}const $i=r=>[...r].map(e=>e.toString(16).padStart(2,"0")).join(""),Qi=r=>(r=r>>1&1431655765|(r&1431655765)<<1,r=r>>2&858993459|(r&858993459)<<2,r=r>>4&252645135|(r&252645135)<<4,r=r>>8&16711935|(r&16711935)<<8,r=r>>16&65535|(r&65535)<<16,r>>>0),_r=(r,e,t)=>{let i=0,s=r.length-1,n=-1;for(;i<=s;){const a=i+s>>1,o=t(r[a]);o===e?(n=a,s=a-1):o<e?i=a+1:s=a-1}return n},H=(r,e,t)=>{let i=0,s=r.length-1,n=-1;for(;i<=s;){const a=i+(s-i+1)/2|0;t(r[a])<=e?(n=a,i=a+1):s=a-1}return n},Ki=(r,e,t)=>{const i=H(r,t(e),t);r.splice(i+1,0,e)},G=()=>{let r,e;return{promise:new Promise((i,s)=>{r=i,e=s}),resolve:r,reject:e}},Ms=(r,e)=>{for(let t=r.length-1;t>=0;t--)if(e(r[t]))return r[t]},Ds=(r,e)=>{for(let t=r.length-1;t>=0;t--)if(e(r[t]))return t;return-1},Yn=async function*(r){Symbol.iterator in r?yield*r[Symbol.iterator]():yield*r[Symbol.asyncIterator]()},Zn=r=>{if(!(Symbol.iterator in r)&&!(Symbol.asyncIterator in r))throw new TypeError("Argument must be an iterable or async iterable.")},ae=r=>{throw new Error(`Unexpected value: ${r}`)},Pr=(r,e,t)=>{const i=r.getUint8(e),s=r.getUint8(e+1),n=r.getUint8(e+2);return t?i|s<<8|n<<16:i<<16|s<<8|n},Jn=(r,e,t)=>Pr(r,e,t)<<8>>8,Us=(r,e,t,i)=>{t=t>>>0,t=t&16777215,i?(r.setUint8(e,t&255),r.setUint8(e+1,t>>>8&255),r.setUint8(e+2,t>>>16&255)):(r.setUint8(e,t>>>16&255),r.setUint8(e+1,t>>>8&255),r.setUint8(e+2,t&255))},ea=(r,e,t,i)=>{t=J(t,-8388608,8388607),t<0&&(t=t+16777216&16777215),Us(r,e,t,i)},ta=(r,e,t,i)=>{r.setUint32(e+0,t,!0),r.setInt32(e+4,Math.floor(t/2**32),!0)},dr=(r,e)=>({async next(){const t=await r.next();return t.done?{value:void 0,done:!0}:{value:e(t.value),done:!1}},return(){return r.return()},throw(t){return r.throw(t)},[Symbol.asyncIterator](){return this}}),J=(r,e,t)=>Math.max(e,Math.min(t,r)),me="und",hr=r=>{const e=Math.round(r);return Math.abs(r/e-1)<10*Number.EPSILON?e:r},Yr=(r,e)=>Math.round(r/e)*e,ra=r=>{let e=0;for(;r;)e++,r>>=1;return e},ia=/^[a-z]{3}$/,$t=r=>ia.test(r),Ke=1e6*(1+Number.EPSILON),Gi=(r,e)=>{const t={...r,...e};if(r.headers||e.headers){const i=r.headers?Xi(r.headers):{},s=e.headers?Xi(e.headers):{},n={...i};Object.entries(s).forEach(([a,o])=>{const c=Object.keys(n).find(l=>l.toLowerCase()===a.toLowerCase());c&&delete n[c],n[a]=o}),t.headers=n}return t},Xi=r=>{if(r instanceof Headers){const e={};return r.forEach((t,i)=>{e[i]=t}),e}if(Array.isArray(r)){const e={};return r.forEach(([t,i])=>{e[t]=i}),e}return r},Yi=async(r,e,t,i,s)=>{let n=0;for(;;)try{return await r(e,t)}catch(a){if(s())throw a;n++;const o=i(n,a,e);if(o===null)throw a;if(console.error("Retrying failed fetch. Error:",a),!Number.isFinite(o)||o<0)throw new TypeError("Retry delay must be a non-negative finite number.");if(o>0&&await new Promise(c=>setTimeout(c,1e3*o)),s())throw a}},sa=(r,e)=>{const t=r<0?-1:1;r=Math.abs(r);let i=0,s=1,n=1,a=0,o=r;for(;;){const c=Math.floor(o),l=c*n+i,u=c*a+s;if(u>e)return{numerator:t*n,denominator:a};if(i=n,s=a,n=l,a=u,o=1/(o-c),!isFinite(o))break}return{numerator:t*n,denominator:a}};class vr{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}let Ar=null;const or=()=>Ar!==null?Ar:Ar=!!(typeof navigator<"u"&&(navigator.vendor?.match(/apple/i)||/AppleWebKit/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)||/\b(iPad|iPhone|iPod)\b/.test(navigator.userAgent)));let Fr=null;const Pt=()=>Fr!==null?Fr:Fr=typeof navigator<"u"&&navigator.userAgent?.includes("Firefox");let Br=null;const Ns=()=>Br!==null?Br:Br=!!(typeof navigator<"u"&&(navigator.vendor?.includes("Google Inc")||/Chrome/.test(navigator.userAgent)));let zr=null;const na=()=>{if(zr!==null)return zr;if(typeof navigator>"u")return null;const r=/\bChrome\/(\d+)/.exec(navigator.userAgent);return r?zr=Number(r[1]):null},gt=(r,e)=>r!==-1?r:e,Zr=(r,e,t,i)=>r<=i&&t<=e,Ft=function*(r){for(const e in r){const t=r[e];t!==void 0&&(yield{key:e,value:t})}},aa=r=>{switch(r.toLowerCase()){case"image/jpeg":case"image/jpg":return".jpg";case"image/png":return".png";case"image/gif":return".gif";case"image/webp":return".webp";case"image/bmp":return".bmp";case"image/svg+xml":return".svg";case"image/tiff":return".tiff";case"image/avif":return".avif";case"image/x-icon":case"image/vnd.microsoft.icon":return".ico";default:return null}},oa=r=>{const e=atob(r),t=new Uint8Array(e.length);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);return t},ca=r=>{let e="";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return btoa(e)},la=(r,e)=>{if(r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0},Os=()=>{Symbol.dispose??=Symbol("Symbol.dispose")},Bt=r=>typeof r=="number"&&!Number.isNaN(r);class St{constructor(e,t){if(this.data=e,this.mimeType=t,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(typeof t!="string")throw new TypeError("mimeType must be a string.")}}class Si{constructor(e,t,i,s){if(this.data=e,this.mimeType=t,this.name=i,this.description=s,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(t!==void 0&&typeof t!="string")throw new TypeError("mimeType, when provided, must be a string.");if(i!==void 0&&typeof i!="string")throw new TypeError("name, when provided, must be a string.");if(s!==void 0&&typeof s!="string")throw new TypeError("description, when provided, must be a string.")}}const Jr=r=>{if(!r||typeof r!="object")throw new TypeError("tags must be an object.");if(r.title!==void 0&&typeof r.title!="string")throw new TypeError("tags.title, when provided, must be a string.");if(r.description!==void 0&&typeof r.description!="string")throw new TypeError("tags.description, when provided, must be a string.");if(r.artist!==void 0&&typeof r.artist!="string")throw new TypeError("tags.artist, when provided, must be a string.");if(r.album!==void 0&&typeof r.album!="string")throw new TypeError("tags.album, when provided, must be a string.");if(r.albumArtist!==void 0&&typeof r.albumArtist!="string")throw new TypeError("tags.albumArtist, when provided, must be a string.");if(r.trackNumber!==void 0&&(!Number.isInteger(r.trackNumber)||r.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(r.tracksTotal!==void 0&&(!Number.isInteger(r.tracksTotal)||r.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(r.discNumber!==void 0&&(!Number.isInteger(r.discNumber)||r.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(r.discsTotal!==void 0&&(!Number.isInteger(r.discsTotal)||r.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(r.genre!==void 0&&typeof r.genre!="string")throw new TypeError("tags.genre, when provided, must be a string.");if(r.date!==void 0&&(!(r.date instanceof Date)||Number.isNaN(r.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(r.lyrics!==void 0&&typeof r.lyrics!="string")throw new TypeError("tags.lyrics, when provided, must be a string.");if(r.images!==void 0){if(!Array.isArray(r.images))throw new TypeError("tags.images, when provided, must be an array.");for(const e of r.images){if(!e||typeof e!="object")throw new TypeError("Each image in tags.images must be an object.");if(!(e.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if(typeof e.mimeType!="string")throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(e.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(r.comment!==void 0&&typeof r.comment!="string")throw new TypeError("tags.comment, when provided, must be a string.");if(r.raw!==void 0){if(!r.raw||typeof r.raw!="object")throw new TypeError("tags.raw, when provided, must be an object.");for(const e of Object.values(r.raw))if(e!==null&&typeof e!="string"&&!(e instanceof Uint8Array)&&!(e instanceof St)&&!(e instanceof Si))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.")}},fr=r=>r.title===void 0&&r.description===void 0&&r.artist===void 0&&r.album===void 0&&r.albumArtist===void 0&&r.trackNumber===void 0&&r.tracksTotal===void 0&&r.discNumber===void 0&&r.discsTotal===void 0&&r.genre===void 0&&r.date===void 0&&r.lyrics===void 0&&(!r.images||r.images.length===0)&&r.comment===void 0&&(r.raw===void 0||Object.keys(r.raw).length===0),at={default:!0,forced:!1,original:!1,commentary:!1,hearingImpaired:!1,visuallyImpaired:!1},ua=r=>{if(!r||typeof r!="object")throw new TypeError("disposition must be an object.");if(r.default!==void 0&&typeof r.default!="boolean")throw new TypeError("disposition.default must be a boolean.");if(r.forced!==void 0&&typeof r.forced!="boolean")throw new TypeError("disposition.forced must be a boolean.");if(r.original!==void 0&&typeof r.original!="boolean")throw new TypeError("disposition.original must be a boolean.");if(r.commentary!==void 0&&typeof r.commentary!="boolean")throw new TypeError("disposition.commentary must be a boolean.");if(r.hearingImpaired!==void 0&&typeof r.hearingImpaired!="boolean")throw new TypeError("disposition.hearingImpaired must be a boolean.");if(r.visuallyImpaired!==void 0&&typeof r.visuallyImpaired!="boolean")throw new TypeError("disposition.visuallyImpaired must be a boolean.")},ce=["avc","hevc","vp9","av1","vp8"],Z=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],xt=["aac","opus","mp3","vorbis","flac"],pe=[...xt,...Z],Ve=["webvtt"],Zi=[{maxMacroblocks:99,maxBitrate:64e3,level:10},{maxMacroblocks:396,maxBitrate:192e3,level:11},{maxMacroblocks:396,maxBitrate:384e3,level:12},{maxMacroblocks:396,maxBitrate:768e3,level:13},{maxMacroblocks:396,maxBitrate:2e6,level:20},{maxMacroblocks:792,maxBitrate:4e6,level:21},{maxMacroblocks:1620,maxBitrate:4e6,level:22},{maxMacroblocks:1620,maxBitrate:1e7,level:30},{maxMacroblocks:3600,maxBitrate:14e6,level:31},{maxMacroblocks:5120,maxBitrate:2e7,level:32},{maxMacroblocks:8192,maxBitrate:2e7,level:40},{maxMacroblocks:8192,maxBitrate:5e7,level:41},{maxMacroblocks:8704,maxBitrate:5e7,level:42},{maxMacroblocks:22080,maxBitrate:135e6,level:50},{maxMacroblocks:36864,maxBitrate:24e7,level:51},{maxMacroblocks:36864,maxBitrate:24e7,level:52},{maxMacroblocks:139264,maxBitrate:24e7,level:60},{maxMacroblocks:139264,maxBitrate:48e7,level:61},{maxMacroblocks:139264,maxBitrate:8e8,level:62}],Ji=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Ge=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],es=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],ts=".01.01.01.01.00",rs=".0.110.01.01.01.0",da=(r,e,t,i)=>{if(r==="avc"){const n=Math.ceil(e/16)*Math.ceil(t/16),a=Zi.find(d=>n<=d.maxMacroblocks&&i<=d.maxBitrate)??X(Zi),o=a?a.level:0,c="64".padStart(2,"0"),l="00",u=o.toString(16).padStart(2,"0");return`avc1.${c}${l}${u}`}else if(r==="hevc"){const o=e*t,c=Ji.find(u=>o<=u.maxPictureSize&&i<=u.maxBitrate)??X(Ji);return`hev1.1.6.${c.tier}${c.level}.B0`}else{if(r==="vp8")return"vp8";if(r==="vp9"){const n=e*t;return`vp09.00.${(Ge.find(c=>n<=c.maxPictureSize&&i<=c.maxBitrate)??X(Ge)).level.toString().padStart(2,"0")}.08`}else if(r==="av1"){const n=e*t,a=es.find(l=>n<=l.maxPictureSize&&i<=l.maxBitrate)??X(es);return`av01.0.${a.level.toString().padStart(2,"0")}${a.tier}.08`}}throw new TypeError(`Unhandled codec '${r}'.`)},ha=r=>{const e=r.split("."),t=Number(e[1]),i=Number(e[2]),s=Number(e[3]),n=e[4]?Number(e[4]):1;return[1,1,t,2,1,i,3,1,s,4,1,n]},Vs=r=>{const e=r.split("."),s=(1<<7)+1,n=Number(e[1]),a=e[2],o=Number(a.slice(0,-1)),c=(n<<5)+o,l=a.slice(-1)==="H"?1:0,d=Number(e[3])===8?0:1,h=0,f=e[4]?Number(e[4]):0,p=e[5]?Number(e[5][0]):1,g=e[5]?Number(e[5][1]):1,w=e[5]?Number(e[5][2]):0,T=(l<<7)+(d<<6)+(h<<5)+(f<<4)+(p<<3)+(g<<2)+w;return[s,c,T,0]},Ws=r=>{const{codec:e,codecDescription:t,colorSpace:i,avcCodecInfo:s,hevcCodecInfo:n,vp9CodecInfo:a,av1CodecInfo:o}=r;if(e==="avc"){if(m(r.avcType!==null),s){const c=new Uint8Array([s.avcProfileIndication,s.profileCompatibility,s.avcLevelIndication]);return`avc${r.avcType}.${$i(c)}`}if(!t||t.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc${r.avcType}.${$i(t.subarray(1,4))}`}else if(e==="hevc"){let c,l,u,d,h,f;if(n)c=n.generalProfileSpace,l=n.generalProfileIdc,u=Qi(n.generalProfileCompatibilityFlags),d=n.generalTierFlag,h=n.generalLevelIdc,f=[...n.generalConstraintIndicatorFlags];else{if(!t||t.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const g=L(t),w=g.getUint8(1);c=w>>6&3,l=w&31,u=Qi(g.getUint32(2)),d=w>>5&1,h=g.getUint8(12),f=[];for(let T=0;T<6;T++)f.push(g.getUint8(6+T))}let p="hev1.";for(p+=["","A","B","C"][c]+l,p+=".",p+=u.toString(16).toUpperCase(),p+=".",p+=d===0?"L":"H",p+=h;f.length>0&&f[f.length-1]===0;)f.pop();return f.length>0&&(p+=".",p+=f.map(g=>g.toString(16).toUpperCase()).join(".")),p}else{if(e==="vp8")return"vp8";if(e==="vp9"){if(!a){const T=r.width*r.height;let k=X(Ge).level;for(const S of Ge)if(T<=S.maxPictureSize){k=S.level;break}return`vp09.00.${k.toString().padStart(2,"0")}.08`}const c=a.profile.toString().padStart(2,"0"),l=a.level.toString().padStart(2,"0"),u=a.bitDepth.toString().padStart(2,"0"),d=a.chromaSubsampling.toString().padStart(2,"0"),h=a.colourPrimaries.toString().padStart(2,"0"),f=a.transferCharacteristics.toString().padStart(2,"0"),p=a.matrixCoefficients.toString().padStart(2,"0"),g=a.videoFullRangeFlag.toString().padStart(2,"0");let w=`vp09.${c}.${l}.${u}.${d}`;return w+=`.${h}.${f}.${p}.${g}`,w.endsWith(ts)&&(w=w.slice(0,-ts.length)),w}else if(e==="av1"){if(!o){const S=r.width*r.height;let y=X(Ge).level;for(const x of Ge)if(S<=x.maxPictureSize){y=x.level;break}return`av01.0.${y.toString().padStart(2,"0")}M.08`}const c=o.profile,l=o.level.toString().padStart(2,"0"),u=o.tier?"H":"M",d=o.bitDepth.toString().padStart(2,"0"),h=o.monochrome?"1":"0",f=100*o.chromaSubsamplingX+10*o.chromaSubsamplingY+1*(o.chromaSubsamplingX&&o.chromaSubsamplingY?o.chromaSamplePosition:0),p=i?.primaries?vt[i.primaries]:1,g=i?.transfer?It[i.transfer]:1,w=i?.matrix?Et[i.matrix]:1,T=i?.fullRange?1:0;let k=`av01.${c}.${l}${u}.${d}`;return k+=`.${h}.${f.toString().padStart(3,"0")}`,k+=`.${p.toString().padStart(2,"0")}`,k+=`.${g.toString().padStart(2,"0")}`,k+=`.${w.toString().padStart(2,"0")}`,k+=`.${T}`,k.endsWith(rs)&&(k=k.slice(0,-rs.length)),k}}throw new TypeError(`Unhandled codec '${e}'.`)},fa=(r,e,t)=>{if(r==="aac")return e>=2&&t<=24e3?"mp4a.40.29":t<=24e3?"mp4a.40.5":"mp4a.40.2";if(r==="mp3")return"mp3";if(r==="opus")return"opus";if(r==="vorbis")return"vorbis";if(r==="flac")return"flac";if(Z.includes(r))return r;throw new TypeError(`Unhandled codec '${r}'.`)},Ls=r=>{const{codec:e,codecDescription:t,aacCodecInfo:i}=r;if(e==="aac"){if(!i)throw new TypeError("AAC codec info must be provided.");return i.isMpeg2?"mp4a.67":`mp4a.40.${Ir(t).objectType}`}else{if(e==="mp3")return"mp3";if(e==="opus")return"opus";if(e==="vorbis")return"vorbis";if(e==="flac")return"flac";if(e&&Z.includes(e))return e}throw new TypeError(`Unhandled codec '${e}'.`)},Qt=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],xi=[-1,1,2,3,4,5,6,8],Ir=r=>{if(!r||r.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const e=new W(r);let t=e.readBits(5);t===31&&(t=32+e.readBits(6));const i=e.readBits(4);let s=null;i===15?s=e.readBits(24):i<Qt.length&&(s=Qt[i]);const n=e.readBits(4);let a=null;return n>=1&&n<=7&&(a=xi[n]),{objectType:t,frequencyIndex:i,sampleRate:s,channelConfiguration:n,numberOfChannels:a}},ma=r=>{let e=Qt.indexOf(r.sampleRate),t=null;e===-1&&(e=15,t=r.sampleRate);const i=xi.indexOf(r.numberOfChannels);if(i===-1)throw new TypeError(`Unsupported number of channels: ${r.numberOfChannels}`);let s=13;r.objectType>=32&&(s+=6),e===15&&(s+=24);const n=Math.ceil(s/8),a=new Uint8Array(n),o=new W(a);return r.objectType<32?o.writeBits(5,r.objectType):(o.writeBits(5,31),o.writeBits(6,r.objectType-32)),o.writeBits(4,e),e===15&&o.writeBits(24,t),o.writeBits(4,i),a},zt=48e3,Hs=/^pcm-([usf])(\d+)+(be)?$/,Ae=r=>{if(m(Z.includes(r)),r==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(r==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=Hs.exec(r);m(e);let t;e[1]==="u"?t="unsigned":e[1]==="s"?t="signed":t="float";const i=Number(e[2])/8,s=e[3]!=="be",n=r==="pcm-u8"?2**7:0;return{dataType:t,sampleSize:i,littleEndian:s,silentValue:n}},qs=r=>r.startsWith("avc1")||r.startsWith("avc3")?"avc":r.startsWith("hev1")||r.startsWith("hvc1")?"hevc":r==="vp8"?"vp8":r.startsWith("vp09")?"vp9":r.startsWith("av01")?"av1":r.startsWith("mp4a.40")||r==="mp4a.67"?"aac":r==="mp3"||r==="mp4a.69"||r==="mp4a.6B"||r==="mp4a.6b"?"mp3":r==="opus"?"opus":r==="vorbis"?"vorbis":r==="flac"?"flac":r==="ulaw"?"ulaw":r==="alaw"?"alaw":Hs.test(r)?r:r==="webvtt"?"webvtt":null,pa=r=>r==="avc"?{avc:{format:"avc"}}:r==="hevc"?{hevc:{format:"hevc"}}:{},ga=r=>r==="aac"?{aac:{format:"aac"}}:r==="opus"?{opus:{format:"opus"}}:{},wa=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],ba=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,ka=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,Ta=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,ya=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,js=r=>{if(!r)throw new TypeError("Video chunk metadata must be provided.");if(typeof r!="object")throw new TypeError("Video chunk metadata must be an object.");if(!r.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof r.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof r.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!wa.some(e=>r.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(r.decoderConfig.codedWidth)||r.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(r.decoderConfig.codedHeight)||r.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(r.decoderConfig.description!==void 0&&!Cr(r.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(r.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=r.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const t=Object.keys(vt);if(e.primaries!=null&&!t.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${t.join(", ")}.`);const i=Object.keys(It);if(e.transfer!=null&&!i.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${i.join(", ")}.`);const s=Object.keys(Et);if(e.matrix!=null&&!s.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${s.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(r.decoderConfig.codec.startsWith("avc1")||r.decoderConfig.codec.startsWith("avc3")){if(!ba.test(r.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(r.decoderConfig.codec.startsWith("hev1")||r.decoderConfig.codec.startsWith("hvc1")){if(!ka.test(r.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(r.decoderConfig.codec.startsWith("vp8")){if(r.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(r.decoderConfig.codec.startsWith("vp09")){if(!Ta.test(r.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(r.decoderConfig.codec.startsWith("av01")&&!ya.test(r.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Sa=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],Rt=r=>{if(!r)throw new TypeError("Audio chunk metadata must be provided.");if(typeof r!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!r.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof r.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof r.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Sa.some(e=>r.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(r.decoderConfig.sampleRate)||r.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(r.decoderConfig.numberOfChannels)||r.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(r.decoderConfig.description!==void 0&&!Cr(r.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(r.decoderConfig.codec.startsWith("mp4a")&&r.decoderConfig.codec!=="mp4a.69"&&r.decoderConfig.codec!=="mp4a.6B"&&r.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(r.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.");if(!r.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3.")}else if(r.decoderConfig.codec.startsWith("mp3")||r.decoderConfig.codec.startsWith("mp4a")){if(r.decoderConfig.codec!=="mp3"&&r.decoderConfig.codec!=="mp4a.69"&&r.decoderConfig.codec!=="mp4a.6B"&&r.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(r.decoderConfig.codec.startsWith("opus")){if(r.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(r.decoderConfig.description&&r.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(r.decoderConfig.codec.startsWith("vorbis")){if(r.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!r.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(r.decoderConfig.codec.startsWith("flac")){if(r.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!r.decoderConfig.description||r.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((r.decoderConfig.codec.startsWith("pcm")||r.decoderConfig.codec.startsWith("ulaw")||r.decoderConfig.codec.startsWith("alaw"))&&!Z.includes(r.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${Z.join(", ")}).`)},$s=r=>{if(!r)throw new TypeError("Subtitle metadata must be provided.");if(typeof r!="object")throw new TypeError("Subtitle metadata must be an object.");if(!r.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof r.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof r.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};class ot{constructor(e){this.mutex=new At,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,t,i){t+=e.source._timestampOffset;let s=this.trackTimestampInfo.get(e);if(!s){if(!i)throw new Error("First packet must be a key packet.");s={maxTimestamp:t,maxTimestampBeforeLastKeyPacket:t},this.trackTimestampInfo.set(e,s)}if(t<0)throw new Error(`Timestamps must be non-negative (got ${t}s).`);if(i&&(s.maxTimestampBeforeLastKeyPacket=s.maxTimestamp),t<s.maxTimestampBeforeLastKeyPacket)throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key packet and ends right before the next key packet). Got ${t}s, but largest timestamp is ${s.maxTimestampBeforeLastKeyPacket}s.`);return s.maxTimestamp=Math.max(s.maxTimestamp,t),t}}class xa extends ot{constructor(e,t){super(e),this.header=new Uint8Array(7),this.headerBitstream=new W(this.header),this.audioSpecificConfig=null,this.format=t,this.writer=e._writer}async start(){}async getMimeType(){return"audio/aac"}async addEncodedVideoPacket(){throw new Error("ADTS does not support video.")}async addEncodedAudioPacket(e,t,i){const s=await this.mutex.acquire();try{if(this.validateAndNormalizeTimestamp(e,t.timestamp,t.type==="key"),!this.audioSpecificConfig){Rt(i);const o=i?.decoderConfig?.description;m(o),this.audioSpecificConfig=Ir(K(o));const{objectType:c,frequencyIndex:l,channelConfiguration:u}=this.audioSpecificConfig,d=c-1;this.headerBitstream.writeBits(12,4095),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(2,0),this.headerBitstream.writeBits(1,1),this.headerBitstream.writeBits(2,d),this.headerBitstream.writeBits(4,l),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(3,u),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(1,0),this.headerBitstream.writeBits(1,0),this.headerBitstream.skipBits(13),this.headerBitstream.writeBits(11,2047),this.headerBitstream.writeBits(2,0)}const n=t.data.byteLength+this.header.byteLength;this.headerBitstream.pos=30,this.headerBitstream.writeBits(13,n);const a=this.writer.getPos();if(this.writer.write(this.header),this.writer.write(t.data),this.format._options.onFrame){const o=new Uint8Array(n);o.set(this.header,0),o.set(t.data,this.header.byteLength),this.format._options.onFrame(o,a)}await this.writer.flush()}finally{s()}}async addSubtitleCue(){throw new Error("ADTS does not support subtitles.")}async finalize(){}}var it;(function(r){r[r.IDR=5]="IDR",r[r.SEI=6]="SEI",r[r.SPS=7]="SPS",r[r.PPS=8]="PPS",r[r.SPS_EXT=13]="SPS_EXT"})(it||(it={}));var oe;(function(r){r[r.RASL_N=8]="RASL_N",r[r.RASL_R=9]="RASL_R",r[r.BLA_W_LP=16]="BLA_W_LP",r[r.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",r[r.VPS_NUT=32]="VPS_NUT",r[r.SPS_NUT=33]="SPS_NUT",r[r.PPS_NUT=34]="PPS_NUT",r[r.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",r[r.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT"})(oe||(oe={}));const Jt=r=>{const e=[];let t=0;for(;t<r.length;){let i=-1,s=0;for(let n=t;n<r.length-3;n++){if(r[n]===0&&r[n+1]===0&&r[n+2]===1){i=n,s=3;break}if(n<r.length-4&&r[n]===0&&r[n+1]===0&&r[n+2]===0&&r[n+3]===1){i=n,s=4;break}}if(i===-1)break;if(t>0&&i>t){const n=r.subarray(t,i);n.length>0&&e.push(n)}t=i+s}if(t<r.length){const i=r.subarray(t);i.length>0&&e.push(i)}return e},Qs=(r,e)=>{const t=[];let i=0;const s=new DataView(r.buffer,r.byteOffset,r.byteLength);for(;i+e<=r.length;){let n;e===1?n=s.getUint8(i):e===2?n=s.getUint16(i,!1):e===3?n=Pr(s,i,!1):e===4?n=s.getUint32(i,!1):(ae(e),m(!1)),i+=e;const a=r.subarray(i,i+n);t.push(a),i+=n}return t},mr=r=>{const e=[],t=r.length;for(let i=0;i<t;i++)i+2<t&&r[i]===0&&r[i+1]===0&&r[i+2]===3?(e.push(0,0),i+=2):e.push(r[i]);return new Uint8Array(e)},Ca=r=>{const t=Jt(r);if(t.length===0)return null;let i=0;for(const o of t)i+=4+o.byteLength;const s=new Uint8Array(i),n=new DataView(s.buffer);let a=0;for(const o of t){const c=o.byteLength;n.setUint32(a,c,!1),a+=4,s.set(o,a),a+=o.byteLength}return s},_a=(r,e)=>{if(e.description){const s=(K(e.description)[4]&3)+1;return Qs(r,s)}else return Jt(r)},Ht=r=>r[0]&31,Ks=r=>{try{const e=Jt(r),t=e.filter(c=>Ht(c)===it.SPS),i=e.filter(c=>Ht(c)===it.PPS),s=e.filter(c=>Ht(c)===it.SPS_EXT);if(t.length===0||i.length===0)return null;const n=t[0],a=Gs(n);m(a!==null);const o=a.profileIdc===100||a.profileIdc===110||a.profileIdc===122||a.profileIdc===144;return{configurationVersion:1,avcProfileIndication:a.profileIdc,profileCompatibility:a.constraintFlags,avcLevelIndication:a.levelIdc,lengthSizeMinusOne:3,sequenceParameterSets:t,pictureParameterSets:i,chromaFormat:o?a.chromaFormatIdc:null,bitDepthLumaMinus8:o?a.bitDepthLumaMinus8:null,bitDepthChromaMinus8:o?a.bitDepthChromaMinus8:null,sequenceParameterSetExt:o?s:null}}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},Pa=r=>{const e=[];e.push(r.configurationVersion),e.push(r.avcProfileIndication),e.push(r.profileCompatibility),e.push(r.avcLevelIndication),e.push(252|r.lengthSizeMinusOne&3),e.push(224|r.sequenceParameterSets.length&31);for(const t of r.sequenceParameterSets){const i=t.byteLength;e.push(i>>8),e.push(i&255);for(let s=0;s<i;s++)e.push(t[s])}e.push(r.pictureParameterSets.length);for(const t of r.pictureParameterSets){const i=t.byteLength;e.push(i>>8),e.push(i&255);for(let s=0;s<i;s++)e.push(t[s])}if(r.avcProfileIndication===100||r.avcProfileIndication===110||r.avcProfileIndication===122||r.avcProfileIndication===144){m(r.chromaFormat!==null),m(r.bitDepthLumaMinus8!==null),m(r.bitDepthChromaMinus8!==null),m(r.sequenceParameterSetExt!==null),e.push(252|r.chromaFormat&3),e.push(248|r.bitDepthLumaMinus8&7),e.push(248|r.bitDepthChromaMinus8&7),e.push(r.sequenceParameterSetExt.length);for(const t of r.sequenceParameterSetExt){const i=t.byteLength;e.push(i>>8),e.push(i&255);for(let s=0;s<i;s++)e.push(t[s])}}return new Uint8Array(e)},va=r=>{try{const e=L(r);let t=0;const i=e.getUint8(t++),s=e.getUint8(t++),n=e.getUint8(t++),a=e.getUint8(t++),o=e.getUint8(t++)&3,c=e.getUint8(t++)&31,l=[];for(let f=0;f<c;f++){const p=e.getUint16(t,!1);t+=2,l.push(r.subarray(t,t+p)),t+=p}const u=e.getUint8(t++),d=[];for(let f=0;f<u;f++){const p=e.getUint16(t,!1);t+=2,d.push(r.subarray(t,t+p)),t+=p}const h={configurationVersion:i,avcProfileIndication:s,profileCompatibility:n,avcLevelIndication:a,lengthSizeMinusOne:o,sequenceParameterSets:l,pictureParameterSets:d,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if((s===100||s===110||s===122||s===144)&&t+4<=r.length){const f=e.getUint8(t++)&3,p=e.getUint8(t++)&7,g=e.getUint8(t++)&7,w=e.getUint8(t++);h.chromaFormat=f,h.bitDepthLumaMinus8=p,h.bitDepthChromaMinus8=g;const T=[];for(let k=0;k<w;k++){const S=e.getUint16(t,!1);t+=2,T.push(r.subarray(t,t+S)),t+=S}h.sequenceParameterSetExt=T}return h}catch(e){return console.error("Error deserializing AVC Decoder Configuration Record:",e),null}},Gs=r=>{try{const e=new W(mr(r));if(e.skipBits(1),e.skipBits(2),e.readBits(5)!==7)return null;const i=e.readAlignedByte(),s=e.readAlignedByte(),n=e.readAlignedByte();E(e);let a=null,o=null,c=null;if((i===100||i===110||i===122||i===244||i===44||i===83||i===86||i===118||i===128)&&(a=E(e),a===3&&e.skipBits(1),o=E(e),c=E(e),e.skipBits(1),e.readBits(1))){for(let h=0;h<(a!==3?8:12);h++)if(e.readBits(1)){const p=h<6?16:64;let g=8,w=8;for(let T=0;T<p;T++){if(w!==0){const k=Ue(e);w=(g+k+256)%256}g=w===0?g:w}}}E(e);const l=E(e);if(l===0)E(e);else if(l===1){e.skipBits(1),Ue(e),Ue(e);const d=E(e);for(let h=0;h<d;h++)Ue(e)}E(e),e.skipBits(1),E(e),E(e);const u=e.readBits(1);return{profileIdc:i,constraintFlags:s,levelIdc:n,frameMbsOnlyFlag:u,chromaFormatIdc:a,bitDepthLumaMinus8:o,bitDepthChromaMinus8:c}}catch(e){return console.error("Error parsing AVC SPS:",e),null}},Xs=(r,e)=>{if(e.description){const s=(K(e.description)[21]&3)+1;return Qs(r,s)}else return Jt(r)},je=r=>r[0]>>1&63,Ys=r=>{try{const e=Jt(r),t=e.filter(R=>je(R)===oe.VPS_NUT),i=e.filter(R=>je(R)===oe.SPS_NUT),s=e.filter(R=>je(R)===oe.PPS_NUT),n=e.filter(R=>je(R)===oe.PREFIX_SEI_NUT||je(R)===oe.SUFFIX_SEI_NUT);if(i.length===0||s.length===0)return null;const a=i[0],o=new W(mr(a));o.skipBits(16),o.readBits(4);const c=o.readBits(3),l=o.readBits(1),{general_profile_space:u,general_tier_flag:d,general_profile_idc:h,general_profile_compatibility_flags:f,general_constraint_indicator_flags:p,general_level_idc:g}=Ia(o,c);E(o);const w=E(o);w===3&&o.skipBits(1),E(o),E(o),o.readBits(1)&&(E(o),E(o),E(o),E(o));const T=E(o),k=E(o);E(o);const y=o.readBits(1)?0:c;for(let R=y;R<=c;R++)E(o),E(o),E(o);E(o),E(o),E(o),E(o),E(o),E(o),o.readBits(1)&&o.readBits(1)&&Ea(o),o.skipBits(1),o.skipBits(1),o.readBits(1)&&(o.skipBits(4),o.skipBits(4),E(o),E(o),o.skipBits(1));const x=E(o);if(Aa(o,x),o.readBits(1)){const R=E(o);for(let F=0;F<R;F++)E(o),o.skipBits(1)}o.skipBits(1),o.skipBits(1);let v=0;o.readBits(1)&&(v=Ba(o,c));let C=0;if(s.length>0){const R=s[0],F=new W(mr(R));F.skipBits(16),E(F),E(F),F.skipBits(1),F.skipBits(1),F.skipBits(3),F.skipBits(1),F.skipBits(1),E(F),E(F),Ue(F),F.skipBits(1),F.skipBits(1),F.readBits(1)&&E(F),Ue(F),Ue(F),F.skipBits(1),F.skipBits(1),F.skipBits(1),F.skipBits(1);const U=F.readBits(1),q=F.readBits(1);!U&&!q?C=0:U&&!q?C=2:!U&&q?C=3:C=0}const P=[...t.length?[{arrayCompleteness:1,nalUnitType:oe.VPS_NUT,nalUnits:t}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:oe.SPS_NUT,nalUnits:i}]:[],...s.length?[{arrayCompleteness:1,nalUnitType:oe.PPS_NUT,nalUnits:s}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:je(n[0]),nalUnits:n}]:[]];return{configurationVersion:1,generalProfileSpace:u,generalTierFlag:d,generalProfileIdc:h,generalProfileCompatibilityFlags:f,generalConstraintIndicatorFlags:p,generalLevelIdc:g,minSpatialSegmentationIdc:v,parallelismType:C,chromaFormatIdc:w,bitDepthLumaMinus8:T,bitDepthChromaMinus8:k,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:c+1,temporalIdNested:l,lengthSizeMinusOne:3,arrays:P}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Ia=(r,e)=>{const t=r.readBits(2),i=r.readBits(1),s=r.readBits(5);let n=0;for(let u=0;u<32;u++)n=n<<1|r.readBits(1);const a=new Uint8Array(6);for(let u=0;u<6;u++)a[u]=r.readBits(8);const o=r.readBits(8),c=[],l=[];for(let u=0;u<e;u++)c.push(r.readBits(1)),l.push(r.readBits(1));if(e>0)for(let u=e;u<8;u++)r.skipBits(2);for(let u=0;u<e;u++)c[u]&&r.skipBits(88),l[u]&&r.skipBits(8);return{general_profile_space:t,general_tier_flag:i,general_profile_idc:s,general_profile_compatibility_flags:n,general_constraint_indicator_flags:a,general_level_idc:o}},Ea=r=>{for(let e=0;e<4;e++)for(let t=0;t<(e===3?2:6);t++)if(!r.readBits(1))E(r);else{const s=Math.min(64,1<<4+(e<<1));e>1&&Ue(r);for(let n=0;n<s;n++)Ue(r)}},Aa=(r,e)=>{const t=[];for(let i=0;i<e;i++)t[i]=Fa(r,i,e,t)},Fa=(r,e,t,i)=>{let s=0,n=0,a=0;if(e!==0&&(n=r.readBits(1)),n){if(e===t){const c=E(r);a=e-(c+1)}else a=e-1;r.readBits(1),E(r);const o=i[a]??0;for(let c=0;c<=o;c++)r.readBits(1)||r.readBits(1);s=i[a]}else{const o=E(r),c=E(r);for(let l=0;l<o;l++)E(r),r.readBits(1);for(let l=0;l<c;l++)E(r),r.readBits(1);s=o+c}return s},Ba=(r,e)=>{if(r.readBits(1)&&r.readBits(8)===255&&(r.readBits(16),r.readBits(16)),r.readBits(1)&&r.readBits(1),r.readBits(1)&&(r.readBits(3),r.readBits(1),r.readBits(1)&&(r.readBits(8),r.readBits(8),r.readBits(8))),r.readBits(1)&&(E(r),E(r)),r.readBits(1),r.readBits(1),r.readBits(1),r.readBits(1)&&(E(r),E(r),E(r),E(r)),r.readBits(1)&&(r.readBits(32),r.readBits(32),r.readBits(1)&&E(r),r.readBits(1)&&za(r,!0,e)),r.readBits(1)){r.readBits(1),r.readBits(1),r.readBits(1);const t=E(r);return E(r),E(r),E(r),E(r),t}return 0},za=(r,e,t)=>{let i=!1,s=!1,n=!1;i=r.readBits(1)===1,s=r.readBits(1)===1,(i||s)&&(n=r.readBits(1)===1,n&&(r.readBits(8),r.readBits(5),r.readBits(1),r.readBits(5)),r.readBits(4),r.readBits(4),n&&r.readBits(4),r.readBits(5),r.readBits(5),r.readBits(5));for(let a=0;a<=t;a++){const o=r.readBits(1)===1;let c=!0;o||(c=r.readBits(1)===1);let l=!1;c?E(r):l=r.readBits(1)===1;let u=1;l||(u=E(r)+1),i&&is(r,u,n),s&&is(r,u,n)}},is=(r,e,t)=>{for(let i=0;i<e;i++)E(r),E(r),t&&(E(r),E(r)),r.readBits(1)},Ra=r=>{const e=[];e.push(r.configurationVersion),e.push((r.generalProfileSpace&3)<<6|(r.generalTierFlag&1)<<5|r.generalProfileIdc&31),e.push(r.generalProfileCompatibilityFlags>>>24&255),e.push(r.generalProfileCompatibilityFlags>>>16&255),e.push(r.generalProfileCompatibilityFlags>>>8&255),e.push(r.generalProfileCompatibilityFlags&255),e.push(...r.generalConstraintIndicatorFlags),e.push(r.generalLevelIdc&255),e.push(240|r.minSpatialSegmentationIdc>>8&15),e.push(r.minSpatialSegmentationIdc&255),e.push(252|r.parallelismType&3),e.push(252|r.chromaFormatIdc&3),e.push(248|r.bitDepthLumaMinus8&7),e.push(248|r.bitDepthChromaMinus8&7),e.push(r.avgFrameRate>>8&255),e.push(r.avgFrameRate&255),e.push((r.constantFrameRate&3)<<6|(r.numTemporalLayers&7)<<3|(r.temporalIdNested&1)<<2|r.lengthSizeMinusOne&3),e.push(r.arrays.length&255);for(const t of r.arrays){e.push((t.arrayCompleteness&1)<<7|0|t.nalUnitType&63),e.push(t.nalUnits.length>>8&255),e.push(t.nalUnits.length&255);for(const i of t.nalUnits){e.push(i.length>>8&255),e.push(i.length&255);for(let s=0;s<i.length;s++)e.push(i[s])}}return new Uint8Array(e)},Zs=r=>{const e=new W(r);if(e.readBits(2)!==2)return null;const i=e.readBits(1),n=(e.readBits(1)<<1)+i;if(n===3&&e.skipBits(1),e.readBits(1)===1||e.readBits(1)!==0||(e.skipBits(2),e.readBits(24)!==4817730))return null;let l=8;n>=2&&(l=e.readBits(1)?12:10);const u=e.readBits(3);let d=0,h=0;if(u!==7)if(h=e.readBits(1),n===1||n===3){const C=e.readBits(1),P=e.readBits(1);d=!C&&!P?3:C&&!P?2:1,e.skipBits(1)}else d=1;else d=3,h=1;const f=e.readBits(16),p=e.readBits(16),g=f+1,w=p+1,T=g*w;let k=X(Ge).level;for(const v of Ge)if(T<=v.maxPictureSize){k=v.level;break}return{profile:n,level:k,bitDepth:l,chromaSubsampling:d,videoFullRangeFlag:h,colourPrimaries:u===2?1:u===1?6:2,transferCharacteristics:u===2?1:u===1?6:2,matrixCoefficients:u===7?0:u===2?1:u===1?6:2}},Js=function*(r){const e=new W(r),t=()=>{let i=0;for(let s=0;s<8;s++){const n=e.readAlignedByte();if(i|=(n&127)<<s*7,!(n&128))break;if(s===7&&n&128)return null}return i>=2**32-1?null:i};for(;e.getBitsLeft()>=8;){e.skipBits(1);const i=e.readBits(4),s=e.readBits(1),n=e.readBits(1);e.skipBits(1),s&&e.skipBits(8);let a;if(n){const o=t();if(o===null)return;a=o}else a=Math.floor(e.getBitsLeft()/8);m(e.pos%8===0),yield{type:i,data:r.subarray(e.pos/8,e.pos/8+a)},e.skipBits(a*8)}},en=r=>{for(const{type:e,data:t}of Js(r)){if(e!==1)continue;const i=new W(t),s=i.readBits(3);i.readBits(1);const n=i.readBits(1);let a=0,o=0,c=0;if(n)a=i.readBits(5);else{if(i.readBits(1)&&(i.skipBits(32),i.skipBits(32),i.readBits(1)))return null;const x=i.readBits(1);x&&(c=i.readBits(5),i.skipBits(32),i.skipBits(5),i.skipBits(5));const v=i.readBits(5);for(let C=0;C<=v;C++){i.skipBits(12);const P=i.readBits(5);if(C===0&&(a=P),P>7){const R=i.readBits(1);C===0&&(o=R)}if(x&&i.readBits(1)){const F=c+1;i.skipBits(F),i.skipBits(F),i.skipBits(1)}i.readBits(1)&&i.skipBits(4)}}const l=i.readBits(4),u=i.readBits(4),d=l+1;i.skipBits(d);const h=u+1;i.skipBits(h);let f=0;if(n?f=0:f=i.readBits(1),f&&(i.skipBits(4),i.skipBits(3)),i.skipBits(1),i.skipBits(1),i.skipBits(1),!n){i.skipBits(1),i.skipBits(1),i.skipBits(1),i.skipBits(1);const y=i.readBits(1);y&&(i.skipBits(1),i.skipBits(1));const x=i.readBits(1);let v=0;x?v=2:v=i.readBits(1),v>0&&(i.readBits(1)||i.skipBits(1)),y&&i.skipBits(3)}i.skipBits(1),i.skipBits(1),i.skipBits(1);const p=i.readBits(1);let g=8;s===2&&p?g=i.readBits(1)?12:10:s<=2&&(g=p?10:8);let w=0;s!==1&&(w=i.readBits(1));let T=1,k=1,S=0;return w||(s===0?(T=1,k=1):s===1?(T=0,k=0):g===12&&(T=i.readBits(1),T&&(k=i.readBits(1))),T&&k&&(S=i.readBits(2))),{profile:s,level:a,tier:o,bitDepth:g,monochrome:w,chromaSubsamplingX:T,chromaSubsamplingY:k,chromaSamplePosition:S}}return null},Er=r=>{const e=L(r),t=e.getUint8(9),i=e.getUint16(10,!0),s=e.getUint32(12,!0),n=e.getInt16(16,!0),a=e.getUint8(18);let o=null;return a&&(o=r.subarray(19,21+t)),{outputChannelCount:t,preSkip:i,inputSampleRate:s,outputGain:n,channelMappingFamily:a,channelMappingTable:o}},Ma=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],Da=r=>{const e=r[0]>>3;return{durationInSamples:Ma[e]}},tn=r=>{if(r.length<7)throw new Error("Setup header is too short.");if(r[0]!==5)throw new Error("Wrong packet type in Setup header.");if(String.fromCharCode(...r.slice(1,7))!=="vorbis")throw new Error("Invalid packet signature in Setup header.");const t=r.length,i=new Uint8Array(t);for(let d=0;d<t;d++)i[d]=r[t-1-d];const s=new W(i);let n=0;for(;s.getBitsLeft()>97;)if(s.readBits(1)===1){n=s.pos;break}if(n===0)throw new Error("Invalid Setup header: framing bit not found.");let a=0,o=!1,c=0;for(;s.getBitsLeft()>=97;){const d=s.pos,h=s.readBits(8),f=s.readBits(16),p=s.readBits(16);if(h>63||f!==0||p!==0){s.pos=d;break}if(s.skipBits(1),a++,a>64)break;s.clone().readBits(6)+1===a&&(o=!0,c=a)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(c>63)throw new Error(`Unsupported mode count: ${c}.`);const l=c;s.pos=0,s.skipBits(n);const u=Array(l).fill(0);for(let d=l-1;d>=0;d--)s.skipBits(40),u[d]=s.readBits(1);return{modeBlockflags:u}},rn=(r,e,t)=>{switch(r){case"avc":{const i=_a(t,e);let s=i.some(n=>Ht(n)===it.IDR);if(!s&&(!Ns()||na()>=144))for(const n of i){if(Ht(n)!==it.SEI)continue;const o=mr(n);let c=1;do{let l=0;for(;;){const h=o[c++];if(h===void 0||(l+=h,h<255))break}let u=0;for(;;){const h=o[c++];if(h===void 0||(u+=h,h<255))break}if(l===6){const h=new W(o);h.pos=8*c;const f=E(h),p=h.readBits(1);if(f===0&&p===1){s=!0;break}}c+=u}while(c<o.length-1)}return s?"key":"delta"}case"hevc":return Xs(t,e).some(n=>{const a=je(n);return oe.BLA_W_LP<=a&&a<=oe.RSV_IRAP_VCL23})?"key":"delta";case"vp8":return(t[0]&1)===0?"key":"delta";case"vp9":{const i=new W(t);if(i.readBits(2)!==2)return null;const s=i.readBits(1);return(i.readBits(1)<<1)+s===3&&i.skipBits(1),i.readBits(1)?null:i.readBits(1)===0?"key":"delta"}case"av1":{let i=!1;for(const{type:s,data:n}of Js(t))if(s===1){const a=new W(n);a.skipBits(4),i=!!a.readBits(1)}else if(s===3||s===6||s===7){if(i)return"key";const a=new W(n);return a.readBits(1)?null:a.readBits(2)===0?"key":"delta"}return null}default:ae(r),m(!1)}};var Ne;(function(r){r[r.STREAMINFO=0]="STREAMINFO",r[r.VORBIS_COMMENT=4]="VORBIS_COMMENT",r[r.PICTURE=6]="PICTURE"})(Ne||(Ne={}));const ei=(r,e)=>{const t=L(r);let i=0;const s=t.getUint32(i,!0);i+=4;const n=ke.decode(r.subarray(i,i+s));i+=s,s>0&&(e.raw??={},e.raw.vendor??=n);const a=t.getUint32(i,!0);i+=4;for(let o=0;o<a;o++){const c=t.getUint32(i,!0);i+=4;const l=ke.decode(r.subarray(i,i+c));i+=c;const u=l.indexOf("=");if(u===-1)continue;const d=l.slice(0,u).toUpperCase(),h=l.slice(u+1);switch(e.raw??={},e.raw[d]??=h,d){case"TITLE":e.title??=h;break;case"DESCRIPTION":e.description??=h;break;case"ARTIST":e.artist??=h;break;case"ALBUM":e.album??=h;break;case"ALBUMARTIST":e.albumArtist??=h;break;case"COMMENT":e.comment??=h;break;case"LYRICS":e.lyrics??=h;break;case"TRACKNUMBER":{const f=h.split("/"),p=Number.parseInt(f[0],10),g=f[1]&&Number.parseInt(f[1],10);Number.isInteger(p)&&p>0&&(e.trackNumber??=p),g&&Number.isInteger(g)&&g>0&&(e.tracksTotal??=g)}break;case"TRACKTOTAL":{const f=Number.parseInt(h,10);Number.isInteger(f)&&f>0&&(e.tracksTotal??=f)}break;case"DISCNUMBER":{const f=h.split("/"),p=Number.parseInt(f[0],10),g=f[1]&&Number.parseInt(f[1],10);Number.isInteger(p)&&p>0&&(e.discNumber??=p),g&&Number.isInteger(g)&&g>0&&(e.discsTotal??=g)}break;case"DISCTOTAL":{const f=Number.parseInt(h,10);Number.isInteger(f)&&f>0&&(e.discsTotal??=f)}break;case"DATE":{const f=new Date(h);Number.isNaN(f.getTime())||(e.date??=f)}break;case"GENRE":e.genre??=h;break;case"METADATA_BLOCK_PICTURE":{const f=oa(h),p=L(f),g=p.getUint32(0,!1),w=p.getUint32(4,!1),T=String.fromCharCode(...f.subarray(8,8+w)),k=p.getUint32(8+w,!1),S=ke.decode(f.subarray(12+w,12+w+k)),y=p.getUint32(w+k+28),x=f.subarray(w+k+32,w+k+32+y);e.images??=[],e.images.push({data:x,mimeType:T,kind:g===3?"coverFront":g===4?"coverBack":"unknown",name:void 0,description:S||void 0})}break}}},ti=(r,e,t)=>{const i=[r],n=j.encode("Mediabunny");let a=new Uint8Array(4+n.length),o=new DataView(a.buffer);o.setUint32(0,n.length,!0),a.set(n,4),i.push(a);const c=new Set,l=(p,g)=>{const w=`${p}=${g}`,T=j.encode(w);a=new Uint8Array(4+T.length),o=new DataView(a.buffer),o.setUint32(0,T.length,!0),a.set(T,4),i.push(a),c.add(p)};for(const{key:p,value:g}of Ft(e))switch(p){case"title":l("TITLE",g);break;case"description":l("DESCRIPTION",g);break;case"artist":l("ARTIST",g);break;case"album":l("ALBUM",g);break;case"albumArtist":l("ALBUMARTIST",g);break;case"genre":l("GENRE",g);break;case"date":{const w=e.raw?.DATE??e.raw?.date;w&&typeof w=="string"?l("DATE",w):l("DATE",g.toISOString().slice(0,10))}break;case"comment":l("COMMENT",g);break;case"lyrics":l("LYRICS",g);break;case"trackNumber":l("TRACKNUMBER",g.toString());break;case"tracksTotal":l("TRACKTOTAL",g.toString());break;case"discNumber":l("DISCNUMBER",g.toString());break;case"discsTotal":l("DISCTOTAL",g.toString());break;case"images":{if(!t)break;for(const w of g){const T=w.kind==="coverFront"?3:w.kind==="coverBack"?4:0,k=new Uint8Array(w.mimeType.length);for(let C=0;C<w.mimeType.length;C++)k[C]=w.mimeType.charCodeAt(C);const S=j.encode(w.description??""),y=new Uint8Array(8+k.length+4+S.length+16+4+w.data.length),x=L(y);x.setUint32(0,T,!1),x.setUint32(4,k.length,!1),y.set(k,8),x.setUint32(8+k.length,S.length,!1),y.set(S,12+k.length),x.setUint32(28+k.length+S.length,w.data.length,!1),y.set(w.data,32+k.length+S.length);const v=ca(y);l("METADATA_BLOCK_PICTURE",v)}}break;case"raw":break;default:ae(p)}if(e.raw)for(const p in e.raw){const g=e.raw[p]??e.raw[p.toLowerCase()];p==="vendor"||g==null||c.has(p)||typeof g=="string"&&l(p,g)}const u=new Uint8Array(4);L(u).setUint32(0,c.size,!0),i.splice(2,0,u);const d=i.reduce((p,g)=>p+g.length,0),h=new Uint8Array(d);let f=0;for(const p of i)h.set(p,f),f+=p.length;return h};class ct{constructor(e){this.input=e}}class Ua{static supports(e,t){return!1}}class Na{static supports(e,t){return!1}}class Oa{static supports(e,t){return!1}}class Va{static supports(e,t){return!1}}const pr=[],gr=[],Kt=[],Gt=[],Zl=r=>{if(r.prototype instanceof Ua){const e=r;if(pr.includes(e)){console.warn("Video decoder already registered.");return}pr.push(e)}else if(r.prototype instanceof Na){const e=r;if(gr.includes(e)){console.warn("Audio decoder already registered.");return}gr.push(e)}else throw new TypeError("Decoder must be a CustomVideoDecoder or CustomAudioDecoder.")},Jl=r=>{if(r.prototype instanceof Oa){const e=r;if(Kt.includes(e)){console.warn("Video encoder already registered.");return}Kt.push(e)}else if(r.prototype instanceof Va){const e=r;if(Gt.includes(e)){console.warn("Audio encoder already registered.");return}Gt.push(e)}else throw new TypeError("Encoder must be a CustomVideoEncoder or CustomAudioEncoder.")},Te=new Uint8Array(0);class ${constructor(e,t,i,s,n=-1,a,o){if(this.data=e,this.type=t,this.timestamp=i,this.duration=s,this.sequenceNumber=n,e===Te&&a===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(a===void 0&&(a=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(t!=="key"&&t!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(i))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(s)||s<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(n))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(a)||a<0)throw new TypeError("byteLength must be a non-negative integer.");if(o!==void 0&&(typeof o!="object"||!o))throw new TypeError("sideData, when provided, must be an object.");if(o?.alpha!==void 0&&!(o.alpha instanceof Uint8Array))throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");if(o?.alphaByteLength!==void 0&&(!Number.isInteger(o.alphaByteLength)||o.alphaByteLength<0))throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");this.byteLength=a,this.sideData=o??{},this.sideData.alpha&&this.sideData.alphaByteLength===void 0&&(this.sideData.alphaByteLength=this.sideData.alpha.byteLength)}get isMetadataOnly(){return this.data===Te}get microsecondTimestamp(){return Math.trunc(Ke*this.timestamp)}get microsecondDuration(){return Math.trunc(Ke*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}alphaToEncodedVideoChunk(e=this.type){if(!this.sideData.alpha)throw new TypeError("This packet does not contain alpha side data.");if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.sideData.alpha,type:e,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e,t){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const i=new Uint8Array(e.byteLength);return e.copyTo(i),new $(i,e.type,e.timestamp/1e6,(e.duration??0)/1e6,void 0,void 0,t)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if(e?.timestamp!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if(e?.duration!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");return new $(this.data,this.type,e?.timestamp??this.timestamp,e?.duration??this.duration,this.sequenceNumber,this.byteLength)}}const Wa=r=>{let i=r,s=4096,n=0,a=12,o=0;for(i<0&&(i=-i,n=128),i+=33,i>8191&&(i=8191);(i&s)!==s&&a>=5;)s>>=1,a--;return o=i>>a-4&15,~(n|a-5<<4|o)&255},La=r=>{let t=0,i=0,s=~r;s&128&&(s&=-129,t=-1),i=((s&240)>>4)+5;const n=(1<<i|(s&15)<<i-4|1<<i-5)-33;return t===0?n:-n},Ha=r=>{let t=2048,i=0,s=11,n=0,a=r;for(a<0&&(a=-a,i=128),a>4095&&(a=4095);(a&t)!==t&&s>=5;)t>>=1,s--;return n=a>>(s===4?1:s-4)&15,(i|s-4<<4|n)^85},qa=r=>{let e=0,t=0,i=r^85;i&128&&(i&=-129,e=-1),t=((i&240)>>4)+4;let s=0;return t!==4?s=1<<t|(i&15)<<t-4|1<<t-5:s=i<<1|1,e===0?s:-s};Os();let ss=-1/0,ns=-1/0,Xt=null;typeof FinalizationRegistry<"u"&&(Xt=new FinalizationRegistry(r=>{const e=Date.now();r.type==="video"?(e-ss>=1e3&&(console.error("A VideoSample was garbage collected without first being closed. For proper resource management, make sure to call close() on all your VideoSamples as soon as you're done using them."),ss=e),typeof VideoFrame<"u"&&r.data instanceof VideoFrame&&r.data.close()):(e-ns>=1e3&&(console.error("An AudioSample was garbage collected without first being closed. For proper resource management, make sure to call close() on all your AudioSamples as soon as you're done using them."),ns=e),typeof AudioData<"u"&&r.data instanceof AudioData&&r.data.close())}));class ee{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(Ke*this.timestamp)}get microsecondDuration(){return Math.trunc(Ke*this.duration)}get hasAlpha(){return this.format&&this.format.includes("A")}constructor(e,t){if(this._closed=!1,e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer||ArrayBuffer.isView(e)){if(!t||typeof t!="object")throw new TypeError("init must be an object.");if(!("format"in t)||typeof t.format!="string")throw new TypeError("init.format must be a string.");if(!Number.isInteger(t.codedWidth)||t.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(t.codedHeight)||t.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(t.timestamp))throw new TypeError("init.timestamp must be a number.");if(t.duration!==void 0&&(!Number.isFinite(t.duration)||t.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=K(e).slice(),this.format=t.format,this.codedWidth=t.codedWidth,this.codedHeight=t.codedHeight,this.rotation=t.rotation??0,this.timestamp=t.timestamp,this.duration=t.duration??0,this.colorSpace=new VideoColorSpace(t.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if(t?.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(t?.timestamp!==void 0&&!Number.isFinite(t?.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if(t?.duration!==void 0&&(!Number.isFinite(t.duration)||t.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this.format=e.format,this.codedWidth=e.displayWidth,this.codedHeight=e.displayHeight,this.rotation=t?.rotation??0,this.timestamp=t?.timestamp??e.timestamp/1e6,this.duration=t?.duration??(e.duration??0)/1e6,this.colorSpace=e.colorSpace}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!t||typeof t!="object")throw new TypeError("init must be an object.");if(t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(t.timestamp))throw new TypeError("init.timestamp must be a number.");if(t.duration!==void 0&&(!Number.isFinite(t.duration)||t.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new ee(new VideoFrame(e,{timestamp:Math.trunc(t.timestamp*Ke),duration:Math.trunc((t.duration??0)*Ke)||void 0}),t);let i=0,s=0;if("naturalWidth"in e?(i=e.naturalWidth,s=e.naturalHeight):"videoWidth"in e?(i=e.videoWidth,s=e.videoHeight):"width"in e&&(i=Number(e.width),s=Number(e.height)),!i||!s)throw new TypeError("Could not determine dimensions.");const n=new OffscreenCanvas(i,s),a=n.getContext("2d",{alpha:Pt(),willReadFrequently:!0});m(a),a.drawImage(e,0,0),this._data=n,this.format="RGBX",this.codedWidth=i,this.codedHeight=s,this.rotation=t.rotation??0,this.timestamp=t.timestamp,this.duration=t.duration??0,this.colorSpace=new VideoColorSpace({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.");Xt?.register(this,{type:"video",data:this._data},this)}clone(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),Mt(this._data)?new ee(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?new ee(this._data.slice(),{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation}):new ee(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(Xt?.unregister(this),Mt(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),Mt(this._data)?this._data.allocationSize():this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e){if(!Cr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),Mt(this._data))await this._data.copyTo(e);else if(this._data instanceof Uint8Array)K(e).set(this._data);else{const i=this._data.getContext("2d");m(i);const s=i.getImageData(0,0,this.codedWidth,this.codedHeight);K(e).set(s.data)}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),Mt(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0})}draw(e,t,i,s,n,a,o,c,l){let u=0,d=0,h=this.displayWidth,f=this.displayHeight,p=0,g=0,w=this.displayWidth,T=this.displayHeight;if(a!==void 0?(u=t,d=i,h=s,f=n,p=a,g=o,c!==void 0?(w=c,T=l):(w=h,T=f)):(p=t,g=i,s!==void 0&&(w=s,T=n)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(u))throw new TypeError("sx must be a number.");if(!Number.isFinite(d))throw new TypeError("sy must be a number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(f)||f<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(p))throw new TypeError("dx must be a number.");if(!Number.isFinite(g))throw new TypeError("dy must be a number.");if(!Number.isFinite(w)||w<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(T)||T<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");({sx:u,sy:d,sWidth:h,sHeight:f}=this._rotateSourceRegion(u,d,h,f,this.rotation));const k=this.toCanvasImageSource();e.save();const S=p+w/2,y=g+T/2;e.translate(S,y),e.rotate(this.rotation*Math.PI/180);const x=this.rotation%180===0?1:w/T;e.scale(1/x,x),e.drawImage(k,u,d,h,f,-w/2,-T/2,w,T),e.restore()}drawWithFit(e,t){if(!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(!["fill","contain","cover"].includes(t.fit))throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");if(t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");t.crop!==void 0&&_i(t.crop,"options.");const i=e.canvas.width,s=e.canvas.height,n=t.rotation??this.rotation,[a,o]=n%180===0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth];t.crop&&Ci(t.crop,a,o);let c,l,u,d;const{sx:h,sy:f,sWidth:p,sHeight:g}=this._rotateSourceRegion(t.crop?.left??0,t.crop?.top??0,t.crop?.width??a,t.crop?.height??o,n);if(t.fit==="fill")c=0,l=0,u=i,d=s;else{const[T,k]=t.crop?[t.crop.width,t.crop.height]:[a,o],S=t.fit==="contain"?Math.min(i/T,s/k):Math.max(i/T,s/k);u=T*S,d=k*S,c=(i-u)/2,l=(s-d)/2}e.save();const w=n%180===0?1:u/d;e.translate(i/2,s/2),e.rotate(n*Math.PI/180),e.scale(1/w,w),e.translate(-i/2,-s/2),e.drawImage(this.toCanvasImageSource(),h,f,p,g,c,l,u,d),e.restore()}_rotateSourceRegion(e,t,i,s,n){return n===90?[e,t,i,s]=[t,this.codedHeight-e-i,s,i]:n===180?[e,t]=[this.codedWidth-e-i,this.codedHeight-t-s]:n===270&&([e,t,i,s]=[this.codedWidth-t-s,e,s,i]),{sx:e,sy:t,sWidth:i,sHeight:s}}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}[Symbol.dispose](){this.close()}}const Mt=r=>typeof VideoFrame<"u"&&r instanceof VideoFrame,Ci=(r,e,t)=>{r.left=Math.min(r.left,e),r.top=Math.min(r.top,t),r.width=Math.min(r.width,e-r.left),r.height=Math.min(r.height,t-r.top),m(r.width>=0),m(r.height>=0)},_i=(r,e)=>{if(!r||typeof r!="object")throw new TypeError(e+"crop, when provided, must be an object.");if(!Number.isInteger(r.left)||r.left<0)throw new TypeError(e+"crop.left must be a non-negative integer.");if(!Number.isInteger(r.top)||r.top<0)throw new TypeError(e+"crop.top must be a non-negative integer.");if(!Number.isInteger(r.width)||r.width<0)throw new TypeError(e+"crop.width must be a non-negative integer.");if(!Number.isInteger(r.height)||r.height<0)throw new TypeError(e+"crop.height must be a non-negative integer.")},Rr=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class ne{get microsecondTimestamp(){return Math.trunc(Ke*this.timestamp)}get microsecondDuration(){return Math.trunc(Ke*this.duration)}constructor(e){if(this._closed=!1,Ut(e)){if(e.format===null)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||typeof e!="object")throw new TypeError("Invalid AudioDataInit: must be an object.");if(!Rr.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels===0)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e?.timestamp))throw new TypeError("init.timestamp must be a number.");const t=e.data.byteLength/(Dt(e.format)*e.numberOfChannels);if(!Number.isInteger(t))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=t,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=t/e.sampleRate;let i;if(e.data instanceof ArrayBuffer)i=new Uint8Array(e.data);else if(ArrayBuffer.isView(e.data))i=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);else throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");const s=this.numberOfFrames*this.numberOfChannels*Dt(this.format);if(i.byteLength<s)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=i}Xt?.register(this,{type:"audio",data:this._data},this)}allocationSize(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(e.format!==void 0&&!Rr.has(e.format))throw new TypeError("Invalid format.");if(e.frameOffset!==void 0&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(e.frameCount!==void 0&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const t=e.format??this.format,i=e.frameOffset??0;if(i>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const s=e.frameCount!==void 0?e.frameCount:this.numberOfFrames-i;if(s>this.numberOfFrames-i)throw new RangeError("frameCount out of range");const n=Dt(t),a=nr(t);if(a&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!a&&e.planeIndex!==0)throw new RangeError("planeIndex out of range");return(a?s:s*this.numberOfChannels)*n}copyTo(e,t){if(!Cr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(t.planeIndex)||t.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(t.format!==void 0&&!Rr.has(t.format))throw new TypeError("Invalid format.");if(t.frameOffset!==void 0&&(!Number.isInteger(t.frameOffset)||t.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(t.frameCount!==void 0&&(!Number.isInteger(t.frameCount)||t.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:i,format:s,frameCount:n,frameOffset:a}=t,o=s??this.format;if(!o)throw new Error("Destination format not determined");const c=this.numberOfFrames,l=this.numberOfChannels,u=a??0;if(u>=c)throw new RangeError("frameOffset out of range");const d=n!==void 0?n:c-u;if(d>c-u)throw new RangeError("frameCount out of range");const h=Dt(o),f=nr(o);if(f&&i>=l)throw new RangeError("planeIndex out of range");if(!f&&i!==0)throw new RangeError("planeIndex out of range");const g=(f?d:d*l)*h;if(e.byteLength<g)throw new RangeError("Destination buffer is too small");const w=L(e),T=$a(o);if(Ut(this._data))if(f)if(o==="f32-planar")this._data.copyTo(e,{planeIndex:i,frameOffset:u,frameCount:d,format:"f32-planar"});else{const k=new ArrayBuffer(d*4),S=new Float32Array(k);this._data.copyTo(S,{planeIndex:i,frameOffset:u,frameCount:d,format:"f32-planar"});const y=new DataView(k);for(let x=0;x<d;x++){const v=x*h,C=y.getFloat32(x*4,!0);T(w,v,C)}}else{const k=l,S=new Float32Array(d);for(let y=0;y<k;y++){this._data.copyTo(S,{planeIndex:y,frameOffset:u,frameCount:d,format:"f32-planar"});for(let x=0;x<d;x++){const C=(x*k+y)*h;T(w,C,S[x])}}}else{const k=this._data,S=L(k),y=this.format,x=ja(y),v=Dt(y),C=nr(y);for(let P=0;P<d;P++)if(f){const A=P*h;let R;C?R=(i*c+(P+u))*v:R=((P+u)*l+i)*v;const F=x(S,R);T(w,A,F)}else for(let A=0;A<l;A++){const F=(P*l+A)*h;let U;C?U=(A*c+(P+u))*v:U=((P+u)*l+A)*v;const q=x(S,U);T(w,F,q)}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(Ut(this._data)){const e=new ne(this._data.clone());return e.setTimestamp(this.timestamp),e}else return new ne({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||(Xt?.unregister(this),Ut(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(Ut(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(nr(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),t=new ArrayBuffer(e*this.numberOfChannels);for(let i=0;i<this.numberOfChannels;i++)this.copyTo(new Uint8Array(t,i*e,e),{planeIndex:i,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:t})}else{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}else return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data.buffer instanceof ArrayBuffer?this._data.buffer:this._data.slice()})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),t=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let i=0;i<this.numberOfChannels;i++)this.copyTo(t,{planeIndex:i,format:"f32-planar"}),e.copyToChannel(t,i);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}[Symbol.dispose](){this.close()}static*_fromAudioBuffer(e,t){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const i=48e3*5,s=e.numberOfChannels,n=e.sampleRate,a=e.length,o=Math.floor(i/s);let c=0,l=a;for(;l>0;){const u=Math.min(o,l),d=new Float32Array(s*u);for(let h=0;h<s;h++)e.copyFromChannel(d.subarray(h*u,(h+1)*u),h,c);yield new ne({format:"f32-planar",sampleRate:n,numberOfFrames:u,numberOfChannels:s,timestamp:t+c/n,data:d}),c+=u,l-=u}}static fromAudioBuffer(e,t){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const i=48e3*5,s=e.numberOfChannels,n=e.sampleRate,a=e.length,o=Math.floor(i/s);let c=0,l=a;const u=[];for(;l>0;){const d=Math.min(o,l),h=new Float32Array(s*d);for(let p=0;p<s;p++)e.copyFromChannel(h.subarray(p*d,(p+1)*d),p,c);const f=new ne({format:"f32-planar",sampleRate:n,numberOfFrames:d,numberOfChannels:s,timestamp:t+c/n,data:h});u.push(f),c+=d,l-=d}return u}}const Dt=r=>{switch(r){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":return 4;case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},nr=r=>{switch(r){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},ja=r=>{switch(r){case"u8":case"u8-planar":return(e,t)=>(e.getUint8(t)-128)/128;case"s16":case"s16-planar":return(e,t)=>e.getInt16(t,!0)/32768;case"s32":case"s32-planar":return(e,t)=>e.getInt32(t,!0)/2147483648;case"f32":case"f32-planar":return(e,t)=>e.getFloat32(t,!0)}},$a=r=>{switch(r){case"u8":case"u8-planar":return(e,t,i)=>e.setUint8(t,J((i+1)*127.5,0,255));case"s16":case"s16-planar":return(e,t,i)=>e.setInt16(t,J(Math.round(i*32767),-32768,32767),!0);case"s32":case"s32-planar":return(e,t,i)=>e.setInt32(t,J(Math.round(i*2147483647),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,t,i)=>e.setFloat32(t,i,!0)}},Ut=r=>typeof AudioData<"u"&&r instanceof AudioData,ht=r=>{if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.metadataOnly!==void 0&&typeof r.metadataOnly!="boolean")throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(r.verifyKeyPackets!==void 0&&typeof r.verifyKeyPackets!="boolean")throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(r.verifyKeyPackets&&r.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},Oe=r=>{if(!Bt(r))throw new TypeError("timestamp must be a number.")},Mr=(r,e,t)=>t.verifyKeyPackets?e.then(async i=>{if(!i||i.type==="delta")return i;const s=await r.determinePacketType(i);return s&&(i.type=s),i}):e;class Yt{constructor(e){if(!(e instanceof vi))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){if(ht(e),this._track.input._disposed)throw new fe;return Mr(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,t={}){if(Oe(e),ht(t),this._track.input._disposed)throw new fe;return Mr(this._track,this._track._backing.getPacket(e,t),t)}getNextPacket(e,t={}){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(ht(t),this._track.input._disposed)throw new fe;return Mr(this._track,this._track._backing.getNextPacket(e,t),t)}async getKeyPacket(e,t={}){if(Oe(e),ht(t),this._track.input._disposed)throw new fe;if(!t.verifyKeyPackets)return this._track._backing.getKeyPacket(e,t);const i=await this._track._backing.getKeyPacket(e,t);return i&&(m(i.type==="key"),await this._track.determinePacketType(i)==="delta"?this.getKeyPacket(i.timestamp-1/this._track.timeResolution,t):i)}async getNextKeyPacket(e,t={}){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(ht(t),this._track.input._disposed)throw new fe;if(!t.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,t);const i=await this._track._backing.getNextKeyPacket(e,t);return i&&(m(i.type==="key"),await this._track.determinePacketType(i)==="delta"?this.getNextKeyPacket(i,t):i)}packets(e,t,i={}){if(e!==void 0&&!(e instanceof $))throw new TypeError("startPacket must be an EncodedPacket.");if(e!==void 0&&e.isMetadataOnly&&!i?.metadataOnly)throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(t!==void 0&&!(t instanceof $))throw new TypeError("endPacket must be an EncodedPacket.");if(ht(i),this._track.input._disposed)throw new fe;const s=[];let{promise:n,resolve:a}=G(),{promise:o,resolve:c}=G(),l=!1,u=!1,d=null;const h=[],f=()=>Math.max(2,h.length);(async()=>{let g=e??await this.getFirstPacket(i);for(;g&&!u&&!this._track.input._disposed&&!(t&&g.sequenceNumber>=t?.sequenceNumber);){if(s.length>f()){({promise:o,resolve:c}=G()),await o;continue}s.push(g),a(),{promise:n,resolve:a}=G(),g=await this.getNextPacket(g,i)}l=!0,a()})().catch(g=>{d||(d=g,a())});const p=this._track;return{async next(){for(;;){if(p.input._disposed)throw new fe;if(u)return{value:void 0,done:!0};if(d)throw d;if(s.length>0){const g=s.shift(),w=performance.now();for(h.push(w);h.length>0&&w-h[0]>=1e3;)h.shift();return c(),{value:g,done:!1}}else{if(l)return{value:void 0,done:!0};await n}}},async return(){return u=!0,c(),a(),{value:void 0,done:!0}},async throw(g){throw g},[Symbol.asyncIterator](){return this}}}}class Pi{constructor(e,t){this.onSample=e,this.onError=t}}class sn{mediaSamplesInRange(e=0,t=1/0){Oe(e),Oe(t);const i=[];let s=!1,n=null,{promise:a,resolve:o}=G(),{promise:c,resolve:l}=G(),u=!1,d=!1,h=!1,f=null;(async()=>{const w=new Error,T=await this._createDecoder(C=>{if(l(),C.timestamp>=t&&(d=!0),d){C.close();return}n&&(C.timestamp>e?(i.push(n),s=!0):n.close()),C.timestamp>=e&&(i.push(C),s=!0),n=s?null:C,i.length>0&&(o(),{promise:a,resolve:o}=G())},C=>{f||(C.stack=w.stack,f=C,o())}),k=this._createPacketSink(),S=await k.getKeyPacket(e,{verifyKeyPackets:!0})??await k.getFirstPacket();let y=S,x;if(t<1/0){const C=await k.getPacket(t),P=C?C.type==="key"&&C.timestamp===t?C:await k.getNextKeyPacket(C,{verifyKeyPackets:!0}):null;P&&(x=P)}const v=k.packets(S??void 0,x);for(await v.next();y&&!d&&!this._track.input._disposed;){const C=as(i.length);if(i.length+T.getDecodeQueueSize()>C){({promise:c,resolve:l}=G()),await c;continue}T.decode(y);const P=await v.next();if(P.done)break;y=P.value}await v.return(),!h&&!this._track.input._disposed&&await T.flush(),T.close(),!s&&n&&i.push(n),u=!0,o()})().catch(w=>{f||(f=w,o())});const p=this._track,g=()=>{n?.close();for(const w of i)w.close()};return{async next(){for(;;){if(p.input._disposed)throw g(),new fe;if(h)return{value:void 0,done:!0};if(f)throw g(),f;if(i.length>0){const w=i.shift();return l(),{value:w,done:!1}}else if(!u)await a;else return{value:void 0,done:!0}}},async return(){return h=!0,d=!0,l(),o(),g(),{value:void 0,done:!0}},async throw(w){throw w},[Symbol.asyncIterator](){return this}}}mediaSamplesAtTimestamps(e){Zn(e);const t=Yn(e),i=[],s=[];let{promise:n,resolve:a}=G(),{promise:o,resolve:c}=G(),l=!1,u=!1,d=null;const h=g=>{s.push(g),a(),{promise:n,resolve:a}=G()};(async()=>{const g=new Error,w=await this._createDecoder(C=>{if(c(),u){C.close();return}let P=0;for(;i.length>0&&C.timestamp-i[0]>-1e-10;)P++,i.shift();if(P>0)for(let A=0;A<P;A++)h(A<P-1?C.clone():C);else C.close()},C=>{d||(C.stack=g.stack,d=C,a())}),T=this._createPacketSink();let k=null,S=null,y=-1;const x=async()=>{m(S);let C=S;for(w.decode(C);C.sequenceNumber<y;){const P=as(s.length);for(;s.length+w.getDecodeQueueSize()>P&&!u;)({promise:o,resolve:c}=G()),await o;if(u)break;const A=await T.getNextPacket(C);m(A),w.decode(A),C=A}y=-1},v=async()=>{await w.flush();for(let C=0;C<i.length;C++)h(null);i.length=0};for await(const C of t){if(Oe(C),u||this._track.input._disposed)break;const P=await T.getPacket(C),A=P&&await T.getKeyPacket(C,{verifyKeyPackets:!0});if(!A){y!==-1&&(await x(),await v()),h(null),k=null;continue}k&&(A.sequenceNumber!==S.sequenceNumber||P.timestamp<k.timestamp)&&(await x(),await v()),i.push(P.timestamp),y=Math.max(P.sequenceNumber,y),k=P,S=A}!u&&!this._track.input._disposed&&(y!==-1&&await x(),await v()),w.close(),l=!0,a()})().catch(g=>{d||(d=g,a())});const f=this._track,p=()=>{for(const g of s)g?.close()};return{async next(){for(;;){if(f.input._disposed)throw p(),new fe;if(u)return{value:void 0,done:!0};if(d)throw p(),d;if(s.length>0){const g=s.shift();return m(g!==void 0),c(),{value:g,done:!1}}else if(!l)await n;else return{value:void 0,done:!0}}},async return(){return u=!0,c(),a(),p(),{value:void 0,done:!0}},async throw(g){throw g},[Symbol.asyncIterator](){return this}}}}const as=r=>r===0?40:8;class Qa extends Pi{constructor(e,t,i,s,n,a){super(e,t),this.codec=i,this.decoderConfig=s,this.rotation=n,this.timeResolution=a,this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new vr,this.customDecoderQueueSize=0,this.inputTimestamps=[],this.sampleQueue=[],this.currentPacketIndex=0,this.raslSkipped=!1,this.alphaDecoder=null,this.alphaHadKeyframe=!1,this.colorQueue=[],this.alphaQueue=[],this.merger=null,this.mergerCreationFailed=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue=[],this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1;const o=pr.find(c=>c.supports(i,s));if(o)this.customDecoder=new o,this.customDecoder.codec=i,this.customDecoder.config=s,this.customDecoder.onSample=c=>{if(!(c instanceof ee))throw new TypeError("The argument passed to onSample must be a VideoSample.");this.finalizeAndEmitSample(c)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init());else{const c=l=>{if(this.alphaQueue.length>0){const u=this.alphaQueue.shift();m(u!==void 0),this.mergeAlpha(l,u)}else this.colorQueue.push(l)};if(i==="avc"&&this.decoderConfig.description&&Ns()){const l=va(K(this.decoderConfig.description));if(l&&l.sequenceParameterSets.length>0){const u=Gs(l.sequenceParameterSets[0]);u&&u.frameMbsOnlyFlag===0&&(this.decoderConfig={...this.decoderConfig,hardwareAcceleration:"prefer-software"})}}this.decoder=new VideoDecoder({output:l=>{try{c(l)}catch(u){this.onError(u)}},error:t}),this.decoder.configure(this.decoderConfig)}}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(m(this.decoder),Math.max(this.decoder.decodeQueueSize,this.alphaDecoder?.decodeQueueSize??0))}decode(e){if(this.codec==="hevc"&&this.currentPacketIndex>0&&!this.raslSkipped){if(this.hasHevcRaslPicture(e.data))return;this.raslSkipped=!0}this.currentPacketIndex++,this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(m(this.decoder),or()||Ki(this.inputTimestamps,e.timestamp,t=>t),this.decoder.decode(e.toEncodedVideoChunk()),this.decodeAlphaData(e))}decodeAlphaData(e){if(!e.sideData.alpha||this.mergerCreationFailed){this.pushNullAlphaFrame();return}if(!this.merger)try{this.merger=new Ka}catch(i){console.error("Due to an error, only color data will be decoded.",i),this.mergerCreationFailed=!0,this.decodeAlphaData(e);return}if(!this.alphaDecoder){const i=s=>{if(this.alphaDecoderQueueSize--,this.colorQueue.length>0){const n=this.colorQueue.shift();m(n!==void 0),this.mergeAlpha(n,s)}else this.alphaQueue.push(s);for(this.decodedAlphaChunkCount++;this.nullAlphaFrameQueue.length>0&&this.nullAlphaFrameQueue[0]===this.decodedAlphaChunkCount;)if(this.nullAlphaFrameQueue.shift(),this.colorQueue.length>0){const n=this.colorQueue.shift();m(n!==void 0),this.mergeAlpha(n,null)}else this.alphaQueue.push(null)};this.alphaDecoder=new VideoDecoder({output:s=>{try{i(s)}catch(n){this.onError(n)}},error:this.onError}),this.alphaDecoder.configure(this.decoderConfig)}const t=rn(this.codec,this.decoderConfig,e.sideData.alpha);if(this.alphaHadKeyframe||(this.alphaHadKeyframe=t==="key"),this.alphaHadKeyframe){if(this.codec==="hevc"&&this.currentAlphaPacketIndex>0&&!this.alphaRaslSkipped){if(this.hasHevcRaslPicture(e.sideData.alpha)){this.pushNullAlphaFrame();return}this.alphaRaslSkipped=!0}this.currentAlphaPacketIndex++,this.alphaDecoder.decode(e.alphaToEncodedVideoChunk(t??e.type)),this.alphaDecoderQueueSize++}else this.pushNullAlphaFrame()}pushNullAlphaFrame(){this.alphaDecoderQueueSize===0?this.alphaQueue.push(null):this.nullAlphaFrameQueue.push(this.decodedAlphaChunkCount+this.alphaDecoderQueueSize)}hasHevcRaslPicture(e){return Xs(e,this.decoderConfig).some(i=>{const s=je(i);return s===oe.RASL_N||s===oe.RASL_R})}sampleHandler(e){if(or()){if(this.sampleQueue.length>0&&e.timestamp>=X(this.sampleQueue).timestamp){for(const t of this.sampleQueue)this.finalizeAndEmitSample(t);this.sampleQueue.length=0}Ki(this.sampleQueue,e,t=>t.timestamp)}else{const t=this.inputTimestamps.shift();m(t!==void 0),e.setTimestamp(t),this.finalizeAndEmitSample(e)}}finalizeAndEmitSample(e){e.setTimestamp(Math.round(e.timestamp*this.timeResolution)/this.timeResolution),e.setDuration(Math.round(e.duration*this.timeResolution)/this.timeResolution),e.setRotation(this.rotation),this.onSample(e)}mergeAlpha(e,t){if(!t){const n=new ee(e);this.sampleHandler(n);return}m(this.merger),this.merger.update(e,t),e.close(),t.close();const i=new VideoFrame(this.merger.canvas,{timestamp:e.timestamp,duration:e.duration??void 0}),s=new ee(i);this.sampleHandler(s)}async flush(){if(this.customDecoder?await this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(m(this.decoder),await Promise.all([this.decoder.flush(),this.alphaDecoder?.flush()]),this.colorQueue.forEach(e=>e.close()),this.colorQueue.length=0,this.alphaQueue.forEach(e=>e?.close()),this.alphaQueue.length=0,this.alphaHadKeyframe=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue.length=0,this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1),or()){for(const e of this.sampleQueue)this.finalizeAndEmitSample(e);this.sampleQueue.length=0}this.currentPacketIndex=0,this.raslSkipped=!1}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(m(this.decoder),this.decoder.close(),this.alphaDecoder?.close(),this.colorQueue.forEach(e=>e.close()),this.colorQueue.length=0,this.alphaQueue.forEach(e=>e?.close()),this.alphaQueue.length=0,this.merger?.close());for(const e of this.sampleQueue)e.close();this.sampleQueue.length=0}}class Ka{constructor(){typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(300,150):this.canvas=document.createElement("canvas");const e=this.canvas.getContext("webgl2",{premultipliedAlpha:!1});if(!e)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=e,this.program=this.createProgram(),this.vao=this.createVAO(),this.colorTexture=this.createTexture(),this.alphaTexture=this.createTexture(),this.gl.useProgram(this.program),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_colorTexture"),0),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_alphaTexture"),1)}createProgram(){const e=this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`),t=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_colorTexture;
			uniform sampler2D u_alphaTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec3 color = texture(u_colorTexture, v_texCoord).rgb;
				float alpha = texture(u_alphaTexture, v_texCoord).r;
				fragColor = vec4(color, alpha);
			}
		`),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,t),this.gl.linkProgram(i),i}createShader(e,t){const i=this.gl.createShader(e);return this.gl.shaderSource(i,t),this.gl.compileShader(i),i}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const t=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),i=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,i),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.STATIC_DRAW);const s=this.gl.getAttribLocation(this.program,"a_position"),n=this.gl.getAttribLocation(this.program,"a_texCoord");return this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}update(e,t){(e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colorTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.gl.activeTexture(this.gl.TEXTURE1),this.gl.bindTexture(this.gl.TEXTURE_2D,this.alphaTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,t),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class ri extends sn{constructor(e){if(!(e instanceof er))throw new TypeError("videoTrack must be an InputVideoTrack.");super(),this._track=e}async _createDecoder(e,t){if(!await this._track.canDecode())throw new Error("This video track cannot be decoded by this browser. Make sure to check decodability before using a track.");const i=this._track.codec,s=this._track.rotation,n=await this._track.getDecoderConfig(),a=this._track.timeResolution;return m(i&&n),new Qa(e,t,i,n,s,a)}_createPacketSink(){return new Yt(this._track)}async getSample(e){Oe(e);for await(const t of this.mediaSamplesAtTimestamps([e]))return t;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,t=1/0){return this.mediaSamplesInRange(e,t)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class Ga{constructor(e,t={}){if(this._nextCanvasIndex=0,!(e instanceof er))throw new TypeError("videoTrack must be an InputVideoTrack.");if(t&&typeof t!="object")throw new TypeError("options must be an object.");if(t.alpha!==void 0&&typeof t.alpha!="boolean")throw new TypeError("options.alpha, when provided, must be a boolean.");if(t.width!==void 0&&(!Number.isInteger(t.width)||t.width<=0))throw new TypeError("options.width, when defined, must be a positive integer.");if(t.height!==void 0&&(!Number.isInteger(t.height)||t.height<=0))throw new TypeError("options.height, when defined, must be a positive integer.");if(t.fit!==void 0&&!["fill","contain","cover"].includes(t.fit))throw new TypeError('options.fit, when provided, must be one of "fill", "contain", or "cover".');if(t.width!==void 0&&t.height!==void 0&&t.fit===void 0)throw new TypeError("When both options.width and options.height are provided, options.fit must also be provided.");if(t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180 or 270.");if(t.crop!==void 0&&_i(t.crop,"options."),t.poolSize!==void 0&&(typeof t.poolSize!="number"||!Number.isInteger(t.poolSize)||t.poolSize<0))throw new TypeError("poolSize must be a non-negative integer.");const i=t.rotation??e.rotation,[s,n]=i%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],a=t.crop;a&&Ci(a,s,n);let[o,c]=a?[a.width,a.height]:[s,n];const l=o/c;t.width!==void 0&&t.height===void 0?(o=t.width,c=Math.round(o/l)):t.width===void 0&&t.height!==void 0?(c=t.height,o=Math.round(c*l)):t.width!==void 0&&t.height!==void 0&&(o=t.width,c=t.height),this._videoTrack=e,this._alpha=t.alpha??!1,this._width=o,this._height=c,this._rotation=i,this._crop=a,this._fit=t.fit??"fill",this._videoSampleSink=new ri(e),this._canvasPool=Array.from({length:t.poolSize??0},()=>null)}_videoSampleToWrappedCanvas(e){let t=this._canvasPool[this._nextCanvasIndex],i=!1;t||(typeof document<"u"?(t=document.createElement("canvas"),t.width=this._width,t.height=this._height):t=new OffscreenCanvas(this._width,this._height),this._canvasPool.length>0&&(this._canvasPool[this._nextCanvasIndex]=t),i=!0),this._canvasPool.length>0&&(this._nextCanvasIndex=(this._nextCanvasIndex+1)%this._canvasPool.length);const s=t.getContext("2d",{alpha:this._alpha||Pt()});m(s),s.resetTransform(),i||(!this._alpha&&Pt()?(s.fillStyle="black",s.fillRect(0,0,this._width,this._height)):s.clearRect(0,0,this._width,this._height)),e.drawWithFit(s,{fit:this._fit,rotation:this._rotation,crop:this._crop});const n={canvas:t,timestamp:e.timestamp,duration:e.duration};return e.close(),n}async getCanvas(e){Oe(e);const t=await this._videoSampleSink.getSample(e);return t&&this._videoSampleToWrappedCanvas(t)}canvases(e=0,t=1/0){return dr(this._videoSampleSink.samples(e,t),i=>this._videoSampleToWrappedCanvas(i))}canvasesAtTimestamps(e){return dr(this._videoSampleSink.samplesAtTimestamps(e),t=>t&&this._videoSampleToWrappedCanvas(t))}}class Xa extends Pi{constructor(e,t,i,s){super(e,t),this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new vr,this.customDecoderQueueSize=0,this.currentTimestamp=null;const n=o=>{(this.currentTimestamp===null||Math.abs(o.timestamp-this.currentTimestamp)>=o.duration)&&(this.currentTimestamp=o.timestamp);const c=this.currentTimestamp;if(this.currentTimestamp+=o.duration,o.numberOfFrames===0){o.close();return}const l=s.sampleRate;o.setTimestamp(Math.round(c*l)/l),e(o)},a=gr.find(o=>o.supports(i,s));a?(this.customDecoder=new a,this.customDecoder.codec=i,this.customDecoder.config=s,this.customDecoder.onSample=o=>{if(!(o instanceof ne))throw new TypeError("The argument passed to onSample must be an AudioSample.");n(o)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init())):(this.decoder=new AudioDecoder({output:o=>{try{n(new ne(o))}catch(c){this.onError(c)}},error:t}),this.decoder.configure(s))}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(m(this.decoder),this.decoder.decodeQueueSize)}decode(e){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(m(this.decoder),this.decoder.decode(e.toEncodedAudioChunk()))}flush(){return this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(m(this.decoder),this.decoder.flush())}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(m(this.decoder),this.decoder.close())}}class Ya extends Pi{constructor(e,t,i){super(e,t),this.decoderConfig=i,this.currentTimestamp=null,m(Z.includes(i.codec)),this.codec=i.codec;const{dataType:s,sampleSize:n,littleEndian:a}=Ae(this.codec);switch(this.inputSampleSize=n,n){case 1:s==="unsigned"?this.readInputValue=(o,c)=>o.getUint8(c)-2**7:s==="signed"?this.readInputValue=(o,c)=>o.getInt8(c):s==="ulaw"?this.readInputValue=(o,c)=>La(o.getUint8(c)):s==="alaw"?this.readInputValue=(o,c)=>qa(o.getUint8(c)):m(!1);break;case 2:s==="unsigned"?this.readInputValue=(o,c)=>o.getUint16(c,a)-2**15:s==="signed"?this.readInputValue=(o,c)=>o.getInt16(c,a):m(!1);break;case 3:s==="unsigned"?this.readInputValue=(o,c)=>Pr(o,c,a)-2**23:s==="signed"?this.readInputValue=(o,c)=>Jn(o,c,a):m(!1);break;case 4:s==="unsigned"?this.readInputValue=(o,c)=>o.getUint32(c,a)-2**31:s==="signed"?this.readInputValue=(o,c)=>o.getInt32(c,a):s==="float"?this.readInputValue=(o,c)=>o.getFloat32(c,a):m(!1);break;case 8:s==="float"?this.readInputValue=(o,c)=>o.getFloat64(c,a):m(!1);break;default:ae(n),m(!1)}switch(n){case 1:s==="ulaw"||s==="alaw"?(this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0)):(this.outputSampleSize=1,this.outputFormat="u8",this.writeOutputValue=(o,c,l)=>o.setUint8(c,l+2**7));break;case 2:this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0);break;case 3:this.outputSampleSize=4,this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l<<8,!0);break;case 4:this.outputSampleSize=4,s==="float"?(this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0)):(this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l,!0));break;case 8:this.outputSampleSize=4,this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0);break;default:ae(n),m(!1)}}getDecodeQueueSize(){return 0}decode(e){const t=L(e.data),i=e.byteLength/this.decoderConfig.numberOfChannels/this.inputSampleSize,s=i*this.decoderConfig.numberOfChannels*this.outputSampleSize,n=new ArrayBuffer(s),a=new DataView(n);for(let u=0;u<i*this.decoderConfig.numberOfChannels;u++){const d=u*this.inputSampleSize,h=u*this.outputSampleSize,f=this.readInputValue(t,d);this.writeOutputValue(a,h,f)}const o=i/this.decoderConfig.sampleRate;(this.currentTimestamp===null||Math.abs(e.timestamp-this.currentTimestamp)>=o)&&(this.currentTimestamp=e.timestamp);const c=this.currentTimestamp;this.currentTimestamp+=o;const l=new ne({format:this.outputFormat,data:n,numberOfChannels:this.decoderConfig.numberOfChannels,sampleRate:this.decoderConfig.sampleRate,numberOfFrames:i,timestamp:c});this.onSample(l)}async flush(){}close(){}}class ii extends sn{constructor(e){if(!(e instanceof Fe))throw new TypeError("audioTrack must be an InputAudioTrack.");super(),this._track=e}async _createDecoder(e,t){if(!await this._track.canDecode())throw new Error("This audio track cannot be decoded by this browser. Make sure to check decodability before using a track.");const i=this._track.codec,s=await this._track.getDecoderConfig();return m(i&&s),Z.includes(s.codec)?new Ya(e,t,s):new Xa(e,t,i,s)}_createPacketSink(){return new Yt(this._track)}async getSample(e){Oe(e);for await(const t of this.mediaSamplesAtTimestamps([e]))return t;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,t=1/0){return this.mediaSamplesInRange(e,t)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class eu{constructor(e){if(!(e instanceof Fe))throw new TypeError("audioTrack must be an InputAudioTrack.");this._audioSampleSink=new ii(e)}_audioSampleToWrappedArrayBuffer(e){const t={buffer:e.toAudioBuffer(),timestamp:e.timestamp,duration:e.duration};return e.close(),t}async getBuffer(e){Oe(e);const t=await this._audioSampleSink.getSample(e);return t&&this._audioSampleToWrappedArrayBuffer(t)}buffers(e=0,t=1/0){return dr(this._audioSampleSink.samples(e,t),i=>this._audioSampleToWrappedArrayBuffer(i))}buffersAtTimestamps(e){return dr(this._audioSampleSink.samplesAtTimestamps(e),t=>t&&this._audioSampleToWrappedArrayBuffer(t))}}class vi{constructor(e,t){this.input=e,this._backing=t}isVideoTrack(){return this instanceof er}isAudioTrack(){return this instanceof Fe}get id(){return this._backing.getId()}get internalCodecId(){return this._backing.getInternalCodecId()}get languageCode(){return this._backing.getLanguageCode()}get name(){return this._backing.getName()}get timeResolution(){return this._backing.getTimeResolution()}get disposition(){return this._backing.getDisposition()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const t=new Yt(this);let i=1/0,s=-1/0,n=0,a=0;for await(const o of t.packets(void 0,void 0,{metadataOnly:!0})){if(n>=e&&o.timestamp>=s)break;i=Math.min(i,o.timestamp),s=Math.max(s,o.timestamp+o.duration),n++,a+=o.byteLength}return{packetCount:n,averagePacketRate:n?Number((n/(s-i)).toPrecision(16)):0,averageBitrate:n?Number((8*a/(s-i)).toPrecision(16)):0}}}class er extends vi{constructor(e,t){super(e,t),this._backing=t}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180===0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180===0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return e.primaries==="bt2020"||e.primaries==="smpte432"||e.transfer==="pg"||e.transfer==="hlg"||e.matrix==="bt2020-ncl"}canBeTransparent(){return this._backing.canBeTransparent()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){return(await this._backing.getDecoderConfig())?.codec??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const t=this._backing.getCodec();return m(t!==null),pr.some(s=>s.supports(t,e))?!0:typeof VideoDecoder>"u"?!1:(await VideoDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");if(this.codec===null)return null;const t=await this.getDecoderConfig();return m(t),rn(this.codec,t,e.data)}}class Fe extends vi{constructor(e,t){super(e,t),this._backing=t}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){return(await this._backing.getDecoderConfig())?.codec??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const t=this._backing.getCodec();return m(t!==null),gr.some(i=>i.supports(t,e))||e.codec.startsWith("pcm-")?!0:typeof AudioDecoder>"u"?!1:(await AudioDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");return this.codec===null?null:"key"}}const nn=r=>{let t=(r.hasVideo?"video/":r.hasAudio?"audio/":"application/")+(r.isQuickTime?"quicktime":"mp4");if(r.codecStrings.length>0){const i=[...new Set(r.codecStrings)];t+=`; codecs="${i.join(", ")}"`}return t},Me=8,et=16,$e=r=>{let e=I(r);const t=te(r,4);let i=8;e===1&&(e=xe(r),i=16);const n=e-i;return n<0?null:{name:t,totalSize:e,headerSize:i,contentSize:n}},Je=r=>rt(r)/65536,Dr=r=>rt(r)/1073741824,Ur=r=>{let e=0;for(let t=0;t<4;t++){e<<=7;const i=B(r);if(e|=i&127,(i&128)===0)break}return e},Pe=r=>{let e=re(r);return r.skip(2),e=Math.min(e,r.remainingLength),ke.decode(D(r,e))},Za=r=>{const e=$e(r);if(!e||e.name!=="data"||r.remainingLength<8)return null;const t=I(r);r.skip(4);const i=D(r,e.contentSize-8);switch(t){case 1:return ke.decode(i);case 2:return new TextDecoder("utf-16be").decode(i);case 13:return new St(i,"image/jpeg");case 14:return new St(i,"image/png");case 27:return new St(i,"image/bmp");default:return i}};class Ja extends ct{constructor(e){super(e),this.moovSlice=null,this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.metadataTags={},this.currentMetadataKeys=null,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.currentFragment=null,this.lastReadFragment=null,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(t=>t.inputTrack.getCodecParameterString()));return nn({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some(t=>t.info?.type==="video"),hasAudio:this.tracks.some(t=>t.info?.type==="audio"),codecStrings:e.filter(Boolean)})}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;;){let t=this.reader.requestSliceRange(e,Me,et);if(t instanceof Promise&&(t=await t),!t)break;const i=e,s=$e(t);if(!s)break;if(s.name==="ftyp"){const n=te(t,4);this.isQuickTime=n==="qt  "}else if(s.name==="moov"){let n=this.reader.requestSlice(t.filePos,s.contentSize);if(n instanceof Promise&&(n=await n),!n)break;this.moovSlice=n,this.readContiguousBoxes(this.moovSlice),this.tracks.sort((a,o)=>Number(o.disposition.default)-Number(a.disposition.default));for(const a of this.tracks){const o=a.editListPreviousSegmentDurations/this.movieTimescale;a.editListOffset-=Math.round(o*a.timescale)}break}e=i+s.totalSize}if(this.isFragmented&&this.reader.fileSize!==null){let t=this.reader.requestSlice(this.reader.fileSize-4,4);t instanceof Promise&&(t=await t),m(t);const i=I(t),s=this.reader.fileSize-i;if(s>=0&&s<=this.reader.fileSize-et){let n=this.reader.requestSliceRange(s,Me,et);if(n instanceof Promise&&(n=await n),n){const a=$e(n);if(a&&a.name==="mfra"){let o=this.reader.requestSlice(n.filePos,a.contentSize);o instanceof Promise&&(o=await o),o&&this.readContiguousBoxes(o)}}}}})()}getSampleTableForTrack(e){if(e.sampleTable)return e.sampleTable;const t={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};e.sampleTable=t,m(this.moovSlice);const i=this.moovSlice.slice(e.sampleTableByteOffset);if(this.currentTrack=e,this.traverseBox(i),this.currentTrack=null,e.info?.type==="audio"&&e.info.codec&&Z.includes(e.info.codec)&&t.sampleCompositionTimeOffsets.length===0){m(e.info?.type==="audio");const n=Ae(e.info.codec),a=[],o=[];for(let c=0;c<t.sampleToChunk.length;c++){const l=t.sampleToChunk[c],u=t.sampleToChunk[c+1],d=(u?u.startChunkIndex:t.chunkOffsets.length)-l.startChunkIndex;for(let h=0;h<d;h++){const f=l.startSampleIndex+h*l.samplesPerChunk,p=f+l.samplesPerChunk,g=H(t.sampleTimingEntries,f,P=>P.startIndex),w=t.sampleTimingEntries[g],T=H(t.sampleTimingEntries,p,P=>P.startIndex),k=t.sampleTimingEntries[T],S=w.startDecodeTimestamp+(f-w.startIndex)*w.delta,x=k.startDecodeTimestamp+(p-k.startIndex)*k.delta-S,v=X(a);v&&v.delta===x?v.count++:a.push({startIndex:l.startChunkIndex+h,startDecodeTimestamp:S,count:1,delta:x});const C=l.samplesPerChunk*n.sampleSize*e.info.numberOfChannels;o.push(C)}l.startSampleIndex=l.startChunkIndex,l.samplesPerChunk=1}t.sampleTimingEntries=a,t.sampleSizes=o}if(t.sampleCompositionTimeOffsets.length>0){t.presentationTimestamps=[];for(const n of t.sampleTimingEntries)for(let a=0;a<n.count;a++)t.presentationTimestamps.push({presentationTimestamp:n.startDecodeTimestamp+a*n.delta,sampleIndex:n.startIndex+a});for(const n of t.sampleCompositionTimeOffsets)for(let a=0;a<n.count;a++){const o=n.startIndex+a,c=t.presentationTimestamps[o];c&&(c.presentationTimestamp+=n.offset)}t.presentationTimestamps.sort((n,a)=>n.presentationTimestamp-a.presentationTimestamp),t.presentationTimestampIndexMap=Array(t.presentationTimestamps.length).fill(-1);for(let n=0;n<t.presentationTimestamps.length;n++)t.presentationTimestampIndexMap[t.presentationTimestamps[n].sampleIndex]=n}return t}async readFragment(e){if(this.lastReadFragment?.moofOffset===e)return this.lastReadFragment;let t=this.reader.requestSliceRange(e,Me,et);t instanceof Promise&&(t=await t),m(t);const i=$e(t);m(i?.name==="moof");let s=this.reader.requestSlice(e,i.totalSize);s instanceof Promise&&(s=await s),m(s),this.traverseBox(s);const n=this.lastReadFragment;m(n&&n.moofOffset===e);for(const[,a]of n.trackData){const o=a.track,{fragmentPositionCache:c}=o;if(!a.startTimestampIsFinal){const u=o.fragmentLookupTable.find(d=>d.moofOffset===n.moofOffset);if(u)Nr(a,u.timestamp);else{const d=H(c,n.moofOffset-1,h=>h.moofOffset);if(d!==-1){const h=c[d];Nr(a,h.endTimestamp)}}a.startTimestampIsFinal=!0}const l=H(c,a.startTimestamp,u=>u.startTimestamp);(l===-1||c[l].moofOffset!==n.moofOffset)&&c.splice(l+1,0,{moofOffset:n.moofOffset,startTimestamp:a.startTimestamp,endTimestamp:a.endTimestamp})}return n}readContiguousBoxes(e){const t=e.filePos;for(;e.filePos-t<=e.length-Me&&this.traverseBox(e););}*iterateContiguousBoxes(e){const t=e.filePos;for(;e.filePos-t<=e.length-Me;){const i=e.filePos,s=$e(e);if(!s)break;yield{boxInfo:s,slice:e},e.filePos=i+s.totalSize}}traverseBox(e){const t=e.filePos,i=$e(e);if(!i)return!1;const s=e.filePos,n=t+i.totalSize;switch(i.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":this.readContiguousBoxes(e.slice(s,i.contentSize));break;case"mvhd":{const a=B(e);e.skip(3),a===1?(e.skip(16),this.movieTimescale=I(e),this.movieDurationInTimescale=xe(e)):(e.skip(8),this.movieTimescale=I(e),this.movieDurationInTimescale=I(e))}break;case"trak":{const a={id:-1,demuxer:this,inputTrack:null,disposition:{...at},info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,internalCodecId:null,name:null,languageCode:me,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:[],currentFragmentState:null,fragmentPositionCache:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=a,this.readContiguousBoxes(e.slice(s,i.contentSize)),a.id!==-1&&a.timescale!==-1&&a.info!==null){if(a.info.type==="video"&&a.info.width!==-1){const o=a;a.inputTrack=new er(this.input,new eo(o)),this.tracks.push(a)}else if(a.info.type==="audio"&&a.info.numberOfChannels!==-1){const o=a;a.inputTrack=new Fe(this.input,new to(o)),this.tracks.push(a)}}this.currentTrack=null}break;case"tkhd":{const a=this.currentTrack;if(!a)break;const o=B(e),l=!!(bt(e)&1);if(a.disposition.default=l,o===0)e.skip(8),a.id=I(e),e.skip(4),a.durationInMovieTimescale=I(e);else if(o===1)e.skip(16),a.id=I(e),e.skip(4),a.durationInMovieTimescale=xe(e);else throw new Error(`Incorrect track header version ${o}.`);e.skip(16);const u=[Je(e),Je(e),Dr(e),Je(e),Je(e),Dr(e),Je(e),Je(e),Dr(e)],d=xr(Yr(no(u),90));m(d===0||d===90||d===180||d===270),a.rotation=d}break;case"elst":{const a=this.currentTrack;if(!a)break;const o=B(e);e.skip(3);let c=!1,l=0;const u=I(e);for(let d=0;d<u;d++){const h=o===1?xe(e):I(e),f=o===1?rc(e):rt(e),p=Je(e);if(h!==0){if(c){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(f===-1){l+=h;continue}if(p!==1){console.warn("Unsupported edit list entry: media rate must be 1.");break}a.editListPreviousSegmentDurations=l,a.editListOffset=f,c=!0}}}break;case"mdhd":{const a=this.currentTrack;if(!a)break;const o=B(e);e.skip(3),o===0?(e.skip(8),a.timescale=I(e),a.durationInMediaTimescale=I(e)):o===1&&(e.skip(16),a.timescale=I(e),a.durationInMediaTimescale=xe(e));let c=re(e);if(c>0){a.languageCode="";for(let l=0;l<3;l++)a.languageCode=String.fromCharCode(96+(c&31))+a.languageCode,c>>=5;$t(a.languageCode)||(a.languageCode=me)}}break;case"hdlr":{const a=this.currentTrack;if(!a)break;e.skip(8);const o=te(e,4);o==="vide"?a.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcType:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:o==="soun"&&(a.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const a=this.currentTrack;if(!a)break;a.sampleTableByteOffset=t,this.readContiguousBoxes(e.slice(s,i.contentSize))}break;case"stsd":{const a=this.currentTrack;if(!a||a.info===null||a.sampleTable)break;const o=B(e);e.skip(3);const c=I(e);for(let l=0;l<c;l++){const u=e.filePos,d=$e(e);if(!d)break;a.internalCodecId=d.name;const h=d.name.toLowerCase();if(a.info.type==="video")h==="avc1"||h==="avc3"?(a.info.codec="avc",a.info.avcType=h==="avc1"?1:3):h==="hvc1"||h==="hev1"?a.info.codec="hevc":h==="vp08"?a.info.codec="vp8":h==="vp09"?a.info.codec="vp9":h==="av01"?a.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${d.name}').`),e.skip(24),a.info.width=re(e),a.info.height=re(e),e.skip(50),this.readContiguousBoxes(e.slice(e.filePos,u+d.totalSize-e.filePos));else{h==="mp4a"||(h==="opus"?a.info.codec="opus":h==="flac"?a.info.codec="flac":h==="twos"||h==="sowt"||h==="raw "||h==="in24"||h==="in32"||h==="fl32"||h==="fl64"||h==="lpcm"||h==="ipcm"||h==="fpcm"||(h==="ulaw"?a.info.codec="ulaw":h==="alaw"?a.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${d.name}').`))),e.skip(8);const f=re(e);e.skip(6);let p=re(e),g=re(e);e.skip(4);let w=I(e)/65536;if(o===0&&f>0){if(f===1)e.skip(4),g=8*I(e),e.skip(8);else if(f===2){e.skip(4),w=An(e),p=I(e),e.skip(4),g=I(e);const T=I(e);if(e.skip(8),h==="lpcm"){const k=g+7>>3,S=!!(T&1),y=!!(T&2),x=T&4?-1:0;g>0&&g<=64&&(S?g===32&&(a.info.codec=y?"pcm-f32be":"pcm-f32"):x&1<<k-1?k===1?a.info.codec="pcm-s8":k===2?a.info.codec=y?"pcm-s16be":"pcm-s16":k===3?a.info.codec=y?"pcm-s24be":"pcm-s24":k===4&&(a.info.codec=y?"pcm-s32be":"pcm-s32"):k===1&&(a.info.codec="pcm-u8")),a.info.codec===null&&console.warn("Unsupported PCM format.")}}}a.info.codec==="opus"&&(w=zt),a.info.numberOfChannels=p,a.info.sampleRate=w,h==="twos"?g===8?a.info.codec="pcm-s8":g===16?a.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${g} for codec 'twos'.`),a.info.codec=null):h==="sowt"?g===8?a.info.codec="pcm-s8":g===16?a.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${g} for codec 'sowt'.`),a.info.codec=null):h==="raw "?a.info.codec="pcm-u8":h==="in24"?a.info.codec="pcm-s24be":h==="in32"?a.info.codec="pcm-s32be":h==="fl32"?a.info.codec="pcm-f32be":h==="fl64"?a.info.codec="pcm-f64be":h==="ipcm"?a.info.codec="pcm-s16be":h==="fpcm"&&(a.info.codec="pcm-f32be"),this.readContiguousBoxes(e.slice(e.filePos,u+d.totalSize-e.filePos))}}}break;case"avcC":{const a=this.currentTrack;if(!a)break;m(a.info),a.info.codecDescription=D(e,i.contentSize)}break;case"hvcC":{const a=this.currentTrack;if(!a)break;m(a.info),a.info.codecDescription=D(e,i.contentSize)}break;case"vpcC":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="video"),e.skip(4);const o=B(e),c=B(e),l=B(e),u=l>>4,d=l>>1&7,h=l&1,f=B(e),p=B(e),g=B(e);a.info.vp9CodecInfo={profile:o,level:c,bitDepth:u,chromaSubsampling:d,videoFullRangeFlag:h,colourPrimaries:f,transferCharacteristics:p,matrixCoefficients:g}}break;case"av1C":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="video"),e.skip(1);const o=B(e),c=o>>5,l=o&31,u=B(e),d=u>>7,h=u>>6&1,f=u>>5&1,p=u>>4&1,g=u>>3&1,w=u>>2&1,T=u&3,k=c===2&&h?f?12:10:h?10:8;a.info.av1CodecInfo={profile:c,level:l,tier:d,bitDepth:k,monochrome:p,chromaSubsamplingX:g,chromaSubsamplingY:w,chromaSamplePosition:T}}break;case"colr":{const a=this.currentTrack;if(!a||(m(a.info?.type==="video"),te(e,4)!=="nclx"))break;const c=re(e),l=re(e),u=re(e),d=!!(B(e)&128);a.info.colorSpace={primaries:Fs[c],transfer:Bs[l],matrix:zs[u],fullRange:d}}break;case"wave":this.readContiguousBoxes(e.slice(s,i.contentSize));break;case"esds":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(4);const o=B(e);m(o===3),Ur(e),e.skip(2);const c=B(e),l=(c&128)!==0,u=(c&64)!==0,d=(c&32)!==0;if(l&&e.skip(2),u){const w=B(e);e.skip(w)}d&&e.skip(2);const h=B(e);m(h===4);const f=Ur(e),p=e.filePos,g=B(e);if(g===64||g===103?(a.info.codec="aac",a.info.aacCodecInfo={isMpeg2:g===103}):g===105||g===107?a.info.codec="mp3":g===221?a.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${g}) - discarding track.`),e.skip(12),f>e.filePos-p){const w=B(e);m(w===5);const T=Ur(e);if(a.info.codecDescription=D(e,T),a.info.codec==="aac"){const k=Ir(a.info.codecDescription);k.numberOfChannels!==null&&(a.info.numberOfChannels=k.numberOfChannels),k.sampleRate!==null&&(a.info.sampleRate=k.sampleRate)}}}break;case"enda":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),re(e)&255&&(a.info.codec==="pcm-s16be"?a.info.codec="pcm-s16":a.info.codec==="pcm-s24be"?a.info.codec="pcm-s24":a.info.codec==="pcm-s32be"?a.info.codec="pcm-s32":a.info.codec==="pcm-f32be"?a.info.codec="pcm-f32":a.info.codec==="pcm-f64be"&&(a.info.codec="pcm-f64"))}break;case"pcmC":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(4);const c=!!(B(e)&1),l=B(e);a.info.codec==="pcm-s16be"?c?l===16?a.info.codec="pcm-s16":l===24?a.info.codec="pcm-s24":l===32?a.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${l}.`),a.info.codec=null):l===16?a.info.codec="pcm-s16be":l===24?a.info.codec="pcm-s24be":l===32?a.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${l}.`),a.info.codec=null):a.info.codec==="pcm-f32be"&&(c?l===32?a.info.codec="pcm-f32":l===64?a.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${l}.`),a.info.codec=null):l===32?a.info.codec="pcm-f32be":l===64?a.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${l}.`),a.info.codec=null));break}case"dOps":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(1);const o=B(e),c=re(e),l=I(e),u=pi(e),d=B(e);let h;d!==0?h=D(e,2+o):h=new Uint8Array(0);const f=new Uint8Array(19+h.byteLength),p=new DataView(f.buffer);p.setUint32(0,1332770163,!1),p.setUint32(4,1214603620,!1),p.setUint8(8,1),p.setUint8(9,o),p.setUint16(10,c,!0),p.setUint32(12,l,!0),p.setInt16(16,u,!0),p.setUint8(18,d),f.set(h,19),a.info.codecDescription=f,a.info.numberOfChannels=o}break;case"dfLa":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(4);const o=127,c=128,l=e.filePos;for(;e.filePos<n;){const p=B(e),g=bt(e);if((p&o)===Ne.STREAMINFO){e.skip(10);const T=I(e),k=T>>>12,S=(T>>9&7)+1;a.info.sampleRate=k,a.info.numberOfChannels=S,e.skip(20)}else e.skip(g);if(p&c)break}const u=e.filePos;e.filePos=l;const d=D(e,u-l),h=new Uint8Array(4+d.byteLength);new DataView(h.buffer).setUint32(0,1716281667,!1),h.set(d,4),a.info.codecDescription=h}break;case"stts":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);let c=0,l=0;for(let u=0;u<o;u++){const d=I(e),h=I(e);a.sampleTable.sampleTimingEntries.push({startIndex:c,startDecodeTimestamp:l,count:d,delta:h}),c+=d,l+=d*h}}break;case"ctts":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);let c=0;for(let l=0;l<o;l++){const u=I(e),d=rt(e);a.sampleTable.sampleCompositionTimeOffsets.push({startIndex:c,count:u,offset:d}),c+=u}}break;case"stsz":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e),c=I(e);if(o===0)for(let l=0;l<c;l++){const u=I(e);a.sampleTable.sampleSizes.push(u)}else a.sampleTable.sampleSizes.push(o)}break;case"stz2":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4),e.skip(3);const o=B(e),c=I(e),l=D(e,Math.ceil(c*o/8)),u=new W(l);for(let d=0;d<c;d++){const h=u.readBits(o);a.sampleTable.sampleSizes.push(h)}}break;case"stss":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4),a.sampleTable.keySampleIndices=[];const o=I(e);for(let c=0;c<o;c++){const l=I(e)-1;a.sampleTable.keySampleIndices.push(l)}a.sampleTable.keySampleIndices[0]!==0&&a.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);for(let l=0;l<o;l++){const u=I(e)-1,d=I(e),h=I(e);a.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:u,samplesPerChunk:d,sampleDescriptionIndex:h})}let c=0;for(let l=0;l<a.sampleTable.sampleToChunk.length;l++)if(a.sampleTable.sampleToChunk[l].startSampleIndex=c,l<a.sampleTable.sampleToChunk.length-1){const d=a.sampleTable.sampleToChunk[l+1].startChunkIndex-a.sampleTable.sampleToChunk[l].startChunkIndex;c+=d*a.sampleTable.sampleToChunk[l].samplesPerChunk}}break;case"stco":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);for(let c=0;c<o;c++){const l=I(e);a.sampleTable.chunkOffsets.push(l)}}break;case"co64":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);for(let c=0;c<o;c++){const l=xe(e);a.sampleTable.chunkOffsets.push(l)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(e.slice(s,i.contentSize));break;case"mehd":{const a=B(e);e.skip(3);const o=a===1?xe(e):I(e);this.movieDurationInTimescale=o}break;case"trex":{e.skip(4);const a=I(e),o=I(e),c=I(e),l=I(e),u=I(e);this.fragmentTrackDefaults.push({trackId:a,defaultSampleDescriptionIndex:o,defaultSampleDuration:c,defaultSampleSize:l,defaultSampleFlags:u})}break;case"tfra":{const a=B(e);e.skip(3);const o=I(e),c=this.tracks.find(k=>k.id===o);if(!c)break;const l=I(e),u=(l&48)>>4,d=(l&12)>>2,h=l&3,f=[B,re,bt,I],p=f[u],g=f[d],w=f[h],T=I(e);for(let k=0;k<T;k++){const S=a===1?xe(e):I(e),y=a===1?xe(e):I(e);p(e),g(e),w(e),c.fragmentLookupTable.push({timestamp:S,moofOffset:y})}c.fragmentLookupTable.sort((k,S)=>k.timestamp-S.timestamp);for(let k=0;k<c.fragmentLookupTable.length-1;k++){const S=c.fragmentLookupTable[k],y=c.fragmentLookupTable[k+1];S.timestamp===y.timestamp&&(c.fragmentLookupTable.splice(k+1,1),k--)}}break;case"moof":this.currentFragment={moofOffset:t,moofSize:i.totalSize,implicitBaseDataOffset:t,trackData:new Map},this.readContiguousBoxes(e.slice(s,i.contentSize)),this.lastReadFragment=this.currentFragment,this.currentFragment=null;break;case"traf":if(m(this.currentFragment),this.readContiguousBoxes(e.slice(s,i.contentSize)),this.currentTrack){const a=this.currentFragment.trackData.get(this.currentTrack.id);if(a){const{currentFragmentState:o}=this.currentTrack;m(o),o.startTimestamp!==null&&(Nr(a,o.startTimestamp),a.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{m(this.currentFragment),e.skip(1);const a=bt(e),o=!!(a&1),c=!!(a&2),l=!!(a&8),u=!!(a&16),d=!!(a&32),h=!!(a&65536),f=!!(a&131072),p=I(e),g=this.tracks.find(T=>T.id===p);if(!g)break;const w=this.fragmentTrackDefaults.find(T=>T.trackId===p);this.currentTrack=g,g.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:w?.defaultSampleDescriptionIndex??null,defaultSampleDuration:w?.defaultSampleDuration??null,defaultSampleSize:w?.defaultSampleSize??null,defaultSampleFlags:w?.defaultSampleFlags??null,startTimestamp:null},o?g.currentFragmentState.baseDataOffset=xe(e):f&&(g.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),c&&(g.currentFragmentState.sampleDescriptionIndex=I(e)),l&&(g.currentFragmentState.defaultSampleDuration=I(e)),u&&(g.currentFragmentState.defaultSampleSize=I(e)),d&&(g.currentFragmentState.defaultSampleFlags=I(e)),h&&(g.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const a=this.currentTrack;if(!a)break;m(a.currentFragmentState);const o=B(e);e.skip(3);const c=o===0?I(e):xe(e);a.currentFragmentState.startTimestamp=c}break;case"trun":{const a=this.currentTrack;if(!a)break;if(m(this.currentFragment),m(a.currentFragmentState),this.currentFragment.trackData.has(a.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const o=B(e),c=bt(e),l=!!(c&1),u=!!(c&4),d=!!(c&256),h=!!(c&512),f=!!(c&1024),p=!!(c&2048),g=I(e);let w=a.currentFragmentState.baseDataOffset;l&&(w+=rt(e));let T=null;u&&(T=I(e));let k=w;if(g===0){this.currentFragment.implicitBaseDataOffset=k;break}let S=0;const y={track:a,startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(a.id,y);for(let C=0;C<g;C++){let P;d?P=I(e):(m(a.currentFragmentState.defaultSampleDuration!==null),P=a.currentFragmentState.defaultSampleDuration);let A;h?A=I(e):(m(a.currentFragmentState.defaultSampleSize!==null),A=a.currentFragmentState.defaultSampleSize);let R;f?R=I(e):(m(a.currentFragmentState.defaultSampleFlags!==null),R=a.currentFragmentState.defaultSampleFlags),C===0&&T!==null&&(R=T);let F=0;p&&(o===0?F=I(e):F=rt(e));const U=!(R&65536);y.samples.push({presentationTimestamp:S+F,duration:P,byteOffset:k,byteSize:A,isKeyFrame:U}),k+=A,S+=P}y.presentationTimestamps=y.samples.map((C,P)=>({presentationTimestamp:C.presentationTimestamp,sampleIndex:P})).sort((C,P)=>C.presentationTimestamp-P.presentationTimestamp);for(let C=0;C<y.presentationTimestamps.length;C++){const P=y.presentationTimestamps[C],A=y.samples[P.sampleIndex];if(y.firstKeyFrameTimestamp===null&&A.isKeyFrame&&(y.firstKeyFrameTimestamp=A.presentationTimestamp),C<y.presentationTimestamps.length-1){const R=y.presentationTimestamps[C+1];A.duration=R.presentationTimestamp-P.presentationTimestamp}}const x=y.samples[y.presentationTimestamps[0].sampleIndex],v=y.samples[X(y.presentationTimestamps).sampleIndex];y.startTimestamp=x.presentationTimestamp,y.endTimestamp=v.presentationTimestamp+v.duration,this.currentFragment.implicitBaseDataOffset=k}break;case"udta":{const a=this.iterateContiguousBoxes(e.slice(s,i.contentSize));for(const{boxInfo:o,slice:c}of a){if(o.name!=="meta"&&!this.currentTrack){const l=c.filePos;this.metadataTags.raw??={},o.name[0]===""?this.metadataTags.raw[o.name]??=Pe(c):this.metadataTags.raw[o.name]??=D(c,o.contentSize),c.filePos=l}switch(o.name){case"meta":c.skip(-o.headerSize),this.traverseBox(c);break;case"nam":case"name":this.currentTrack?this.currentTrack.name=ke.decode(D(c,o.contentSize)):this.metadataTags.title??=Pe(c);break;case"des":this.currentTrack||(this.metadataTags.description??=Pe(c));break;case"ART":this.currentTrack||(this.metadataTags.artist??=Pe(c));break;case"alb":this.currentTrack||(this.metadataTags.album??=Pe(c));break;case"albr":this.currentTrack||(this.metadataTags.albumArtist??=Pe(c));break;case"gen":this.currentTrack||(this.metadataTags.genre??=Pe(c));break;case"day":if(!this.currentTrack){const l=new Date(Pe(c));Number.isNaN(l.getTime())||(this.metadataTags.date??=l)}break;case"cmt":this.currentTrack||(this.metadataTags.comment??=Pe(c));break;case"lyr":this.currentTrack||(this.metadataTags.lyrics??=Pe(c));break}}}break;case"meta":{if(this.currentTrack)break;const o=I(e)!==0;this.currentMetadataKeys=new Map,o?this.readContiguousBoxes(e.slice(s,i.contentSize)):this.readContiguousBoxes(e.slice(s+4,i.contentSize-4)),this.currentMetadataKeys=null}break;case"keys":{if(!this.currentMetadataKeys)break;e.skip(4);const a=I(e);for(let o=0;o<a;o++){const c=I(e);e.skip(4);const l=ke.decode(D(e,c-8));this.currentMetadataKeys.set(o+1,l)}}break;case"ilst":{if(!this.currentMetadataKeys)break;const a=this.iterateContiguousBoxes(e.slice(s,i.contentSize));for(const{boxInfo:o,slice:c}of a){let l=o.name;const u=(l.charCodeAt(0)<<24)+(l.charCodeAt(1)<<16)+(l.charCodeAt(2)<<8)+l.charCodeAt(3);this.currentMetadataKeys.has(u)&&(l=this.currentMetadataKeys.get(u));const d=Za(c);switch(this.metadataTags.raw??={},this.metadataTags.raw[l]??=d,l){case"nam":case"titl":case"com.apple.quicktime.title":case"title":typeof d=="string"&&(this.metadataTags.title??=d);break;case"des":case"desc":case"dscp":case"com.apple.quicktime.description":case"description":typeof d=="string"&&(this.metadataTags.description??=d);break;case"ART":case"com.apple.quicktime.artist":case"artist":typeof d=="string"&&(this.metadataTags.artist??=d);break;case"alb":case"albm":case"com.apple.quicktime.album":case"album":typeof d=="string"&&(this.metadataTags.album??=d);break;case"aART":case"album_artist":typeof d=="string"&&(this.metadataTags.albumArtist??=d);break;case"cmt":case"com.apple.quicktime.comment":case"comment":typeof d=="string"&&(this.metadataTags.comment??=d);break;case"gen":case"gnre":case"com.apple.quicktime.genre":case"genre":typeof d=="string"&&(this.metadataTags.genre??=d);break;case"lyr":case"lyrics":typeof d=="string"&&(this.metadataTags.lyrics??=d);break;case"day":case"rldt":case"com.apple.quicktime.creationdate":case"date":if(typeof d=="string"){const h=new Date(d);Number.isNaN(h.getTime())||(this.metadataTags.date??=h)}break;case"covr":case"com.apple.quicktime.artwork":d instanceof St?(this.metadataTags.images??=[],this.metadataTags.images.push({data:d.data,kind:"coverFront",mimeType:d.mimeType})):d instanceof Uint8Array&&(this.metadataTags.images??=[],this.metadataTags.images.push({data:d,kind:"coverFront",mimeType:"image/*"}));break;case"track":if(typeof d=="string"){const h=d.split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(this.metadataTags.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(this.metadataTags.tracksTotal??=p)}break;case"trkn":if(d instanceof Uint8Array&&d.length>=6){const h=L(d),f=h.getUint16(2,!1),p=h.getUint16(4,!1);f>0&&(this.metadataTags.trackNumber??=f),p>0&&(this.metadataTags.tracksTotal??=p)}break;case"disc":case"disk":if(d instanceof Uint8Array&&d.length>=6){const h=L(d),f=h.getUint16(2,!1),p=h.getUint16(4,!1);f>0&&(this.metadataTags.discNumber??=f),p>0&&(this.metadataTags.discsTotal??=p)}break}}}break}return e.filePos=n,!0}}class an{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.internalCodecId}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}getDisposition(){return this.internalTrack.disposition}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}async getFirstPacket(e){const t=await this.fetchPacketForSampleIndex(0,e);return t||!this.internalTrack.demuxer.isFragmented?t:this.performFragmentedLookup(null,i=>i.trackData.get(this.internalTrack.id)?{sampleIndex:0,correctSampleFound:!0}:{sampleIndex:-1,correctSampleFound:!1},-1/0,1/0,e)}mapTimestampIntoTimescale(e){return hr(e*this.internalTrack.timescale)+this.internalTrack.editListOffset}async getPacket(e,t){const i=this.mapTimestampIntoTimescale(e),s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),n=si(s,i),a=await this.fetchPacketForSampleIndex(n,t);return!os(s)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(null,o=>{const c=o.trackData.get(this.internalTrack.id);if(!c)return{sampleIndex:-1,correctSampleFound:!1};const l=H(c.presentationTimestamps,i,h=>h.presentationTimestamp),u=l!==-1?c.presentationTimestamps[l].sampleIndex:-1,d=l!==-1&&i<c.endTimestamp;return{sampleIndex:u,correctSampleFound:d}},i,i,t)}async getNextPacket(e,t){const i=this.packetToSampleIndex.get(e);if(i!==void 0)return this.fetchPacketForSampleIndex(i+1,t);const s=this.packetToFragmentLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");return this.performFragmentedLookup(s.fragment,n=>{if(n===s.fragment){const a=n.trackData.get(this.internalTrack.id);if(s.sampleIndex+1<a.samples.length)return{sampleIndex:s.sampleIndex+1,correctSampleFound:!0}}else if(n.trackData.get(this.internalTrack.id))return{sampleIndex:0,correctSampleFound:!0};return{sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,t)}async getKeyPacket(e,t){const i=this.mapTimestampIntoTimescale(e),s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),n=ro(s,i),a=await this.fetchPacketForSampleIndex(n,t);return!os(s)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(null,o=>{const c=o.trackData.get(this.internalTrack.id);if(!c)return{sampleIndex:-1,correctSampleFound:!1};const l=Ds(c.presentationTimestamps,h=>c.samples[h.sampleIndex].isKeyFrame&&h.presentationTimestamp<=i),u=l!==-1?c.presentationTimestamps[l].sampleIndex:-1,d=l!==-1&&i<c.endTimestamp;return{sampleIndex:u,correctSampleFound:d}},i,i,t)}async getNextKeyPacket(e,t){const i=this.packetToSampleIndex.get(e);if(i!==void 0){const n=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=so(n,i);return this.fetchPacketForSampleIndex(a,t)}const s=this.packetToFragmentLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");return this.performFragmentedLookup(s.fragment,n=>{if(n===s.fragment){const o=n.trackData.get(this.internalTrack.id).samples.findIndex((c,l)=>c.isKeyFrame&&l>s.sampleIndex);if(o!==-1)return{sampleIndex:o,correctSampleFound:!0}}else{const a=n.trackData.get(this.internalTrack.id);if(a&&a.firstKeyFrameTimestamp!==null){const o=a.samples.findIndex(c=>c.isKeyFrame);return m(o!==-1),{sampleIndex:o,correctSampleFound:!0}}}return{sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,t)}async fetchPacketForSampleIndex(e,t){if(e===-1)return null;const i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=io(i,e);if(!s)return null;let n;if(t.metadataOnly)n=Te;else{let l=this.internalTrack.demuxer.reader.requestSlice(s.sampleOffset,s.sampleSize);l instanceof Promise&&(l=await l),m(l),n=D(l,s.sampleSize)}const a=(s.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=s.duration/this.internalTrack.timescale,c=new $(n,s.isKeyFrame?"key":"delta",a,o,e,s.sampleSize);return this.packetToSampleIndex.set(c,e),c}async fetchPacketInFragment(e,t,i){if(t===-1)return null;const n=e.trackData.get(this.internalTrack.id).samples[t];m(n);let a;if(i.metadataOnly)a=Te;else{let u=this.internalTrack.demuxer.reader.requestSlice(n.byteOffset,n.byteSize);u instanceof Promise&&(u=await u),m(u),a=D(u,n.byteSize)}const o=(n.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,c=n.duration/this.internalTrack.timescale,l=new $(a,n.isKeyFrame?"key":"delta",o,c,e.moofOffset+t,n.byteSize);return this.packetToFragmentLocation.set(l,{fragment:e,sampleIndex:t}),l}async performFragmentedLookup(e,t,i,s,n){const a=this.internalTrack.demuxer;let o=null,c=null,l=-1;if(e){const{sampleIndex:w,correctSampleFound:T}=t(e);if(T)return this.fetchPacketInFragment(e,w,n);w!==-1&&(c=e,l=w)}const u=H(this.internalTrack.fragmentLookupTable,i,w=>w.timestamp),d=u!==-1?this.internalTrack.fragmentLookupTable[u]:null,h=H(this.internalTrack.fragmentPositionCache,i,w=>w.startTimestamp),f=h!==-1?this.internalTrack.fragmentPositionCache[h]:null,p=Math.max(d?.moofOffset??0,f?.moofOffset??0)||null;let g;for(e?p===null||e.moofOffset>=p?(g=e.moofOffset+e.moofSize,o=e):g=p:g=p??0;;){if(o){const S=o.trackData.get(this.internalTrack.id);if(S&&S.startTimestamp>s)break}let w=a.reader.requestSliceRange(g,Me,et);if(w instanceof Promise&&(w=await w),!w)break;const T=g,k=$e(w);if(!k)break;if(k.name==="moof"){o=await a.readFragment(T);const{sampleIndex:S,correctSampleFound:y}=t(o);if(y)return this.fetchPacketInFragment(o,S,n);S!==-1&&(c=o,l=S)}g=T+k.totalSize}if(d&&(!c||c.moofOffset<d.moofOffset)){const w=this.internalTrack.fragmentLookupTable[u-1];m(!w||w.timestamp<d.timestamp);const T=w?.timestamp??-1/0;return this.performFragmentedLookup(null,t,T,s,n)}return c?this.fetchPacketInFragment(c,l,n):null}}class eo extends an{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async canBeTransparent(){return!1}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{if(this.internalTrack.info.codec==="vp9"&&!this.internalTrack.info.vp9CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&Zs(e.data)}else if(this.internalTrack.info.codec==="av1"&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&en(e.data)}return{codec:Ws(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class to extends an{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:Ls(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const si=(r,e)=>{if(r.presentationTimestamps){const t=H(r.presentationTimestamps,e,i=>i.presentationTimestamp);return t===-1?-1:r.presentationTimestamps[t].sampleIndex}else{const t=H(r.sampleTimingEntries,e,s=>s.startDecodeTimestamp);if(t===-1)return-1;const i=r.sampleTimingEntries[t];return i.startIndex+Math.min(Math.floor((e-i.startDecodeTimestamp)/i.delta),i.count-1)}},ro=(r,e)=>{if(!r.keySampleIndices)return si(r,e);if(r.presentationTimestamps){const t=H(r.presentationTimestamps,e,i=>i.presentationTimestamp);if(t===-1)return-1;for(let i=t;i>=0;i--){const s=r.presentationTimestamps[i].sampleIndex;if(_r(r.keySampleIndices,s,a=>a)!==-1)return s}return-1}else{const t=si(r,e),i=H(r.keySampleIndices,t,s=>s);return r.keySampleIndices[i]??-1}},io=(r,e)=>{const t=H(r.sampleTimingEntries,e,T=>T.startIndex),i=r.sampleTimingEntries[t];if(!i||i.startIndex+i.count<=e)return null;let n=i.startDecodeTimestamp+(e-i.startIndex)*i.delta;const a=H(r.sampleCompositionTimeOffsets,e,T=>T.startIndex),o=r.sampleCompositionTimeOffsets[a];o&&e-o.startIndex<o.count&&(n+=o.offset);const c=r.sampleSizes[Math.min(e,r.sampleSizes.length-1)],l=H(r.sampleToChunk,e,T=>T.startSampleIndex),u=r.sampleToChunk[l];m(u);const d=u.startChunkIndex+Math.floor((e-u.startSampleIndex)/u.samplesPerChunk),h=r.chunkOffsets[d],f=u.startSampleIndex+(d-u.startChunkIndex)*u.samplesPerChunk;let p=0,g=h;if(r.sampleSizes.length===1)g+=c*(e-f),p+=c*u.samplesPerChunk;else for(let T=f;T<f+u.samplesPerChunk;T++){const k=r.sampleSizes[T];T<e&&(g+=k),p+=k}let w=i.delta;if(r.presentationTimestamps){const T=r.presentationTimestampIndexMap[e];m(T!==void 0),T<r.presentationTimestamps.length-1&&(w=r.presentationTimestamps[T+1].presentationTimestamp-n)}return{presentationTimestamp:n,duration:w,sampleOffset:g,sampleSize:c,chunkOffset:h,chunkSize:p,isKeyFrame:r.keySampleIndices?_r(r.keySampleIndices,e,T=>T)!==-1:!0}},so=(r,e)=>{if(!r.keySampleIndices)return e+1;const t=H(r.keySampleIndices,e,i=>i);return r.keySampleIndices[t+1]??-1},Nr=(r,e)=>{r.startTimestamp+=e,r.endTimestamp+=e;for(const t of r.samples)t.presentationTimestamp+=e;for(const t of r.presentationTimestamps)t.presentationTimestamp+=e},no=r=>{const[e,,,t]=r,i=Math.hypot(e,t),s=e/i,n=t/i,a=-Math.atan2(n,s)*(180/Math.PI);return Number.isFinite(a)?a:0},os=r=>r.sampleSizes.length===0;class ni{constructor(e){this.value=e}}class ai{constructor(e){this.value=e}}class on{constructor(e){this.value=e}}class He{constructor(e){this.value=e}}var b;(function(r){r[r.EBML=440786851]="EBML",r[r.EBMLVersion=17030]="EBMLVersion",r[r.EBMLReadVersion=17143]="EBMLReadVersion",r[r.EBMLMaxIDLength=17138]="EBMLMaxIDLength",r[r.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",r[r.DocType=17026]="DocType",r[r.DocTypeVersion=17031]="DocTypeVersion",r[r.DocTypeReadVersion=17029]="DocTypeReadVersion",r[r.Void=236]="Void",r[r.Segment=408125543]="Segment",r[r.SeekHead=290298740]="SeekHead",r[r.Seek=19899]="Seek",r[r.SeekID=21419]="SeekID",r[r.SeekPosition=21420]="SeekPosition",r[r.Duration=17545]="Duration",r[r.Info=357149030]="Info",r[r.TimestampScale=2807729]="TimestampScale",r[r.MuxingApp=19840]="MuxingApp",r[r.WritingApp=22337]="WritingApp",r[r.Tracks=374648427]="Tracks",r[r.TrackEntry=174]="TrackEntry",r[r.TrackNumber=215]="TrackNumber",r[r.TrackUID=29637]="TrackUID",r[r.TrackType=131]="TrackType",r[r.FlagEnabled=185]="FlagEnabled",r[r.FlagDefault=136]="FlagDefault",r[r.FlagForced=21930]="FlagForced",r[r.FlagOriginal=21934]="FlagOriginal",r[r.FlagHearingImpaired=21931]="FlagHearingImpaired",r[r.FlagVisualImpaired=21932]="FlagVisualImpaired",r[r.FlagCommentary=21935]="FlagCommentary",r[r.FlagLacing=156]="FlagLacing",r[r.Name=21358]="Name",r[r.Language=2274716]="Language",r[r.LanguageBCP47=2274717]="LanguageBCP47",r[r.CodecID=134]="CodecID",r[r.CodecPrivate=25506]="CodecPrivate",r[r.CodecDelay=22186]="CodecDelay",r[r.SeekPreRoll=22203]="SeekPreRoll",r[r.DefaultDuration=2352003]="DefaultDuration",r[r.Video=224]="Video",r[r.PixelWidth=176]="PixelWidth",r[r.PixelHeight=186]="PixelHeight",r[r.AlphaMode=21440]="AlphaMode",r[r.Audio=225]="Audio",r[r.SamplingFrequency=181]="SamplingFrequency",r[r.Channels=159]="Channels",r[r.BitDepth=25188]="BitDepth",r[r.SimpleBlock=163]="SimpleBlock",r[r.BlockGroup=160]="BlockGroup",r[r.Block=161]="Block",r[r.BlockAdditions=30113]="BlockAdditions",r[r.BlockMore=166]="BlockMore",r[r.BlockAdditional=165]="BlockAdditional",r[r.BlockAddID=238]="BlockAddID",r[r.BlockDuration=155]="BlockDuration",r[r.ReferenceBlock=251]="ReferenceBlock",r[r.Cluster=524531317]="Cluster",r[r.Timestamp=231]="Timestamp",r[r.Cues=475249515]="Cues",r[r.CuePoint=187]="CuePoint",r[r.CueTime=179]="CueTime",r[r.CueTrackPositions=183]="CueTrackPositions",r[r.CueTrack=247]="CueTrack",r[r.CueClusterPosition=241]="CueClusterPosition",r[r.Colour=21936]="Colour",r[r.MatrixCoefficients=21937]="MatrixCoefficients",r[r.TransferCharacteristics=21946]="TransferCharacteristics",r[r.Primaries=21947]="Primaries",r[r.Range=21945]="Range",r[r.Projection=30320]="Projection",r[r.ProjectionType=30321]="ProjectionType",r[r.ProjectionPoseRoll=30325]="ProjectionPoseRoll",r[r.Attachments=423732329]="Attachments",r[r.AttachedFile=24999]="AttachedFile",r[r.FileDescription=18046]="FileDescription",r[r.FileName=18030]="FileName",r[r.FileMediaType=18016]="FileMediaType",r[r.FileData=18012]="FileData",r[r.FileUID=18094]="FileUID",r[r.Chapters=272869232]="Chapters",r[r.Tags=307544935]="Tags",r[r.Tag=29555]="Tag",r[r.Targets=25536]="Targets",r[r.TargetTypeValue=26826]="TargetTypeValue",r[r.TargetType=25546]="TargetType",r[r.TagTrackUID=25541]="TagTrackUID",r[r.TagEditionUID=25545]="TagEditionUID",r[r.TagChapterUID=25540]="TagChapterUID",r[r.TagAttachmentUID=25542]="TagAttachmentUID",r[r.SimpleTag=26568]="SimpleTag",r[r.TagName=17827]="TagName",r[r.TagLanguage=17530]="TagLanguage",r[r.TagString=17543]="TagString",r[r.TagBinary=17541]="TagBinary",r[r.ContentEncodings=28032]="ContentEncodings",r[r.ContentEncoding=25152]="ContentEncoding",r[r.ContentEncodingOrder=20529]="ContentEncodingOrder",r[r.ContentEncodingScope=20530]="ContentEncodingScope",r[r.ContentCompression=20532]="ContentCompression",r[r.ContentCompAlgo=16980]="ContentCompAlgo",r[r.ContentCompSettings=16981]="ContentCompSettings",r[r.ContentEncryption=20533]="ContentEncryption"})(b||(b={}));const ao=[b.EBML,b.Segment],Zt=[b.SeekHead,b.Info,b.Cluster,b.Tracks,b.Cues,b.Attachments,b.Chapters,b.Tags],cr=[...ao,...Zt],cs=r=>r<256?1:r<65536?2:r<1<<24?3:r<2**32?4:r<2**40?5:6,ls=r=>r<1n<<8n?1:r<1n<<16n?2:r<1n<<24n?3:r<1n<<32n?4:r<1n<<40n?5:r<1n<<48n?6:r<1n<<56n?7:8,us=r=>r>=-64&&r<64?1:r>=-8192&&r<8192?2:r>=-1048576&&r<1<<20?3:r>=-134217728&&r<1<<27?4:r>=-17179869184&&r<2**34?5:6,oo=r=>{if(r<127)return 1;if(r<16383)return 2;if(r<(1<<21)-1)return 3;if(r<(1<<28)-1)return 4;if(r<2**35-1)return 5;if(r<2**42-1)return 6;throw new Error("EBML varint size not supported "+r)};class co{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap,this.dataOffsets=new WeakMap}writeByte(e){this.helperView.setUint8(0,e),this.writer.write(this.helper.subarray(0,1))}writeFloat32(e){this.helperView.setFloat32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeFloat64(e){this.helperView.setFloat64(0,e,!1),this.writer.write(this.helper)}writeUnsignedInt(e,t=cs(e)){let i=0;switch(t){case 6:this.helperView.setUint8(i++,e/2**40|0);case 5:this.helperView.setUint8(i++,e/2**32|0);case 4:this.helperView.setUint8(i++,e>>24);case 3:this.helperView.setUint8(i++,e>>16);case 2:this.helperView.setUint8(i++,e>>8);case 1:this.helperView.setUint8(i++,e);break;default:throw new Error("Bad unsigned int size "+t)}this.writer.write(this.helper.subarray(0,i))}writeUnsignedBigInt(e,t=ls(e)){let i=0;for(let s=t-1;s>=0;s--)this.helperView.setUint8(i++,Number(e>>BigInt(s*8)&0xffn));this.writer.write(this.helper.subarray(0,i))}writeSignedInt(e,t=us(e)){e<0&&(e+=2**(t*8)),this.writeUnsignedInt(e,t)}writeVarInt(e,t=oo(e)){let i=0;switch(t){case 1:this.helperView.setUint8(i++,128|e);break;case 2:this.helperView.setUint8(i++,64|e>>8),this.helperView.setUint8(i++,e);break;case 3:this.helperView.setUint8(i++,32|e>>16),this.helperView.setUint8(i++,e>>8),this.helperView.setUint8(i++,e);break;case 4:this.helperView.setUint8(i++,16|e>>24),this.helperView.setUint8(i++,e>>16),this.helperView.setUint8(i++,e>>8),this.helperView.setUint8(i++,e);break;case 5:this.helperView.setUint8(i++,8|e/2**32&7),this.helperView.setUint8(i++,e>>24),this.helperView.setUint8(i++,e>>16),this.helperView.setUint8(i++,e>>8),this.helperView.setUint8(i++,e);break;case 6:this.helperView.setUint8(i++,4|e/2**40&3),this.helperView.setUint8(i++,e/2**32|0),this.helperView.setUint8(i++,e>>24),this.helperView.setUint8(i++,e>>16),this.helperView.setUint8(i++,e>>8),this.helperView.setUint8(i++,e);break;default:throw new Error("Bad EBML varint size "+t)}this.writer.write(this.helper.subarray(0,i))}writeAsciiString(e){this.writer.write(new Uint8Array(e.split("").map(t=>t.charCodeAt(0))))}writeEBML(e){if(e!==null)if(e instanceof Uint8Array)this.writer.write(e);else if(Array.isArray(e))for(const t of e)this.writeEBML(t);else if(this.offsets.set(e,this.writer.getPos()),this.writeUnsignedInt(e.id),Array.isArray(e.data)){const t=this.writer.getPos(),i=e.size===-1?1:e.size??4;e.size===-1?this.writeByte(255):this.writer.seek(this.writer.getPos()+i);const s=this.writer.getPos();if(this.dataOffsets.set(e,s),this.writeEBML(e.data),e.size!==-1){const n=this.writer.getPos()-s,a=this.writer.getPos();this.writer.seek(t),this.writeVarInt(n,i),this.writer.seek(a)}}else if(typeof e.data=="number"){const t=e.size??cs(e.data);this.writeVarInt(t),this.writeUnsignedInt(e.data,t)}else if(typeof e.data=="bigint"){const t=e.size??ls(e.data);this.writeVarInt(t),this.writeUnsignedBigInt(e.data,t)}else if(typeof e.data=="string")this.writeVarInt(e.data.length),this.writeAsciiString(e.data);else if(e.data instanceof Uint8Array)this.writeVarInt(e.data.byteLength,e.size),this.writer.write(e.data);else if(e.data instanceof ni)this.writeVarInt(4),this.writeFloat32(e.data.value);else if(e.data instanceof ai)this.writeVarInt(8),this.writeFloat64(e.data.value);else if(e.data instanceof on){const t=e.size??us(e.data.value);this.writeVarInt(t),this.writeSignedInt(e.data.value,t)}else if(e.data instanceof He){const t=j.encode(e.data.value);this.writeVarInt(t.length),this.writer.write(t)}else ae(e.data)}}const oi=8,Ce=2,De=2*oi,cn=r=>{const e=B(r);if(r.skip(-1),e===0)return null;let t=1,i=128;for(;(e&i)===0;)t++,i>>=1;return t},Lt=r=>{const e=B(r);if(e===0)return null;let t=1,i=128;for(;(e&i)===0;)t++,i>>=1;let s=e&i-1;for(let n=1;n<t;n++)s*=256,s+=B(r);return s},N=(r,e)=>{if(e<1||e>8)throw new Error("Bad unsigned int size "+e);let t=0;for(let i=0;i<e;i++)t*=256,t+=B(r);return t},lo=(r,e)=>{if(e<1)throw new Error("Bad unsigned int size "+e);let t=0n;for(let i=0;i<e;i++)t<<=8n,t+=BigInt(B(r));return t},Ii=r=>{const e=cn(r);return e===null?null:N(r,e)},ln=r=>{let e=B(r);return e===255?e=null:(r.skip(-1),e=Lt(r),e===72057594037927940&&(e=null)),e},ze=r=>{const e=Ii(r);if(e===null)return null;const t=ln(r);return{id:e,size:t}},wt=(r,e)=>{const t=D(r,e);let i=0;for(;i<e&&t[i]!==0;)i+=1;return String.fromCharCode(...t.subarray(0,i))},Nt=(r,e)=>{const t=D(r,e);let i=0;for(;i<e&&t[i]!==0;)i+=1;return ke.decode(t.subarray(0,i))},Or=(r,e)=>{if(e===0)return 0;if(e!==4&&e!==8)throw new Error("Bad float size "+e);return e===4?sc(r):An(r)},ci=async(r,e,t,i)=>{const s=new Set(t);let n=e;for(;i===null||n<i;){let a=r.requestSliceRange(n,Ce,De);if(a instanceof Promise&&(a=await a),!a)break;const o=ze(a);if(!o)break;if(s.has(o.id))return{pos:n,found:!0};qe(o.size),n=a.filePos+o.size}return{pos:i!==null&&i>n?i:n,found:!1}},un=async(r,e,t,i)=>{const n=new Set(t);let a=e;for(;a<i;){let o=r.requestSliceRange(a,0,Math.min(65536,i-a));if(o instanceof Promise&&(o=await o),!o||o.length<oi)break;for(let c=0;c<o.length-oi;c++){o.filePos=a;const l=Ii(o);if(l!==null&&n.has(l))return a;a++}}return null},Se={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC","pcm-u8":"A_PCM/INT/LIT","pcm-s16":"A_PCM/INT/LIT","pcm-s16be":"A_PCM/INT/BIG","pcm-s24":"A_PCM/INT/LIT","pcm-s24be":"A_PCM/INT/BIG","pcm-s32":"A_PCM/INT/LIT","pcm-s32be":"A_PCM/INT/BIG","pcm-f32":"A_PCM/FLOAT/IEEE","pcm-f64":"A_PCM/FLOAT/IEEE",webvtt:"S_TEXT/WEBVTT"};function qe(r){if(r===null)throw new Error("Undefined element size is used in a place where it is not supported.")}const dn=r=>{let t=(r.hasVideo?"video/":r.hasAudio?"audio/":"application/")+(r.isWebM?"webm":"x-matroska");if(r.codecStrings.length>0){const i=[...new Set(r.codecStrings.filter(Boolean))];t+=`; codecs="${i.join(", ")}"`}return t};var Be;(function(r){r[r.None=0]="None",r[r.Xiph=1]="Xiph",r[r.FixedSize=2]="FixedSize",r[r.Ebml=3]="Ebml"})(Be||(Be={}));var wr;(function(r){r[r.Block=1]="Block",r[r.Private=2]="Private",r[r.Next=4]="Next"})(wr||(wr={}));var qt;(function(r){r[r.Zlib=0]="Zlib",r[r.Bzlib=1]="Bzlib",r[r.lzo1x=2]="lzo1x",r[r.HeaderStripping=3]="HeaderStripping"})(qt||(qt={}));const Vr=[{id:b.SeekHead,flag:"seekHeadSeen"},{id:b.Info,flag:"infoSeen"},{id:b.Tracks,flag:"tracksSeen"},{id:b.Cues,flag:"cuesSeen"}],hn=10*2**20;class uo extends ct{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentBlockAdditional=null,this.currentCueTime=null,this.currentDecodingInstruction=null,this.currentTagTargetIsMovie=!0,this.currentSimpleTagName=null,this.currentAttachedFile=null,this.isWebM=!1,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...t)}async getTracks(){return await this.readMetadata(),this.segments.flatMap(e=>e.tracks.map(t=>t.inputTrack))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),t=await Promise.all(e.map(i=>i.getCodecParameterString()));return dn({isWebM:this.isWebM,hasVideo:this.segments.some(i=>i.tracks.some(s=>s.info?.type==="video")),hasAudio:this.segments.some(i=>i.tracks.some(s=>s.info?.type==="audio")),codecStrings:t.filter(Boolean)})}async getMetadataTags(){await this.readMetadata();for(const t of this.segments)t.metadataTagsCollected||(this.reader.fileSize!==null&&await this.loadSegmentMetadata(t),t.metadataTagsCollected=!0);let e={};for(const t of this.segments)e={...e,...t.metadataTags};return e}readMetadata(){return this.readMetadataPromise??=(async()=>{let e=0;for(;;){let t=this.reader.requestSliceRange(e,Ce,De);if(t instanceof Promise&&(t=await t),!t)break;const i=ze(t);if(!i)break;const s=i.id;let n=i.size;const a=t.filePos;if(s===b.EBML){qe(n);let o=this.reader.requestSlice(a,n);if(o instanceof Promise&&(o=await o),!o)break;this.readContiguousElements(o)}else if(s===b.Segment){if(await this.readSegment(a,n),n===null||this.reader.fileSize===null)break}else if(s===b.Cluster){if(this.reader.fileSize===null)break;n===null&&(n=(await ci(this.reader,a,cr,this.reader.fileSize)).pos-a);const o=X(this.segments);o&&(o.elementEndPos=a+n)}qe(n),e=a+n}})()}async readSegment(e,t){this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,tagsSeen:!1,attachmentsSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:e,elementEndPos:t===null?null:e+t,clusterSeekStartPos:e,lastReadCluster:null,metadataTags:{},metadataTagsCollected:!1},this.segments.push(this.currentSegment);let i=e;for(;this.currentSegment.elementEndPos===null||i<this.currentSegment.elementEndPos;){let o=this.reader.requestSliceRange(i,Ce,De);if(o instanceof Promise&&(o=await o),!o)break;const c=i,l=ze(o);if(!l||!Zt.includes(l.id)&&l.id!==b.Void){const p=await un(this.reader,c,Zt,Math.min(this.currentSegment.elementEndPos??1/0,c+hn));if(p){i=p;continue}else break}const{id:u,size:d}=l,h=o.filePos,f=Vr.findIndex(p=>p.id===u);if(f!==-1){const p=Vr[f].flag;this.currentSegment[p]=!0,qe(d);let g=this.reader.requestSlice(h,d);g instanceof Promise&&(g=await g),g&&this.readContiguousElements(g)}else if(u===b.Tags||u===b.Attachments){u===b.Tags?this.currentSegment.tagsSeen=!0:this.currentSegment.attachmentsSeen=!0,qe(d);let p=this.reader.requestSlice(h,d);p instanceof Promise&&(p=await p),p&&this.readContiguousElements(p)}else if(u===b.Cluster){this.currentSegment.clusterSeekStartPos=c;break}if(d===null)break;i=h+d}if(this.currentSegment.seekEntries.sort((o,c)=>o.segmentPosition-c.segmentPosition),this.reader.fileSize!==null)for(const o of this.currentSegment.seekEntries){const c=Vr.find(p=>p.id===o.id);if(!c||this.currentSegment[c.flag])continue;let l=this.reader.requestSliceRange(e+o.segmentPosition,Ce,De);if(l instanceof Promise&&(l=await l),!l)continue;const u=ze(l);if(!u)continue;const{id:d,size:h}=u;if(d!==c.id)continue;qe(h),this.currentSegment[c.flag]=!0;let f=this.reader.requestSlice(l.filePos,h);f instanceof Promise&&(f=await f),f&&this.readContiguousElements(f)}this.currentSegment.timestampScale===-1&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e9/1e6),this.currentSegment.tracks.sort((o,c)=>Number(c.disposition.default)-Number(o.disposition.default));const s=new Map(this.currentSegment.tracks.map(o=>[o.id,o]));for(const o of this.currentSegment.cuePoints){const c=s.get(o.trackId);c&&c.cuePoints.push(o)}for(const o of this.currentSegment.tracks){o.cuePoints.sort((c,l)=>c.time-l.time);for(let c=0;c<o.cuePoints.length-1;c++){const l=o.cuePoints[c],u=o.cuePoints[c+1];l.time===u.time&&(o.cuePoints.splice(c+1,1),c--)}}let n=null,a=-1/0;for(const o of this.currentSegment.tracks)o.cuePoints.length>a&&(a=o.cuePoints.length,n=o);for(const o of this.currentSegment.tracks)o.cuePoints.length===0&&(o.cuePoints=n.cuePoints);this.currentSegment=null}async readCluster(e,t){if(t.lastReadCluster?.elementStartPos===e)return t.lastReadCluster;let i=this.reader.requestSliceRange(e,Ce,De);i instanceof Promise&&(i=await i),m(i);const s=e,n=ze(i);m(n);const a=n.id;m(a===b.Cluster);let o=n.size;const c=i.filePos;o===null&&(o=(await ci(this.reader,c,cr,t.elementEndPos)).pos-c);let l=this.reader.requestSlice(c,o);l instanceof Promise&&(l=await l);const u={segment:t,elementStartPos:s,elementEndPos:c+o,dataStartPos:c,timestamp:-1,trackData:new Map};if(this.currentCluster=u,l){const d=this.readContiguousElements(l,cr);u.elementEndPos=d}for(const[,d]of u.trackData){const h=d.track;m(d.blocks.length>0);let f=!1;for(let T=0;T<d.blocks.length;T++){const k=d.blocks[T];k.timestamp+=u.timestamp,f||=k.lacing!==Be.None}d.presentationTimestamps=d.blocks.map((T,k)=>({timestamp:T.timestamp,blockIndex:k})).sort((T,k)=>T.timestamp-k.timestamp);for(let T=0;T<d.presentationTimestamps.length;T++){const k=d.presentationTimestamps[T],S=d.blocks[k.blockIndex];if(d.firstKeyFrameTimestamp===null&&S.isKeyFrame&&(d.firstKeyFrameTimestamp=S.timestamp),T<d.presentationTimestamps.length-1){const y=d.presentationTimestamps[T+1];S.duration=y.timestamp-S.timestamp}else S.duration===0&&h.defaultDuration!=null&&S.lacing===Be.None&&(S.duration=h.defaultDuration)}f&&(this.expandLacedBlocks(d.blocks,h),d.presentationTimestamps=d.blocks.map((T,k)=>({timestamp:T.timestamp,blockIndex:k})).sort((T,k)=>T.timestamp-k.timestamp));const p=d.blocks[d.presentationTimestamps[0].blockIndex],g=d.blocks[X(d.presentationTimestamps).blockIndex];d.startTimestamp=p.timestamp,d.endTimestamp=g.timestamp+g.duration;const w=H(h.clusterPositionCache,d.startTimestamp,T=>T.startTimestamp);(w===-1||h.clusterPositionCache[w].elementStartPos!==s)&&h.clusterPositionCache.splice(w+1,0,{elementStartPos:u.elementStartPos,startTimestamp:d.startTimestamp})}return t.lastReadCluster=u,u}getTrackDataInCluster(e,t){let i=e.trackData.get(t);if(!i){const s=e.segment.tracks.find(n=>n.id===t);if(!s)return null;i={track:s,startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(t,i)}return i}expandLacedBlocks(e,t){for(let i=0;i<e.length;i++){const s=e[i];if(s.lacing===Be.None)continue;s.decoded||(s.data=this.decodeBlockData(t,s.data),s.decoded=!0);const n=st.tempFromBytes(s.data),a=[],o=B(n)+1;switch(s.lacing){case Be.Xiph:{let l=0;for(let u=0;u<o-1;u++){let d=0;for(;n.bufferPos<n.length;){const h=B(n);if(d+=h,h<255){a.push(d),l+=d;break}}}a.push(n.length-(n.bufferPos+l))}break;case Be.FixedSize:{const l=n.length-1,u=Math.floor(l/o);for(let d=0;d<o;d++)a.push(u)}break;case Be.Ebml:{const l=Lt(n);m(l!==null);let u=l;a.push(u);let d=u;for(let h=1;h<o-1;h++){const f=n.bufferPos,p=Lt(n);m(p!==null);const g=p,T=(1<<(n.bufferPos-f)*7-1)-1,k=g-T;u+=k,a.push(u),d+=u}a.push(n.length-(n.bufferPos+d))}break;default:m(!1)}m(a.length===o),e.splice(i,1);const c=s.duration||o*(t.defaultDuration??0);for(let l=0;l<o;l++){const u=a[l],d=D(n,u),h=s.timestamp+c*l/o,f=c/o;e.splice(i+l,0,{timestamp:h,duration:f,isKeyFrame:s.isKeyFrame,data:d,lacing:Be.None,decoded:!0,mainAdditional:s.mainAdditional})}i+=o,i--}}async loadSegmentMetadata(e){for(const t of e.seekEntries){if(!(t.id===b.Tags&&!e.tagsSeen)){if(!(t.id===b.Attachments&&!e.attachmentsSeen))continue}let i=this.reader.requestSliceRange(e.dataStartPos+t.segmentPosition,Ce,De);if(i instanceof Promise&&(i=await i),!i)continue;const s=ze(i);if(!s||s.id!==t.id)continue;const{size:n}=s;qe(n),m(!this.currentSegment),this.currentSegment=e;let a=this.reader.requestSlice(i.filePos,n);a instanceof Promise&&(a=await a),a&&this.readContiguousElements(a),this.currentSegment=null,t.id===b.Tags?e.tagsSeen=!0:t.id===b.Attachments&&(e.attachmentsSeen=!0)}}readContiguousElements(e,t){const i=e.filePos;for(;e.filePos-i<=e.length-Ce;){const s=e.filePos;if(!this.traverseElement(e,t))return s}return e.filePos}traverseElement(e,t){const i=ze(e);if(!i||t&&t.includes(i.id))return!1;const{id:s,size:n}=i,a=e.filePos;switch(qe(n),s){case b.DocType:this.isWebM=wt(e,n)==="webm";break;case b.Seek:{if(!this.currentSegment)break;const o={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(o),this.readContiguousElements(e.slice(a,n)),(o.id===-1||o.segmentPosition===-1)&&this.currentSegment.seekEntries.pop()}break;case b.SeekID:{const o=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!o)break;o.id=N(e,n)}break;case b.SeekPosition:{const o=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!o)break;o.segmentPosition=N(e,n)}break;case b.TimestampScale:{if(!this.currentSegment)break;this.currentSegment.timestampScale=N(e,n),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale}break;case b.Duration:{if(!this.currentSegment)break;this.currentSegment.duration=Or(e,n)}break;case b.TrackEntry:{if(!this.currentSegment)break;if(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusterPositionCache:[],cuePoints:[],disposition:{...at},inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,name:null,languageCode:me,decodingInstructions:[],info:null},this.readContiguousElements(e.slice(a,n)),this.currentTrack.decodingInstructions.some(o=>o.data?.type!=="decompress"||o.scope!==wr.Block||o.data.algorithm!==qt.HeaderStripping)&&(console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`),this.currentTrack=null),this.currentTrack&&this.currentTrack.id!==-1&&this.currentTrack.codecId&&this.currentTrack.info){const o=this.currentTrack.codecId.indexOf("/"),c=o===-1?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,o);if(this.currentTrack.info.type==="video"&&this.currentTrack.info.width!==-1&&this.currentTrack.info.height!==-1){this.currentTrack.codecId===Se.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===Se.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):c===Se.vp8?this.currentTrack.info.codec="vp8":c===Se.vp9?this.currentTrack.info.codec="vp9":c===Se.av1&&(this.currentTrack.info.codec="av1");const l=this.currentTrack,u=new er(this.input,new ho(l));this.currentTrack.inputTrack=u,this.currentSegment.tracks.push(this.currentTrack)}else if(this.currentTrack.info.type==="audio"&&this.currentTrack.info.numberOfChannels!==-1&&this.currentTrack.info.sampleRate!==-1){c===Se.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2")},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===Se.mp3?this.currentTrack.info.codec="mp3":c===Se.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate,this.currentTrack.info.sampleRate=zt):c===Se.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):c===Se.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId==="A_PCM/INT/LIT"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32"):this.currentTrack.codecId==="A_PCM/INT/BIG"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16be":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24be":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32be"):this.currentTrack.codecId==="A_PCM/FLOAT/IEEE"&&(this.currentTrack.info.bitDepth===32?this.currentTrack.info.codec="pcm-f32":this.currentTrack.info.bitDepth===64&&(this.currentTrack.info.codec="pcm-f64"));const l=this.currentTrack,u=new Fe(this.input,new fo(l));this.currentTrack.inputTrack=u,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null}break;case b.TrackNumber:{if(!this.currentTrack)break;this.currentTrack.id=N(e,n)}break;case b.TrackType:{if(!this.currentTrack)break;const o=N(e,n);o===1?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null,alphaMode:!1}:o===2&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case b.FlagEnabled:{if(!this.currentTrack)break;N(e,n)||(this.currentSegment.tracks.pop(),this.currentTrack=null)}break;case b.FlagDefault:{if(!this.currentTrack)break;this.currentTrack.disposition.default=!!N(e,n)}break;case b.FlagForced:{if(!this.currentTrack)break;this.currentTrack.disposition.forced=!!N(e,n)}break;case b.FlagOriginal:{if(!this.currentTrack)break;this.currentTrack.disposition.original=!!N(e,n)}break;case b.FlagHearingImpaired:{if(!this.currentTrack)break;this.currentTrack.disposition.hearingImpaired=!!N(e,n)}break;case b.FlagVisualImpaired:{if(!this.currentTrack)break;this.currentTrack.disposition.visuallyImpaired=!!N(e,n)}break;case b.FlagCommentary:{if(!this.currentTrack)break;this.currentTrack.disposition.commentary=!!N(e,n)}break;case b.CodecID:{if(!this.currentTrack)break;this.currentTrack.codecId=wt(e,n)}break;case b.CodecPrivate:{if(!this.currentTrack)break;this.currentTrack.codecPrivate=D(e,n)}break;case b.DefaultDuration:{if(!this.currentTrack)break;this.currentTrack.defaultDuration=this.currentTrack.segment.timestampFactor*N(e,n)/1e9}break;case b.Name:{if(!this.currentTrack)break;this.currentTrack.name=Nt(e,n)}break;case b.Language:{if(!this.currentTrack||this.currentTrack.languageCode!==me)break;this.currentTrack.languageCode=wt(e,n),$t(this.currentTrack.languageCode)||(this.currentTrack.languageCode=me)}break;case b.LanguageBCP47:{if(!this.currentTrack)break;const c=wt(e,n).split("-")[0];c?this.currentTrack.languageCode=c:this.currentTrack.languageCode=me}break;case b.Video:{if(this.currentTrack?.info?.type!=="video")break;this.readContiguousElements(e.slice(a,n))}break;case b.PixelWidth:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.width=N(e,n)}break;case b.PixelHeight:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.height=N(e,n)}break;case b.AlphaMode:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.alphaMode=N(e,n)===1}break;case b.Colour:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.colorSpace={},this.readContiguousElements(e.slice(a,n))}break;case b.MatrixCoefficients:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const o=N(e,n),c=zs[o]??null;this.currentTrack.info.colorSpace.matrix=c}break;case b.Range:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=N(e,n)===2}break;case b.TransferCharacteristics:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const o=N(e,n),c=Bs[o]??null;this.currentTrack.info.colorSpace.transfer=c}break;case b.Primaries:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const o=N(e,n),c=Fs[o]??null;this.currentTrack.info.colorSpace.primaries=c}break;case b.Projection:{if(this.currentTrack?.info?.type!=="video")break;this.readContiguousElements(e.slice(a,n))}break;case b.ProjectionPoseRoll:{if(this.currentTrack?.info?.type!=="video")break;const c=-Or(e,n);try{this.currentTrack.info.rotation=xr(c)}catch{}}break;case b.Audio:{if(this.currentTrack?.info?.type!=="audio")break;this.readContiguousElements(e.slice(a,n))}break;case b.SamplingFrequency:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.sampleRate=Or(e,n)}break;case b.Channels:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.numberOfChannels=N(e,n)}break;case b.BitDepth:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.bitDepth=N(e,n)}break;case b.CuePoint:{if(!this.currentSegment)break;this.readContiguousElements(e.slice(a,n)),this.currentCueTime=null}break;case b.CueTime:this.currentCueTime=N(e,n);break;case b.CueTrackPositions:{if(this.currentCueTime===null)break;m(this.currentSegment);const o={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(o),this.readContiguousElements(e.slice(a,n)),(o.trackId===-1||o.clusterPosition===-1)&&this.currentSegment.cuePoints.pop()}break;case b.CueTrack:{const o=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!o)break;o.trackId=N(e,n)}break;case b.CueClusterPosition:{const o=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!o)break;m(this.currentSegment),o.clusterPosition=this.currentSegment.dataStartPos+N(e,n)}break;case b.Timestamp:{if(!this.currentCluster)break;this.currentCluster.timestamp=N(e,n)}break;case b.SimpleBlock:{if(!this.currentCluster)break;const o=Lt(e);if(o===null)break;const c=this.getTrackDataInCluster(this.currentCluster,o);if(!c)break;const l=pi(e),u=B(e),d=u>>1&3;let h=!!(u&128);c.track.info?.type==="audio"&&c.track.info.codec&&(h=!0);const f=D(e,n-(e.filePos-a)),p=c.track.decodingInstructions.length>0;c.blocks.push({timestamp:l,duration:0,isKeyFrame:h,data:f,lacing:d,decoded:!p,mainAdditional:null})}break;case b.BlockGroup:{if(!this.currentCluster)break;this.readContiguousElements(e.slice(a,n)),this.currentBlock=null}break;case b.Block:{if(!this.currentCluster)break;const o=Lt(e);if(o===null)break;const c=this.getTrackDataInCluster(this.currentCluster,o);if(!c)break;const l=pi(e),d=B(e)>>1&3,h=D(e,n-(e.filePos-a)),f=c.track.decodingInstructions.length>0;this.currentBlock={timestamp:l,duration:0,isKeyFrame:!0,data:h,lacing:d,decoded:!f,mainAdditional:null},c.blocks.push(this.currentBlock)}break;case b.BlockAdditions:this.readContiguousElements(e.slice(a,n));break;case b.BlockMore:{if(!this.currentBlock)break;this.currentBlockAdditional={addId:1,data:null},this.readContiguousElements(e.slice(a,n)),this.currentBlockAdditional.data&&this.currentBlockAdditional.addId===1&&(this.currentBlock.mainAdditional=this.currentBlockAdditional.data),this.currentBlockAdditional=null}break;case b.BlockAdditional:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.data=D(e,n)}break;case b.BlockAddID:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.addId=N(e,n)}break;case b.BlockDuration:{if(!this.currentBlock)break;this.currentBlock.duration=N(e,n)}break;case b.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1}break;case b.Tag:this.currentTagTargetIsMovie=!0,this.readContiguousElements(e.slice(a,n));break;case b.Targets:this.readContiguousElements(e.slice(a,n));break;case b.TargetTypeValue:N(e,n)!==50&&(this.currentTagTargetIsMovie=!1);break;case b.TagTrackUID:case b.TagEditionUID:case b.TagChapterUID:case b.TagAttachmentUID:this.currentTagTargetIsMovie=!1;break;case b.SimpleTag:{if(!this.currentTagTargetIsMovie)break;this.currentSimpleTagName=null,this.readContiguousElements(e.slice(a,n))}break;case b.TagName:this.currentSimpleTagName=Nt(e,n);break;case b.TagString:{if(!this.currentSimpleTagName)break;const o=Nt(e,n);this.processTagValue(this.currentSimpleTagName,o)}break;case b.TagBinary:{if(!this.currentSimpleTagName)break;const o=D(e,n);this.processTagValue(this.currentSimpleTagName,o)}break;case b.AttachedFile:{if(!this.currentSegment)break;this.currentAttachedFile={fileUid:null,fileName:null,fileMediaType:null,fileData:null,fileDescription:null},this.readContiguousElements(e.slice(a,n));const o=this.currentSegment.metadataTags;if(this.currentAttachedFile.fileUid&&this.currentAttachedFile.fileData&&(o.raw??={},o.raw[this.currentAttachedFile.fileUid.toString()]=new Si(this.currentAttachedFile.fileData,this.currentAttachedFile.fileMediaType??void 0,this.currentAttachedFile.fileName??void 0,this.currentAttachedFile.fileDescription??void 0)),this.currentAttachedFile.fileMediaType?.startsWith("image/")&&this.currentAttachedFile.fileData){const c=this.currentAttachedFile.fileName;let l="unknown";if(c){const u=c.toLowerCase();u.startsWith("cover.")?l="coverFront":u.startsWith("back.")&&(l="coverBack")}o.images??=[],o.images.push({data:this.currentAttachedFile.fileData,mimeType:this.currentAttachedFile.fileMediaType,kind:l,name:this.currentAttachedFile.fileName??void 0,description:this.currentAttachedFile.fileDescription??void 0})}this.currentAttachedFile=null}break;case b.FileUID:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileUid=lo(e,n)}break;case b.FileName:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileName=Nt(e,n)}break;case b.FileMediaType:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileMediaType=wt(e,n)}break;case b.FileData:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileData=D(e,n)}break;case b.FileDescription:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileDescription=Nt(e,n)}break;case b.ContentEncodings:{if(!this.currentTrack)break;this.readContiguousElements(e.slice(a,n)),this.currentTrack.decodingInstructions.sort((o,c)=>c.order-o.order)}break;case b.ContentEncoding:this.currentDecodingInstruction={order:0,scope:wr.Block,data:null},this.readContiguousElements(e.slice(a,n)),this.currentDecodingInstruction.data&&this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction),this.currentDecodingInstruction=null;break;case b.ContentEncodingOrder:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.order=N(e,n)}break;case b.ContentEncodingScope:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.scope=N(e,n)}break;case b.ContentCompression:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decompress",algorithm:qt.Zlib,settings:null},this.readContiguousElements(e.slice(a,n))}break;case b.ContentCompAlgo:{if(this.currentDecodingInstruction?.data?.type!=="decompress")break;this.currentDecodingInstruction.data.algorithm=N(e,n)}break;case b.ContentCompSettings:{if(this.currentDecodingInstruction?.data?.type!=="decompress")break;this.currentDecodingInstruction.data.settings=D(e,n)}break;case b.ContentEncryption:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decrypt"}}break}return e.filePos=a+n,!0}decodeBlockData(e,t){m(e.decodingInstructions.length>0);let i=t;for(const s of e.decodingInstructions)switch(m(s.data),s.data.type){case"decompress":switch(s.data.algorithm){case qt.HeaderStripping:if(s.data.settings&&s.data.settings.length>0){const n=s.data.settings,a=new Uint8Array(n.length+i.length);a.set(n,0),a.set(i,n.length),i=a}break}break}return i}processTagValue(e,t){if(!this.currentSegment?.metadataTags)return;const i=this.currentSegment.metadataTags;if(i.raw??={},i.raw[e]??=t,typeof t=="string")switch(e.toLowerCase()){case"title":i.title??=t;break;case"description":i.description??=t;break;case"artist":i.artist??=t;break;case"album":i.album??=t;break;case"album_artist":i.albumArtist??=t;break;case"genre":i.genre??=t;break;case"comment":i.comment??=t;break;case"lyrics":i.lyrics??=t;break;case"date":{const s=new Date(t);Number.isNaN(s.getTime())||(i.date??=s)}break;case"track_number":case"part_number":{const s=t.split("/"),n=Number.parseInt(s[0],10),a=s[1]&&Number.parseInt(s[1],10);Number.isInteger(n)&&n>0&&(i.trackNumber??=n),a&&Number.isInteger(a)&&a>0&&(i.tracksTotal??=a)}break;case"disc_number":case"disc":{const s=t.split("/"),n=Number.parseInt(s[0],10),a=s[1]&&Number.parseInt(s[1],10);Number.isInteger(n)&&n>0&&(i.discNumber??=n),a&&Number.isInteger(a)&&a>0&&(i.discsTotal??=a)}break}}}class fn{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.codecId}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}getDisposition(){return this.internalTrack.disposition}async getFirstPacket(e){return this.performClusterLookup(null,t=>t.trackData.get(this.internalTrack.id)?{blockIndex:0,correctBlockFound:!0}:{blockIndex:-1,correctBlockFound:!1},-1/0,1/0,e)}intoTimescale(e){return hr(e*this.internalTrack.segment.timestampFactor)}async getPacket(e,t){const i=this.intoTimescale(e);return this.performClusterLookup(null,s=>{const n=s.trackData.get(this.internalTrack.id);if(!n)return{blockIndex:-1,correctBlockFound:!1};const a=H(n.presentationTimestamps,i,l=>l.timestamp),o=a!==-1?n.presentationTimestamps[a].blockIndex:-1,c=a!==-1&&i<n.endTimestamp;return{blockIndex:o,correctBlockFound:c}},i,i,t)}async getNextPacket(e,t){const i=this.packetToClusterLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");return this.performClusterLookup(i.cluster,s=>{if(s===i.cluster){const n=s.trackData.get(this.internalTrack.id);if(i.blockIndex+1<n.blocks.length)return{blockIndex:i.blockIndex+1,correctBlockFound:!0}}else if(s.trackData.get(this.internalTrack.id))return{blockIndex:0,correctBlockFound:!0};return{blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,t)}async getKeyPacket(e,t){const i=this.intoTimescale(e);return this.performClusterLookup(null,s=>{const n=s.trackData.get(this.internalTrack.id);if(!n)return{blockIndex:-1,correctBlockFound:!1};const a=Ds(n.presentationTimestamps,l=>n.blocks[l.blockIndex].isKeyFrame&&l.timestamp<=i),o=a!==-1?n.presentationTimestamps[a].blockIndex:-1,c=a!==-1&&i<n.endTimestamp;return{blockIndex:o,correctBlockFound:c}},i,i,t)}async getNextKeyPacket(e,t){const i=this.packetToClusterLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");return this.performClusterLookup(i.cluster,s=>{if(s===i.cluster){const a=s.trackData.get(this.internalTrack.id).blocks.findIndex((o,c)=>o.isKeyFrame&&c>i.blockIndex);if(a!==-1)return{blockIndex:a,correctBlockFound:!0}}else{const n=s.trackData.get(this.internalTrack.id);if(n&&n.firstKeyFrameTimestamp!==null){const a=n.blocks.findIndex(o=>o.isKeyFrame);return m(a!==-1),{blockIndex:a,correctBlockFound:!0}}}return{blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,t)}async fetchPacketInCluster(e,t,i){if(t===-1)return null;const n=e.trackData.get(this.internalTrack.id).blocks[t];m(n),n.decoded||(n.data=this.internalTrack.demuxer.decodeBlockData(this.internalTrack,n.data),n.decoded=!0);const a=i.metadataOnly?Te:n.data,o=n.timestamp/this.internalTrack.segment.timestampFactor,c=n.duration/this.internalTrack.segment.timestampFactor,l={};n.mainAdditional&&this.internalTrack.info?.type==="video"&&this.internalTrack.info.alphaMode&&(l.alpha=i.metadataOnly?Te:n.mainAdditional,l.alphaByteLength=n.mainAdditional.byteLength);const u=new $(a,n.isKeyFrame?"key":"delta",o,c,e.dataStartPos+t,n.data.byteLength,l);return this.packetToClusterLocation.set(u,{cluster:e,blockIndex:t}),u}async performClusterLookup(e,t,i,s,n){const{demuxer:a,segment:o}=this.internalTrack;let c=null,l=null,u=-1;if(e){const{blockIndex:T,correctBlockFound:k}=t(e);if(k)return this.fetchPacketInCluster(e,T,n);T!==-1&&(l=e,u=T)}const d=H(this.internalTrack.cuePoints,i,T=>T.time),h=d!==-1?this.internalTrack.cuePoints[d]:null,f=H(this.internalTrack.clusterPositionCache,i,T=>T.startTimestamp),p=f!==-1?this.internalTrack.clusterPositionCache[f]:null,g=Math.max(h?.clusterPosition??0,p?.elementStartPos??0)||null;let w;for(e?g===null||e.elementStartPos>=g?(w=e.elementEndPos,c=e):w=g:w=g??o.clusterSeekStartPos;o.elementEndPos===null||w<=o.elementEndPos-Ce;){if(c){const P=c.trackData.get(this.internalTrack.id);if(P&&P.startTimestamp>s)break}let T=a.reader.requestSliceRange(w,Ce,De);if(T instanceof Promise&&(T=await T),!T)break;const k=w,S=ze(T);if(!S||!Zt.includes(S.id)&&S.id!==b.Void){const P=await un(a.reader,k,Zt,Math.min(o.elementEndPos??1/0,k+hn));if(P){w=P;continue}else break}const y=S.id;let x=S.size;const v=T.filePos;if(y===b.Cluster){c=await a.readCluster(k,o),x=c.elementEndPos-v;const{blockIndex:P,correctBlockFound:A}=t(c);if(A)return this.fetchPacketInCluster(c,P,n);P!==-1&&(l=c,u=P)}x===null&&(m(y!==b.Cluster),x=(await ci(a.reader,v,cr,o.elementEndPos)).pos-v);const C=v+x;if(o.elementEndPos===null){let P=a.reader.requestSliceRange(C,Ce,De);if(P instanceof Promise&&(P=await P),!P)break;if(Ii(P)===b.Segment){o.elementEndPos=C;break}}w=C}if(h&&(!l||l.elementStartPos<h.clusterPosition)){const T=this.internalTrack.cuePoints[d-1];m(!T||T.time<h.time);const k=T?.time??-1/0;return this.performClusterLookup(null,t,k,s,n)}return l?this.fetchPacketInCluster(l,u,n):null}}class ho extends fn{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async canBeTransparent(){return this.internalTrack.info.alphaMode}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{let e=null;return(this.internalTrack.info.codec==="vp9"||this.internalTrack.info.codec==="av1"||this.internalTrack.info.codec==="avc"&&!this.internalTrack.info.codecDescription||this.internalTrack.info.codec==="hevc"&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:Ws({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcType:1,avcCodecInfo:this.internalTrack.info.codec==="avc"&&e?Ks(e.data):null,hevcCodecInfo:this.internalTrack.info.codec==="hevc"&&e?Ys(e.data):null,vp9CodecInfo:this.internalTrack.info.codec==="vp9"&&e?Zs(e.data):null,av1CodecInfo:this.internalTrack.info.codec==="av1"&&e?en(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class fo extends fn{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:Ls({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const mn=4,mo=[44100,48e3,32e3],li=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1,-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1,-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],Ei=1483304551,pn=1231971951,ui=(r,e,t,i,s)=>e===0?0:e===1?Math.floor(144*t/(i<<r))+s:e===2?Math.floor(144*t/i)+s:(Math.floor(12*t/i)+s)*4,Ai=(r,e)=>r===3?e===3?21:36:e===3?13:21,gn=(r,e)=>{const t=r>>>24,i=r>>>16&255,s=r>>>8&255,n=r&255;if(t!==255&&i!==255&&s!==255&&n!==255)return{header:null,bytesAdvanced:4};if(t!==255)return{header:null,bytesAdvanced:1};if((i&224)!==224)return{header:null,bytesAdvanced:1};let a=0,o=0;i&16?a=i&8?0:1:(a=1,o=1);const c=i>>3&3,l=i>>1&3,u=s>>4&15,d=(s>>2&3)%3,h=s>>1&1,f=n>>6&3,p=n>>4&3,g=n>>3&1,w=n>>2&1,T=n&3,k=li[a*16*4+l*16+u];if(k===-1)return{header:null,bytesAdvanced:1};const S=k*1e3,y=mo[d]>>a+o,x=ui(a,l,S,y,h);if(e!==null&&e<x)return{header:null,bytesAdvanced:1};let v;return c===3?v=l===3?384:1152:l===3?v=384:l===2?v=1152:v=576,{header:{totalSize:x,mpegVersionId:c,layer:l,bitrate:S,frequencyIndex:d,sampleRate:y,channel:f,modeExtension:p,copyright:g,original:w,emphasis:T,audioSamplesInFrame:v},bytesAdvanced:1}},po=r=>{let e=127,t=0,i=r;for(;(e^2147483647)!==0;)t=i&~e,t<<=1,t|=i&e,e=(e+1<<8)-1,i=t;return t},di=r=>{let e=2130706432,t=0;for(;e!==0;)t>>=1,t|=r&e,e>>=8;return t};var kt;(function(r){r[r.Unsynchronisation=128]="Unsynchronisation",r[r.ExtendedHeader=64]="ExtendedHeader",r[r.ExperimentalIndicator=32]="ExperimentalIndicator",r[r.Footer=16]="Footer"})(kt||(kt={}));var se;(function(r){r[r.ISO_8859_1=0]="ISO_8859_1",r[r.UTF_16_WITH_BOM=1]="UTF_16_WITH_BOM",r[r.UTF_16_BE_NO_BOM=2]="UTF_16_BE_NO_BOM",r[r.UTF_8=3]="UTF_8"})(se||(se={}));const lr=128,br=10,Tt=["Blues","Classic rock","Country","Dance","Disco","Funk","Grunge","Hip-hop","Jazz","Metal","New age","Oldies","Other","Pop","Rhythm and blues","Rap","Reggae","Rock","Techno","Industrial","Alternative","Ska","Death metal","Pranks","Soundtrack","Euro-techno","Ambient","Trip-hop","Vocal","Jazz & funk","Fusion","Trance","Classical","Instrumental","Acid","House","Game","Sound clip","Gospel","Noise","Alternative rock","Bass","Soul","Punk","Space","Meditative","Instrumental pop","Instrumental rock","Ethnic","Gothic","Darkwave","Techno-industrial","Electronic","Pop-folk","Eurodance","Dream","Southern rock","Comedy","Cult","Gangsta","Top 40","Christian rap","Pop/funk","Jungle music","Native US","Cabaret","New wave","Psychedelic","Rave","Showtunes","Trailer","Lo-fi","Tribal","Acid punk","Acid jazz","Polka","Retro","Musical","Rock 'n' roll","Hard rock","Folk","Folk rock","National folk","Swing","Fast fusion","Bebop","Latin","Revival","Celtic","Bluegrass","Avantgarde","Gothic rock","Progressive rock","Psychedelic rock","Symphonic rock","Slow rock","Big band","Chorus","Easy listening","Acoustic","Humour","Speech","Chanson","Opera","Chamber music","Sonata","Symphony","Booty bass","Primus","Porn groove","Satire","Slow jam","Club","Tango","Samba","Folklore","Ballad","Power ballad","Rhythmic Soul","Freestyle","Duet","Punk rock","Drum solo","A cappella","Euro-house","Dance hall","Goa music","Drum & bass","Club-house","Hardcore techno","Terror","Indie","Britpop","Negerpunk","Polsk punk","Beat","Christian gangsta rap","Heavy metal","Black metal","Crossover","Contemporary Christian","Christian rock","Merengue","Salsa","Thrash metal","Anime","Jpop","Synthpop","Christmas","Art rock","Baroque","Bhangra","Big beat","Breakbeat","Chillout","Downtempo","Dub","EBM","Eclectic","Electro","Electroclash","Emo","Experimental","Garage","Global","IDM","Illbient","Industro-Goth","Jam Band","Krautrock","Leftfield","Lounge","Math rock","New romantic","Nu-breakz","Post-punk","Post-rock","Psytrance","Shoegaze","Space rock","Trop rock","World music","Neoclassical","Audiobook","Audio theatre","Neue Deutsche Welle","Podcast","Indie rock","G-Funk","Dubstep","Garage rock","Psybient"],go=(r,e)=>{const t=r.filePos;e.raw??={},e.raw.TAG??=D(r,lr-3),r.filePos=t;const i=ft(r,30);i&&(e.title??=i);const s=ft(r,30);s&&(e.artist??=s);const n=ft(r,30);n&&(e.album??=n);const a=ft(r,4),o=Number.parseInt(a,10);Number.isInteger(o)&&o>0&&(e.date??=new Date(o,0,1));const c=D(r,30);let l;if(c[28]===0&&c[29]!==0){const d=c[29];d>0&&(e.trackNumber??=d),r.skip(-30),l=ft(r,28),r.skip(2)}else r.skip(-30),l=ft(r,30);l&&(e.comment??=l);const u=B(r);u<Tt.length&&(e.genre??=Tt[u])},ft=(r,e)=>{const t=D(r,e),i=gt(t.indexOf(0),t.length),s=t.subarray(0,i);let n="";for(let a=0;a<s.length;a++)n+=String.fromCharCode(s[a]);return n.trimEnd()},kr=r=>{const e=r.filePos,t=te(r,3),i=B(r),s=B(r),n=B(r),a=I(r);if(t!=="ID3"||i===255||s===255||(a&2155905152)!==0)return r.filePos=e,null;const o=di(a);return{majorVersion:i,revision:s,flags:n,size:o}},wn=(r,e,t)=>{if(![2,3,4].includes(e.majorVersion)){console.warn(`Unsupported ID3v2 major version: ${e.majorVersion}`);return}const i=D(r,e.size),s=new wo(e,i);if(e.flags&kt.Footer&&s.removeFooter(),e.flags&kt.Unsynchronisation&&e.majorVersion===3&&s.ununsynchronizeAll(),e.flags&kt.ExtendedHeader){const n=s.readU32();e.majorVersion===3?s.pos+=n:s.pos+=n-4}for(;s.pos<=s.bytes.length-s.frameHeaderSize();){const n=s.readId3V2Frame();if(!n)break;const a=s.pos,o=s.pos+n.size;let c=!1,l=!1,u=!1;if(e.majorVersion===3?(c=!!(n.flags&64),l=!!(n.flags&128)):e.majorVersion===4&&(c=!!(n.flags&4),l=!!(n.flags&8),u=!!(n.flags&2)||!!(e.flags&kt.Unsynchronisation)),c){console.warn(`Skipping encrypted ID3v2 frame ${n.id}`),s.pos=o;continue}if(l){console.warn(`Skipping compressed ID3v2 frame ${n.id}`),s.pos=o;continue}switch(u&&s.ununsynchronizeRegion(s.pos,o),t.raw??={},n.id[0]==="T"?t.raw[n.id]??=s.readId3V2EncodingAndText(o):t.raw[n.id]??=s.readBytes(n.size),s.pos=a,n.id){case"TIT2":case"TT2":t.title??=s.readId3V2EncodingAndText(o);break;case"TIT3":case"TT3":t.description??=s.readId3V2EncodingAndText(o);break;case"TPE1":case"TP1":t.artist??=s.readId3V2EncodingAndText(o);break;case"TALB":case"TAL":t.album??=s.readId3V2EncodingAndText(o);break;case"TPE2":case"TP2":t.albumArtist??=s.readId3V2EncodingAndText(o);break;case"TRCK":case"TRK":{const h=s.readId3V2EncodingAndText(o).split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(t.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(t.tracksTotal??=p)}break;case"TPOS":case"TPA":{const h=s.readId3V2EncodingAndText(o).split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(t.discNumber??=f),p&&Number.isInteger(p)&&p>0&&(t.discsTotal??=p)}break;case"TCON":case"TCO":{const d=s.readId3V2EncodingAndText(o);let h=/^\((\d+)\)/.exec(d);if(h){const f=Number.parseInt(h[1]);if(Tt[f]!==void 0){t.genre??=Tt[f];break}}if(h=/^\d+$/.exec(d),h){const f=Number.parseInt(h[0]);if(Tt[f]!==void 0){t.genre??=Tt[f];break}}t.genre??=d}break;case"TDRC":case"TDAT":{const d=s.readId3V2EncodingAndText(o),h=new Date(d);Number.isNaN(h.getTime())||(t.date??=h)}break;case"TYER":case"TYE":{const d=s.readId3V2EncodingAndText(o),h=Number.parseInt(d,10);Number.isInteger(h)&&(t.date??=new Date(h,0,1))}break;case"USLT":case"ULT":{const d=s.readU8();s.pos+=3,s.readId3V2Text(d,o),t.lyrics??=s.readId3V2Text(d,o)}break;case"COMM":case"COM":{const d=s.readU8();s.pos+=3,s.readId3V2Text(d,o),t.comment??=s.readId3V2Text(d,o)}break;case"APIC":case"PIC":{const d=s.readId3V2TextEncoding();let h;if(e.majorVersion===2){const w=s.readAscii(3);h=w==="PNG"?"image/png":w==="JPG"?"image/jpeg":"image/*"}else h=s.readId3V2Text(d,o);const f=s.readU8(),p=s.readId3V2Text(d,o).trimEnd(),g=o-s.pos;if(g>=0){const w=s.readBytes(g);t.images||(t.images=[]),t.images.push({data:w,mimeType:h,kind:f===3?"coverFront":f===4?"coverBack":"unknown",description:p})}}break;default:s.pos+=n.size;break}s.pos=o}};class wo{constructor(e,t){this.header=e,this.bytes=t,this.pos=0,this.view=new DataView(t.buffer,t.byteOffset,t.byteLength)}frameHeaderSize(){return this.header.majorVersion===2?6:10}ununsynchronizeAll(){const e=[];for(let t=0;t<this.bytes.length;t++){const i=this.bytes[t];e.push(i),i===255&&t!==this.bytes.length-1&&this.bytes[t]===0&&t++}this.bytes=new Uint8Array(e),this.view=new DataView(this.bytes.buffer)}ununsynchronizeRegion(e,t){const i=[];for(let a=e;a<t;a++){const o=this.bytes[a];i.push(o),o===255&&a!==t-1&&this.bytes[a+1]===0&&a++}const s=this.bytes.subarray(0,e),n=this.bytes.subarray(t);this.bytes=new Uint8Array(s.length+i.length+n.length),this.bytes.set(s,0),this.bytes.set(i,s.length),this.bytes.set(n,s.length+i.length),this.view=new DataView(this.bytes.buffer)}removeFooter(){this.bytes=this.bytes.subarray(0,this.bytes.length-br),this.view=new DataView(this.bytes.buffer)}readBytes(e){const t=this.bytes.subarray(this.pos,this.pos+e);return this.pos+=e,t}readU8(){const e=this.view.getUint8(this.pos);return this.pos+=1,e}readU16(){const e=this.view.getUint16(this.pos,!1);return this.pos+=2,e}readU24(){const e=this.view.getUint16(this.pos,!1),t=this.view.getUint8(this.pos+1);return this.pos+=3,e*256+t}readU32(){const e=this.view.getUint32(this.pos,!1);return this.pos+=4,e}readAscii(e){let t="";for(let i=0;i<e;i++)t+=String.fromCharCode(this.view.getUint8(this.pos+i));return this.pos+=e,t}readId3V2Frame(){if(this.header.majorVersion===2){const e=this.readAscii(3);if(e==="\0\0\0")return null;const t=this.readU24();return{id:e,size:t,flags:0}}else{const e=this.readAscii(4);if(e==="\0\0\0\0")return null;const t=this.readU32();let i=this.header.majorVersion===4?di(t):t;const s=this.readU16(),n=this.pos,a=o=>{const c=this.pos+o;if(c>this.bytes.length)return!1;if(c<=this.bytes.length-this.frameHeaderSize()){this.pos+=o;const l=this.readAscii(4);if(l!=="\0\0\0\0"&&!/[0-9A-Z]{4}/.test(l))return!1}return!0};if(!a(i)){const o=this.header.majorVersion===4?t:di(t);a(o)&&(i=o)}return this.pos=n,{id:e,size:i,flags:s}}}readId3V2TextEncoding(){const e=this.readU8();if(e>3)throw new Error(`Unsupported text encoding: ${e}`);return e}readId3V2Text(e,t){const i=this.pos,s=this.readBytes(t-this.pos);switch(e){case se.ISO_8859_1:{let n="";for(let a=0;a<s.length;a++){const o=s[a];if(o===0){this.pos=i+a+1;break}n+=String.fromCharCode(o)}return n}case se.UTF_16_WITH_BOM:if(s[0]===255&&s[1]===254){const n=new TextDecoder("utf-16le"),a=gt(s.findIndex((o,c)=>o===0&&s[c+1]===0&&c%2===0),s.length);return this.pos=i+Math.min(a+2,s.length),n.decode(s.subarray(2,a))}else if(s[0]===254&&s[1]===255){const n=new TextDecoder("utf-16be"),a=gt(s.findIndex((o,c)=>o===0&&s[c+1]===0&&c%2===0),s.length);return this.pos=i+Math.min(a+2,s.length),n.decode(s.subarray(2,a))}else{const n=gt(s.findIndex(a=>a===0),s.length);return this.pos=i+Math.min(n+1,s.length),ke.decode(s.subarray(0,n))}case se.UTF_16_BE_NO_BOM:{const n=new TextDecoder("utf-16be"),a=gt(s.findIndex((o,c)=>o===0&&s[c+1]===0&&c%2===0),s.length);return this.pos=i+Math.min(a+2,s.length),n.decode(s.subarray(0,a))}case se.UTF_8:{const n=gt(s.findIndex(a=>a===0),s.length);return this.pos=i+Math.min(n+1,s.length),ke.decode(s.subarray(0,n))}}}readId3V2EncodingAndText(e){if(this.pos>=e)return"";const t=this.readId3V2TextEncoding();return this.readId3V2Text(t,e)}}class bn{constructor(e){this.helper=new Uint8Array(8),this.helperView=L(this.helper),this.writer=e}writeId3V2Tag(e){const t=this.writer.getPos();this.writeAscii("ID3"),this.writeU8(4),this.writeU8(0),this.writeU8(0),this.writeSynchsafeU32(0);const i=this.writer.getPos(),s=new Set;for(const{key:o,value:c}of Ft(e))switch(o){case"title":this.writeId3V2TextFrame("TIT2",c),s.add("TIT2");break;case"description":this.writeId3V2TextFrame("TIT3",c),s.add("TIT3");break;case"artist":this.writeId3V2TextFrame("TPE1",c),s.add("TPE1");break;case"album":this.writeId3V2TextFrame("TALB",c),s.add("TALB");break;case"albumArtist":this.writeId3V2TextFrame("TPE2",c),s.add("TPE2");break;case"trackNumber":{const l=e.tracksTotal!==void 0?`${c}/${e.tracksTotal}`:c.toString();this.writeId3V2TextFrame("TRCK",l),s.add("TRCK")}break;case"discNumber":{const l=e.discsTotal!==void 0?`${c}/${e.discsTotal}`:c.toString();this.writeId3V2TextFrame("TPOS",l),s.add("TPOS")}break;case"genre":this.writeId3V2TextFrame("TCON",c),s.add("TCON");break;case"date":this.writeId3V2TextFrame("TDRC",c.toISOString().slice(0,10)),s.add("TDRC");break;case"lyrics":this.writeId3V2LyricsFrame(c),s.add("USLT");break;case"comment":this.writeId3V2CommentFrame(c),s.add("COMM");break;case"images":{const l={coverFront:3,coverBack:4,unknown:0};for(const u of c){const d=l[u.kind]??0,h=u.description??"";this.writeId3V2ApicFrame(u.mimeType,d,h,u.data)}}break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:ae(o)}if(e.raw)for(const o in e.raw){const c=e.raw[o];if(c==null||o.length!==4||s.has(o))continue;let l;if(typeof c=="string"){const u=j.encode(c);l=new Uint8Array(u.byteLength+2),l[0]=se.UTF_8,l.set(u,1)}else if(c instanceof Uint8Array)l=c;else continue;this.writeAscii(o),this.writeSynchsafeU32(l.byteLength),this.writeU16(0),this.writer.write(l)}const n=this.writer.getPos(),a=n-i;return this.writer.seek(t+6),this.writeSynchsafeU32(a),this.writer.seek(n),a+10}writeU8(e){this.helper[0]=e,this.writer.write(this.helper.subarray(0,1))}writeU16(e){this.helperView.setUint16(0,e,!1),this.writer.write(this.helper.subarray(0,2))}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeAscii(e){for(let t=0;t<e.length;t++)this.helper[t]=e.charCodeAt(t);this.writer.write(this.helper.subarray(0,e.length))}writeSynchsafeU32(e){this.writeU32(po(e))}writeIsoString(e){const t=new Uint8Array(e.length+1);for(let i=0;i<e.length;i++)t[i]=e.charCodeAt(i);t[e.length]=0,this.writer.write(t)}writeUtf8String(e){const t=j.encode(e);this.writer.write(t),this.writeU8(0)}writeId3V2TextFrame(e,t){const i=pt(t),n=1+(i?t.length:j.encode(t).byteLength)+1;this.writeAscii(e),this.writeSynchsafeU32(n),this.writeU16(0),this.writeU8(i?se.ISO_8859_1:se.UTF_8),i?this.writeIsoString(t):this.writeUtf8String(t)}writeId3V2LyricsFrame(e){const t=pt(e),i="",s=4+i.length+1+e.length+1;this.writeAscii("USLT"),this.writeSynchsafeU32(s),this.writeU16(0),this.writeU8(t?se.ISO_8859_1:se.UTF_8),this.writeAscii("und"),t?(this.writeIsoString(i),this.writeIsoString(e)):(this.writeUtf8String(i),this.writeUtf8String(e))}writeId3V2CommentFrame(e){const t=pt(e),i=t?e.length:j.encode(e).byteLength,s="",n=4+s.length+1+i+1;this.writeAscii("COMM"),this.writeSynchsafeU32(n),this.writeU16(0),this.writeU8(t?se.ISO_8859_1:se.UTF_8),this.writeU8(117),this.writeU8(110),this.writeU8(100),t?(this.writeIsoString(s),this.writeIsoString(e)):(this.writeUtf8String(s),this.writeUtf8String(e))}writeId3V2ApicFrame(e,t,i,s){const n=pt(e)&&pt(i),a=n?i.length:j.encode(i).byteLength,o=1+e.length+1+1+a+1+s.byteLength;this.writeAscii("APIC"),this.writeSynchsafeU32(o),this.writeU16(0),this.writeU8(n?se.ISO_8859_1:se.UTF_8),n?this.writeIsoString(e):this.writeUtf8String(e),this.writeU8(t),n?this.writeIsoString(i):this.writeUtf8String(i),this.writer.write(s)}}const hi=async(r,e,t)=>{let i=e;for(;t===null||i<t;){let s=r.requestSlice(i,mn);if(s instanceof Promise&&(s=await s),!s)break;const n=I(s),a=gn(n,r.fileSize!==null?r.fileSize-i:null);if(a.header)return{header:a.header,startPos:i};i+=a.bytesAdvanced}return null};class bo extends ct{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.metadataTags=null,this.tracks=[],this.readingMutex=new At,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();if(!this.firstFrameHeader)throw new Error("No valid MP3 frame found.");this.tracks=[new Fe(this.input,new ko(this))]})()}async advanceReader(){if(this.lastLoadedPos===0)for(;;){let o=this.reader.requestSlice(this.lastLoadedPos,br);if(o instanceof Promise&&(o=await o),!o){this.lastSampleLoaded=!0;return}const c=kr(o);if(!c)break;this.lastLoadedPos=o.filePos+c.size}const e=await hi(this.reader,this.lastLoadedPos,this.reader.fileSize);if(!e){this.lastSampleLoaded=!0;return}const t=e.header;this.lastLoadedPos=e.startPos+t.totalSize-1;const i=Ai(t.mpegVersionId,t.channel);let s=this.reader.requestSlice(e.startPos+i,4);if(s instanceof Promise&&(s=await s),s){const o=I(s);if(o===Ei||o===pn)return}this.firstFrameHeader||(this.firstFrameHeader=t),t.sampleRate!==this.firstFrameHeader.sampleRate&&console.warn(`MP3 changed sample rate mid-file: ${this.firstFrameHeader.sampleRate} Hz to ${t.sampleRate} Hz. Might be a bug, so please report this file.`);const n=t.audioSamplesInFrame/this.firstFrameHeader.sampleRate,a={timestamp:this.nextTimestampInSamples/this.firstFrameHeader.sampleRate,duration:n,dataStart:e.startPos,dataSize:t.totalSize};this.loadedSamples.push(a),this.nextTimestampInSamples+=t.audioSamplesInFrame}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getMetadataTags(){const e=await this.readingMutex.acquire();try{if(await this.readMetadata(),this.metadataTags)return this.metadataTags;this.metadataTags={};let t=0,i=!1;for(;;){let s=this.reader.requestSlice(t,br);if(s instanceof Promise&&(s=await s),!s)break;const n=kr(s);if(!n)break;i=!0;let a=this.reader.requestSlice(s.filePos,n.size);if(a instanceof Promise&&(a=await a),!a)break;wn(a,n,this.metadataTags),t=s.filePos+n.size}if(!i&&this.reader.fileSize!==null&&this.reader.fileSize>=lr){let s=this.reader.requestSlice(this.reader.fileSize-lr,lr);s instanceof Promise&&(s=await s),m(s),te(s,3)==="TAG"&&go(s,this.metadataTags)}return this.metadataTags}finally{e()}}}class ko{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return me}getCodec(){return"mp3"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.channel===3?1:2}getSampleRate(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}getDisposition(){return{...at}}async getDecoderConfig(){return m(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:this.demuxer.firstFrameHeader.channel===3?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}async getPacketAtIndex(e,t){if(e===-1)return null;const i=this.demuxer.loadedSamples[e];if(!i)return null;let s;if(t.metadataOnly)s=Te;else{let n=this.demuxer.reader.requestSlice(i.dataStart,i.dataSize);if(n instanceof Promise&&(n=await n),!n)return null;s=D(n,i.dataSize)}return new $(s,"key",i.timestamp,i.duration,e,i.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,t){const i=await this.demuxer.readingMutex.acquire();try{const s=_r(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const n=s+1;for(;n>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(n,t)}finally{i()}}async getPacket(e,t){const i=await this.demuxer.readingMutex.acquire();try{for(;;){const s=H(this.demuxer.loadedSamples,e,n=>n.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(s,t);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,t);await this.demuxer.advanceReader()}}finally{i()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}const Fi=1399285583,To=79764919,kn=new Uint32Array(256);for(let r=0;r<256;r++){let e=r<<24;for(let t=0;t<8;t++)e=e&2147483648?e<<1^To:e<<1;kn[r]=e>>>0&4294967295}const Tn=r=>{const e=L(r),t=e.getUint32(22,!0);e.setUint32(22,0,!0);let i=0;for(let s=0;s<r.length;s++){const n=r[s];i=(i<<8^kn[i>>>24^n])>>>0}return e.setUint32(22,t,!0),i},yn=(r,e,t)=>{let i=0,s=null;if(r.length>0)if(e.codec==="vorbis"){m(e.vorbisInfo);const n=e.vorbisInfo.modeBlockflags.length,o=(1<<ra(n-1))-1<<1,c=(r[0]&o)>>1;if(c>=e.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let l=t;const u=e.vorbisInfo.modeBlockflags[c];if(s=e.vorbisInfo.blocksizes[u],u===1){const d=(o|1)+1,h=r[0]&d?1:0;l=e.vorbisInfo.blocksizes[h]}i=l!==null?l+s>>2:0}else e.codec==="opus"&&(i=Da(r).durationInSamples);return{durationInSamples:i,vorbisBlockSize:s}},Sn=r=>{let e="audio/ogg";if(r.codecStrings){const t=[...new Set(r.codecStrings)];e+=`; codecs="${t.join(", ")}"`}return e},tt=27,Ct=282,xn=Ct+65025,jt=r=>{const e=r.filePos;if(yt(r)!==Fi)return null;r.skip(1);const i=B(r),s=ic(r),n=yt(r),a=yt(r),o=yt(r),c=B(r),l=new Uint8Array(c);for(let f=0;f<c;f++)l[f]=B(r);const u=27+c,d=l.reduce((f,p)=>f+p,0),h=u+d;return{headerStartPos:e,totalSize:h,dataStartPos:e+u,dataSize:d,headerType:i,granulePosition:s,serialNumber:n,sequenceNumber:a,checksum:o,lacingValues:l}},yo=(r,e)=>{for(;r.filePos<e-3;){const t=yt(r),i=t&255,s=t>>>8&255,n=t>>>16&255,a=t>>>24&255,o=79;if(!(i!==o&&s!==o&&n!==o&&a!==o)){if(r.skip(-4),t===Fi)return!0;r.skip(1)}}return!1};class So extends ct{constructor(e){super(e),this.metadataPromise=null,this.bitstreams=[],this.tracks=[],this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;;){let t=this.reader.requestSliceRange(e,tt,Ct);if(t instanceof Promise&&(t=await t),!t)break;const i=jt(t);if(!i||!!!(i.headerType&2))break;this.bitstreams.push({serialNumber:i.serialNumber,bosPage:i,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),e=i.headerStartPos+i.totalSize}for(const t of this.bitstreams){const i=await this.readPacket(t.bosPage,0);i&&(i.data.byteLength>=7&&i.data[0]===1&&i.data[1]===118&&i.data[2]===111&&i.data[3]===114&&i.data[4]===98&&i.data[5]===105&&i.data[6]===115?await this.readVorbisMetadata(i,t):i.data.byteLength>=8&&i.data[0]===79&&i.data[1]===112&&i.data[2]===117&&i.data[3]===115&&i.data[4]===72&&i.data[5]===101&&i.data[6]===97&&i.data[7]===100&&await this.readOpusMetadata(i,t),t.codecInfo.codec!==null&&this.tracks.push(new Fe(this.input,new xo(t,this))))}})()}async readVorbisMetadata(e,t){let i=await this.findNextPacketStart(e);if(!i)return;const s=await this.readPacket(i.startPage,i.startSegmentIndex);if(!s||(i=await this.findNextPacketStart(s),!i))return;const n=await this.readPacket(i.startPage,i.startSegmentIndex);if(!n||s.data[0]!==3||n.data[0]!==5)return;const a=[],o=d=>{for(;a.push(Math.min(255,d)),!(d<255);)d-=255};o(e.data.length),o(s.data.length);const c=new Uint8Array(1+a.length+e.data.length+s.data.length+n.data.length);c[0]=2,c.set(a,1),c.set(e.data,1+a.length),c.set(s.data,1+a.length+e.data.length),c.set(n.data,1+a.length+e.data.length+s.data.length),t.codecInfo.codec="vorbis",t.description=c,t.lastMetadataPacket=n;const l=L(e.data);t.numberOfChannels=l.getUint8(11),t.sampleRate=l.getUint32(12,!0);const u=l.getUint8(28);t.codecInfo.vorbisInfo={blocksizes:[1<<(u&15),1<<(u>>4)],modeBlockflags:tn(n.data).modeBlockflags},ei(s.data.subarray(7),this.metadataTags)}async readOpusMetadata(e,t){const i=await this.findNextPacketStart(e);if(!i)return;const s=await this.readPacket(i.startPage,i.startSegmentIndex);if(!s)return;t.codecInfo.codec="opus",t.description=e.data,t.lastMetadataPacket=s;const n=Er(e.data);t.numberOfChannels=n.outputChannelCount,t.sampleRate=zt,t.codecInfo.opusInfo={preSkip:n.preSkip},ei(s.data.subarray(8),this.metadataTags)}async readPacket(e,t){m(t<e.lacingValues.length);let i=0;for(let d=0;d<t;d++)i+=e.lacingValues[d];let s=e,n=i,a=t;const o=[];e:for(;;){let d=this.reader.requestSlice(s.dataStartPos,s.dataSize);d instanceof Promise&&(d=await d),m(d);const h=D(d,s.dataSize);for(;;){if(a===s.lacingValues.length){o.push(h.subarray(i,n));break}const p=s.lacingValues[a];if(n+=p,p<255){o.push(h.subarray(i,n));break e}a++}let f=s.headerStartPos+s.totalSize;for(;;){let p=this.reader.requestSliceRange(f,tt,Ct);if(p instanceof Promise&&(p=await p),!p)return null;const g=jt(p);if(!g)return null;if(s=g,s.serialNumber===e.serialNumber)break;f=s.headerStartPos+s.totalSize}i=0,n=0,a=0}const c=o.reduce((d,h)=>d+h.length,0),l=new Uint8Array(c);let u=0;for(let d=0;d<o.length;d++){const h=o[d];l.set(h,u),u+=h.length}return{data:l,endPage:s,endSegmentIndex:a}}async findNextPacketStart(e){if(e.endSegmentIndex<e.endPage.lacingValues.length-1)return{startPage:e.endPage,startSegmentIndex:e.endSegmentIndex+1};if(!!(e.endPage.headerType&4))return null;let i=e.endPage.headerStartPos+e.endPage.totalSize;for(;;){let s=this.reader.requestSliceRange(i,tt,Ct);if(s instanceof Promise&&(s=await s),!s)return null;const n=jt(s);if(!n)return null;if(n.serialNumber===e.endPage.serialNumber)return{startPage:n,startSegmentIndex:0};i=n.headerStartPos+n.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(t=>t.getCodecParameterString()));return Sn({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),t=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...t)}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}class xo{constructor(e,t){this.bitstream=e,this.demuxer=t,this.encodedPacketToMetadata=new WeakMap,this.sequentialScanCache=[],this.sequentialScanMutex=new At,this.internalSampleRate=e.codecInfo.codec==="opus"?zt:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}getInternalCodecId(){return null}async getDecoderConfig(){return m(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getName(){return null}getLanguageCode(){return me}getDisposition(){return{...at}}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}granulePositionToTimestampInSamples(e){return this.bitstream.codecInfo.codec==="opus"?(m(this.bitstream.codecInfo.opusInfo),e-this.bitstream.codecInfo.opusInfo.preSkip):e}createEncodedPacketFromOggPacket(e,t,i){if(!e)return null;const{durationInSamples:s,vorbisBlockSize:n}=yn(e.data,this.bitstream.codecInfo,t.vorbisLastBlocksize),a=new $(i.metadataOnly?Te:e.data,"key",Math.max(0,t.timestampInSamples)/this.internalSampleRate,s/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(a,{packet:e,timestampInSamples:t.timestampInSamples,durationInSamples:s,vorbisLastBlockSize:t.vorbisLastBlocksize,vorbisBlockSize:n}),a}async getFirstPacket(e){m(this.bitstream.lastMetadataPacket);const t=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!t)return null;let i=0;this.bitstream.codecInfo.codec==="opus"&&(m(this.bitstream.codecInfo.opusInfo),i-=this.bitstream.codecInfo.opusInfo.preSkip);const s=await this.demuxer.readPacket(t.startPage,t.startSegmentIndex);return this.createEncodedPacketFromOggPacket(s,{timestampInSamples:i,vorbisLastBlocksize:null},e)}async getNextPacket(e,t){const i=this.encodedPacketToMetadata.get(e);if(!i)throw new Error("Packet was not created from this track.");const s=await this.demuxer.findNextPacketStart(i.packet);if(!s)return null;const n=i.timestampInSamples+i.durationInSamples,a=await this.demuxer.readPacket(s.startPage,s.startSegmentIndex);return this.createEncodedPacketFromOggPacket(a,{timestampInSamples:n,vorbisLastBlocksize:i.vorbisBlockSize},t)}async getPacket(e,t){if(this.demuxer.reader.fileSize===null)return this.getPacketSequential(e,t);const i=hr(e*this.internalSampleRate);if(i===0)return this.getFirstPacket(t);if(i<0)return null;m(this.bitstream.lastMetadataPacket);const s=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!s)return null;let n=s.startPage,a=this.demuxer.reader.fileSize;const o=[n];e:for(;n.headerStartPos+n.totalSize<a;){const k=n.headerStartPos,S=Math.floor((k+a)/2);let y=S;for(;;){const x=Math.min(y+xn,a-tt);let v=this.demuxer.reader.requestSlice(y,x-y);if(v instanceof Promise&&(v=await v),m(v),!yo(v,x)){a=S+tt;continue e}let P=this.demuxer.reader.requestSliceRange(v.filePos,tt,Ct);P instanceof Promise&&(P=await P),m(P);const A=jt(P);m(A);let R=!1;if(A.serialNumber===this.bitstream.serialNumber)R=!0;else{let U=this.demuxer.reader.requestSlice(A.headerStartPos,A.totalSize);U instanceof Promise&&(U=await U),m(U);const q=D(U,A.totalSize);R=Tn(q)===A.checksum}if(!R){y=A.headerStartPos+4;continue}if(R&&A.serialNumber!==this.bitstream.serialNumber){y=A.headerStartPos+A.totalSize;continue}if(A.granulePosition===-1){y=A.headerStartPos+A.totalSize;continue}this.granulePositionToTimestampInSamples(A.granulePosition)>i?a=A.headerStartPos:(n=A,o.push(A));continue e}}let c=s.startPage;for(const k of o){if(k.granulePosition===n.granulePosition)break;(!c||k.headerStartPos>c.headerStartPos)&&(c=k)}let l=c;const u=[l];for(;!(l.serialNumber===this.bitstream.serialNumber&&l.granulePosition===n.granulePosition);){const k=l.headerStartPos+l.totalSize;let S=this.demuxer.reader.requestSliceRange(k,tt,Ct);S instanceof Promise&&(S=await S),m(S);const y=jt(S);m(y),l=y,l.serialNumber===this.bitstream.serialNumber&&u.push(l)}m(l.granulePosition!==-1);let d=null,h,f,p=l,g=0;if(l.headerStartPos===s.startPage.headerStartPos)h=this.granulePositionToTimestampInSamples(0),f=!0,d=0;else{h=0,f=!1;for(let y=l.lacingValues.length-1;y>=0;y--)if(l.lacingValues[y]<255){d=y+1;break}if(d===null)throw new Error("Invalid page with granule position: no packets end on this page.");g=d-1;const k={data:Te,endPage:p,endSegmentIndex:g};if(await this.demuxer.findNextPacketStart(k)){const y=hs(u,l,d);m(y);const x=ds(u,y.page,y.segmentIndex);x&&(l=x.page,d=x.segmentIndex)}else for(;;){const y=hs(u,l,d);if(!y)break;const x=ds(u,y.page,y.segmentIndex);if(!x)break;if(l=x.page,d=x.segmentIndex,y.page.headerStartPos!==p.headerStartPos){p=y.page,g=y.segmentIndex;break}}}let w=null,T=null;for(;l!==null;){m(d!==null);const k=await this.demuxer.readPacket(l,d);if(!k)break;if(!(l.headerStartPos===s.startPage.headerStartPos&&d<s.startSegmentIndex)){let x=this.createEncodedPacketFromOggPacket(k,{timestampInSamples:h,vorbisLastBlocksize:T?.vorbisBlockSize??null},t);m(x);let v=this.encodedPacketToMetadata.get(x);if(m(v),!f&&k.endPage.headerStartPos===p.headerStartPos&&k.endSegmentIndex===g?(h=this.granulePositionToTimestampInSamples(l.granulePosition),f=!0,x=this.createEncodedPacketFromOggPacket(k,{timestampInSamples:h-v.durationInSamples,vorbisLastBlocksize:T?.vorbisBlockSize??null},t),m(x),v=this.encodedPacketToMetadata.get(x),m(v)):h+=v.durationInSamples,w=x,T=v,f&&(Math.max(h,0)>i||Math.max(v.timestampInSamples,0)===i))break}const y=await this.demuxer.findNextPacketStart(k);if(!y)break;l=y.startPage,d=y.startSegmentIndex}return w}async getPacketSequential(e,t){const i=await this.sequentialScanMutex.acquire();try{const s=hr(e*this.internalSampleRate);e=s/this.internalSampleRate;const n=H(this.sequentialScanCache,s,c=>c.timestampInSamples);let a;if(n!==-1){const c=this.sequentialScanCache[n];a=this.createEncodedPacketFromOggPacket(c.packet,{timestampInSamples:c.timestampInSamples,vorbisLastBlocksize:c.vorbisLastBlockSize},t)}else a=await this.getFirstPacket(t);let o=0;for(;a&&a.timestamp<e;){const c=await this.getNextPacket(a,t);if(!c||c.timestamp>e)break;if(a=c,o++,o===100){o=0;const l=this.encodedPacketToMetadata.get(a);m(l),this.sequentialScanCache.length>0&&m(X(this.sequentialScanCache).timestampInSamples<=l.timestampInSamples),this.sequentialScanCache.push(l)}}return a}finally{i()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}const ds=(r,e,t)=>{let i=e,s=t;e:for(;;){for(s--,s;s>=0;s--)if(i.lacingValues[s]<255){s++;break e}if(m(s===-1),!(i.headerType&1)){s=0;break}const a=Ms(r,o=>o.headerStartPos<i.headerStartPos);if(!a)return null;i=a,s=i.lacingValues.length}if(m(s!==-1),s===i.lacingValues.length){const n=r[r.indexOf(i)+1];m(n),i=n,s=0}return{page:i,segmentIndex:s}},hs=(r,e,t)=>{if(t>0)return{page:e,segmentIndex:t-1};const i=Ms(r,s=>s.headerStartPos<e.headerStartPos);return i?{page:i,segmentIndex:i.lacingValues.length-1}:null};var he;(function(r){r[r.PCM=1]="PCM",r[r.IEEE_FLOAT=3]="IEEE_FLOAT",r[r.ALAW=6]="ALAW",r[r.MULAW=7]="MULAW",r[r.EXTENSIBLE=65534]="EXTENSIBLE"})(he||(he={}));class Co extends ct{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.lastKnownPacketIndex=0,this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=this.reader.requestSlice(0,12);e instanceof Promise&&(e=await e),m(e);const t=te(e,4),i=t!=="RIFX",s=t==="RF64",n=Xe(e,i);let a=s?this.reader.fileSize:Math.min(n+8,this.reader.fileSize??1/0);if(te(e,4)!=="WAVE")throw new Error("Invalid WAVE file - wrong format");let c=0,l=null,u=e.filePos;for(;a===null||u<a;){let h=this.reader.requestSlice(u,8);if(h instanceof Promise&&(h=await h),!h)break;const f=te(h,4),p=Xe(h,i),g=h.filePos;if(s&&c===0&&f!=="ds64")throw new Error('Invalid RF64 file: First chunk must be "ds64".');if(f==="fmt ")await this.parseFmtChunk(g,p,i);else if(f==="data"){if(l??=p,this.dataStart=h.filePos,this.dataSize=Math.min(l,(a??1/0)-this.dataStart),this.reader.fileSize===null)break}else if(f==="ds64"){let w=this.reader.requestSlice(g,p);if(w instanceof Promise&&(w=await w),!w)break;const T=fs(w,i);l=fs(w,i),a=Math.min(T+8,this.reader.fileSize??1/0)}else f==="LIST"?await this.parseListChunk(g,p,i):(f==="ID3 "||f==="id3 ")&&await this.parseId3Chunk(g,p);u=g+p+(p&1),c++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(this.dataStart===-1)throw new Error('Invalid WAVE file - missing "data" chunk');const d=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/d)*d,this.tracks.push(new Fe(this.input,new _o(this)))})()}async parseFmtChunk(e,t,i){let s=this.reader.requestSlice(e,t);if(s instanceof Promise&&(s=await s),!s)return;let n=Ot(s,i);const a=Ot(s,i),o=Xe(s,i);s.skip(4);const c=Ot(s,i);let l;if(t===14?l=8:l=Ot(s,i),t>=18&&n!==357){const u=Ot(s,i),d=t-18;if(Math.min(d,u)>=22&&n===he.EXTENSIBLE){s.skip(6);const f=D(s,16);n=f[0]|f[1]<<8}}(n===he.MULAW||n===he.ALAW)&&(l=8),this.audioInfo={format:n,numberOfChannels:a,sampleRate:o,sampleSizeInBytes:Math.ceil(l/8),blockSizeInBytes:c}}async parseListChunk(e,t,i){let s=this.reader.requestSlice(e,t);if(s instanceof Promise&&(s=await s),!s)return;const n=te(s,4);if(n!=="INFO"&&n!=="INF0")return;let a=s.filePos;for(;a<=e+t-8;){s.filePos=a;const o=te(s,4),c=Xe(s,i),l=D(s,c);let u=0;for(let h=0;h<l.length&&l[h]!==0;h++)u++;const d=String.fromCharCode(...l.subarray(0,u));switch(this.metadataTags.raw??={},this.metadataTags.raw[o]=d,o){case"INAM":case"TITL":this.metadataTags.title??=d;break;case"TIT3":this.metadataTags.description??=d;break;case"IART":this.metadataTags.artist??=d;break;case"IPRD":this.metadataTags.album??=d;break;case"IPRT":case"ITRK":case"TRCK":{const h=d.split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(this.metadataTags.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(this.metadataTags.tracksTotal??=p)}break;case"ICRD":case"IDIT":{const h=new Date(d);Number.isNaN(h.getTime())||(this.metadataTags.date??=h)}break;case"YEAR":{const h=Number.parseInt(d,10);Number.isInteger(h)&&h>0&&(this.metadataTags.date??=new Date(h,0,1))}break;case"IGNR":case"GENR":this.metadataTags.genre??=d;break;case"ICMT":case"CMNT":case"COMM":this.metadataTags.comment??=d;break}a+=8+c+(c&1)}}async parseId3Chunk(e,t){let i=this.reader.requestSlice(e,t);if(i instanceof Promise&&(i=await i),!i)return;const s=kr(i);if(s){const n=i.slice(e+10,s.size);wn(n,s,this.metadataTags)}}getCodec(){if(m(this.audioInfo),this.audioInfo.format===he.MULAW)return"ulaw";if(this.audioInfo.format===he.ALAW)return"alaw";if(this.audioInfo.format===he.PCM){if(this.audioInfo.sampleSizeInBytes===1)return"pcm-u8";if(this.audioInfo.sampleSizeInBytes===2)return"pcm-s16";if(this.audioInfo.sampleSizeInBytes===3)return"pcm-s24";if(this.audioInfo.sampleSizeInBytes===4)return"pcm-s32"}return this.audioInfo.format===he.IEEE_FLOAT&&this.audioInfo.sampleSizeInBytes===4?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getTracks(){return await this.readMetadata(),this.tracks}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}const mt=2048;class _o{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}getInternalCodecId(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.format}async getDecoderConfig(){const e=this.demuxer.getCodec();return e?(m(this.demuxer.audioInfo),{codec:e,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return me}getDisposition(){return{...at}}async getFirstTimestamp(){return 0}async getPacketAtIndex(e,t){m(this.demuxer.audioInfo);const i=e*mt*this.demuxer.audioInfo.blockSizeInBytes;if(i>=this.demuxer.dataSize)return null;const s=Math.min(mt*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-i);if(this.demuxer.reader.fileSize===null){let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+i,s);if(c instanceof Promise&&(c=await c),!c)return null}let n;if(t.metadataOnly)n=Te;else{let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+i,s);c instanceof Promise&&(c=await c),m(c),n=D(c,s)}const a=e*mt/this.demuxer.audioInfo.sampleRate,o=s/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return this.demuxer.lastKnownPacketIndex=Math.max(e,a),new $(n,"key",a,o,e,s)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getPacket(e,t){m(this.demuxer.audioInfo);const i=Math.floor(Math.min(e*this.demuxer.audioInfo.sampleRate/mt,(this.demuxer.dataSize-1)/(mt*this.demuxer.audioInfo.blockSizeInBytes))),s=await this.getPacketAtIndex(i,t);if(s)return s;if(i===0)return null;m(this.demuxer.reader.fileSize===null);let n=await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex,t);for(;n;){const a=await this.getNextPacket(n,t);if(!a)break;n=a}return n}getNextPacket(e,t){m(this.demuxer.audioInfo);const i=Math.round(e.timestamp*this.demuxer.audioInfo.sampleRate/mt);return this.getPacketAtIndex(i+1,t)}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}const Tr=7,yr=9,fi=r=>{const e=r.filePos,t=D(r,9),i=new W(t);if(i.readBits(12)!==4095||(i.skipBits(1),i.readBits(2)!==0))return null;const a=i.readBits(1),o=i.readBits(2)+1,c=i.readBits(4);if(c===15)return null;i.skipBits(1);const l=i.readBits(3);if(l===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");i.skipBits(1),i.skipBits(1),i.skipBits(1),i.skipBits(1);const u=i.readBits(13);i.skipBits(11);const d=i.readBits(2)+1;if(d!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let h=null;return a===1?r.filePos-=2:h=i.readBits(16),{objectType:o,samplingFrequencyIndex:c,channelConfiguration:l,frameLength:u,numberOfAacFrames:d,crcCheck:h,startPos:e}},mi=1024;class Po extends ct{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new At,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();m(this.firstFrameHeader),this.tracks=[new Fe(this.input,new vo(this))]})()}async advanceReader(){let e=this.reader.requestSliceRange(this.lastLoadedPos,Tr,yr);if(e instanceof Promise&&(e=await e),!e){this.lastSampleLoaded=!0;return}const t=fi(e);if(!t){this.lastSampleLoaded=!0;return}if(this.reader.fileSize!==null&&t.startPos+t.frameLength>this.reader.fileSize){this.lastSampleLoaded=!0;return}this.firstFrameHeader||(this.firstFrameHeader=t);const i=Qt[t.samplingFrequencyIndex];m(i!==void 0);const s=mi/i,n=t.crcCheck?yr:Tr,a={timestamp:this.nextTimestampInSamples/i,duration:s,dataStart:t.startPos+n,dataSize:t.frameLength-n};this.loadedSamples.push(a),this.nextTimestampInSamples+=mi,this.lastLoadedPos=t.startPos+t.frameLength}async getMimeType(){return"audio/aac"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getMetadataTags(){return{}}}class vo{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return this.getSampleRate()/mi}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return me}getCodec(){return"aac"}getInternalCodecId(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.objectType}getNumberOfChannels(){m(this.demuxer.firstFrameHeader);const e=xi[this.demuxer.firstFrameHeader.channelConfiguration];return m(e!==void 0),e}getSampleRate(){m(this.demuxer.firstFrameHeader);const e=Qt[this.demuxer.firstFrameHeader.samplingFrequencyIndex];return m(e!==void 0),e}getDisposition(){return{...at}}async getDecoderConfig(){m(this.demuxer.firstFrameHeader);const e=new Uint8Array(3),t=new W(e),{objectType:i,samplingFrequencyIndex:s,channelConfiguration:n}=this.demuxer.firstFrameHeader;return i>31?(t.writeBits(5,31),t.writeBits(6,i-32)):t.writeBits(5,i),t.writeBits(4,s),t.writeBits(4,n),{codec:`mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,numberOfChannels:this.getNumberOfChannels(),sampleRate:this.getSampleRate(),description:e.subarray(0,Math.ceil((t.pos-1)/8))}}async getPacketAtIndex(e,t){if(e===-1)return null;const i=this.demuxer.loadedSamples[e];if(!i)return null;let s;if(t.metadataOnly)s=Te;else{let n=this.demuxer.reader.requestSlice(i.dataStart,i.dataSize);if(n instanceof Promise&&(n=await n),!n)return null;s=D(n,i.dataSize)}return new $(s,"key",i.timestamp,i.duration,e,i.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,t){const i=await this.demuxer.readingMutex.acquire();try{const s=_r(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const n=s+1;for(;n>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(n,t)}finally{i()}}async getPacket(e,t){const i=await this.demuxer.readingMutex.acquire();try{for(;;){const s=H(this.demuxer.loadedSamples,e,n=>n.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(s,t);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,t);await this.demuxer.advanceReader()}}finally{i()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}}const Cn=r=>r===0?null:r===1?192:r>=2&&r<=5?144*2**r:r===6?"uncommon-u8":r===7?"uncommon-u16":r>=8&&r<=15?2**r:null,Io=(r,e)=>{switch(r){case 0:return e;case 1:return 88200;case 2:return 176400;case 3:return 192e3;case 4:return 8e3;case 5:return 16e3;case 6:return 22050;case 7:return 24e3;case 8:return 32e3;case 9:return 44100;case 10:return 48e3;case 11:return 96e3;case 12:return"uncommon-u8";case 13:return"uncommon-u16";case 14:return"uncommon-u16-10";default:return null}},_n=r=>{let e=0;const t=new W(D(r,1));for(;t.readBits(1)===1;)e++;if(e===0)return t.readBits(7);const i=[],s=e-1,n=new W(D(r,s)),a=8-e-1;for(let c=0;c<a;c++)i.unshift(t.readBits(1));for(let c=0;c<s;c++)for(let l=0;l<8;l++){const u=n.readBits(1);l<2||i.unshift(u)}return i.reduce((c,l,u)=>c|l<<u,0)},Pn=(r,e)=>{if(e==="uncommon-u16")return re(r)+1;if(e==="uncommon-u8")return B(r)+1;if(typeof e=="number")return e;ae(e),m(!1)},Eo=(r,e)=>e==="uncommon-u16"?re(r):e==="uncommon-u16-10"?re(r)*10:e==="uncommon-u8"?B(r):typeof e=="number"?e:null,Ao=r=>{let t=0;for(const i of r){t^=i;for(let s=0;s<8;s++)(t&128)!==0?t=t<<1^7:t<<=1,t&=255}return t};class Fo extends ct{constructor(e){super(e),this.loadedSamples=[],this.metadataPromise=null,this.track=null,this.metadataTags={},this.audioInfo=null,this.lastLoadedPos=null,this.blockingBit=null,this.readingMutex=new At,this.lastSampleLoaded=!1,this.reader=e._reader}async computeDuration(){return await this.readMetadata(),m(this.track),this.track.computeDuration()}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}async getTracks(){return await this.readMetadata(),m(this.track),[this.track]}async getMimeType(){return"audio/flac"}async readMetadata(){let e=4;return this.metadataPromise??=(async()=>{for(;this.reader.fileSize===null||e<this.reader.fileSize;){let t=this.reader.requestSlice(e,4);if(t instanceof Promise&&(t=await t),e+=4,t===null)throw new Error(`Metadata block at position ${e} is too small! Corrupted file.`);m(t);const i=B(t),s=bt(t),n=(i&128)!==0;switch(i&127){case Ne.STREAMINFO:{let o=this.reader.requestSlice(e,s);if(o instanceof Promise&&(o=await o),m(o),o===null)throw new Error(`StreamInfo block at position ${e} is too small! Corrupted file.`);const c=D(o,34),l=new W(c),u=l.readBits(16),d=l.readBits(16),h=l.readBits(24),f=l.readBits(24),p=l.readBits(20),g=l.readBits(3)+1;l.readBits(5);const w=l.readBits(36);l.skipBits(128);const T=new Uint8Array(42);T.set(new Uint8Array([102,76,97,67]),0),T.set(new Uint8Array([128,0,0,34]),4),T.set(c,8),this.audioInfo={numberOfChannels:g,sampleRate:p,totalSamples:w,minimumBlockSize:u,maximumBlockSize:d,minimumFrameSize:h,maximumFrameSize:f,description:T},this.track=new Fe(this.input,new Bo(this));break}case Ne.VORBIS_COMMENT:{let o=this.reader.requestSlice(e,s);o instanceof Promise&&(o=await o),m(o),ei(D(o,s),this.metadataTags);break}case Ne.PICTURE:{let o=this.reader.requestSlice(e,s);o instanceof Promise&&(o=await o),m(o);const c=I(o),l=I(o),u=ke.decode(D(o,l)),d=I(o),h=ke.decode(D(o,d));o.skip(16);const f=I(o),p=D(o,f);this.metadataTags.images??=[],this.metadataTags.images.push({data:p,mimeType:u,kind:c===3?"coverFront":c===4?"coverBack":"unknown",description:h});break}}if(e+=s,n){this.lastLoadedPos=e;break}}})()}async readNextFlacFrame({startPos:e,isFirstPacket:t}){m(this.audioInfo);const i=6,n=this.audioInfo.maximumFrameSize+16,a=await this.reader.requestSliceRange(e,this.audioInfo.minimumFrameSize,n);if(!a)return null;const o=this.readFlacFrameHeader({slice:a,isFirstPacket:t});if(!o)return null;for(a.filePos=e+this.audioInfo.minimumFrameSize;;){if(a.filePos>a.end-i)return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:a.end-e,isLastFrame:!0};if(B(a)===255){const l=a.filePos,u=B(a),d=this.blockingBit===1?249:248;if(u!==d){a.filePos=l;continue}a.skip(-2);const h=a.filePos-e,f=this.readFlacFrameHeader({slice:a,isFirstPacket:!1});if(!f){a.filePos=l;continue}if(this.blockingBit===0){if(f.num-o.num!==1){a.filePos=l;continue}}else if(f.num-o.num!==o.blockSize){a.filePos=l;continue}return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:h,isLastFrame:!1}}}}readFlacFrameHeader({slice:e,isFirstPacket:t}){const i=e.filePos,s=D(e,4),n=new W(s);if(n.readBits(15)!==32764)return null;if(this.blockingBit===null){m(t);const w=n.readBits(1);this.blockingBit=w}else if(this.blockingBit===1){if(m(!t),n.readBits(1)!==1)return null}else if(this.blockingBit===0){if(m(!t),n.readBits(1)!==0)return null}else throw new Error("Invalid blocking bit");const o=Cn(n.readBits(4));if(!o)return null;m(this.audioInfo);const c=Io(n.readBits(4),this.audioInfo.sampleRate);if(!c||(n.readBits(4),n.readBits(3),n.readBits(1)!==0))return null;const u=_n(e),d=Pn(e,o),h=Eo(e,c);if(h===null||h!==this.audioInfo.sampleRate)return null;const f=e.filePos-i,p=B(e);e.skip(-f),e.skip(-1);const g=Ao(D(e,f));return p!==g?null:{num:u,blockSize:d,sampleRate:h}}async advanceReader(){await this.readMetadata(),m(this.lastLoadedPos!==null),m(this.audioInfo);const e=this.lastLoadedPos,t=await this.readNextFlacFrame({startPos:e,isFirstPacket:this.loadedSamples.length===0});if(!t){this.lastSampleLoaded=!0;return}const i=this.loadedSamples[this.loadedSamples.length-1],n={blockOffset:i?i.blockOffset+i.blockSize:0,blockSize:t.blockSize,byteOffset:e,byteSize:t.size};if(this.lastLoadedPos=this.lastLoadedPos+t.size,this.loadedSamples.push(n),t.isLastFrame){this.lastSampleLoaded=!0;return}}}class Bo{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return"flac"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return me}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getDisposition(){return{...at}}async getFirstTimestamp(){return 0}async getDecoderConfig(){return m(this.demuxer.audioInfo),{codec:"flac",numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate,description:this.demuxer.audioInfo.description}}async getPacket(e,t){if(m(this.demuxer.audioInfo),e<0)throw new Error("Timestamp cannot be negative");const i=await this.demuxer.readingMutex.acquire();try{for(;;){const s=H(this.demuxer.loadedSamples,e,c=>c.blockOffset/this.demuxer.audioInfo.sampleRate);if(s===-1){await this.demuxer.advanceReader();continue}const n=this.demuxer.loadedSamples[s],a=n.blockOffset/this.demuxer.audioInfo.sampleRate,o=n.blockSize/this.demuxer.audioInfo.sampleRate;if(a+o<=e){if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(this.demuxer.loadedSamples.length-1,t);await this.demuxer.advanceReader();continue}return this.getPacketAtIndex(s,t)}}finally{i()}}async getNextPacket(e,t){const i=await this.demuxer.readingMutex.acquire();try{const s=e.sequenceNumber+1;if(this.demuxer.lastSampleLoaded&&s>=this.demuxer.loadedSamples.length)return null;for(;s>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(s,t)}finally{i()}}getKeyPacket(e,t){return this.getPacket(e,t)}getNextKeyPacket(e,t){return this.getNextPacket(e,t)}async getPacketAtIndex(e,t){const i=this.demuxer.loadedSamples[e];if(!i)return null;let s;if(t.metadataOnly)s=Te;else{let o=this.demuxer.reader.requestSlice(i.byteOffset,i.byteSize);if(o instanceof Promise&&(o=await o),!o)return null;s=D(o,i.byteSize)}m(this.demuxer.audioInfo);const n=i.blockOffset/this.demuxer.audioInfo.sampleRate,a=i.blockSize/this.demuxer.audioInfo.sampleRate;return new $(s,"key",n,a,e,i.byteSize)}async getFirstPacket(e){for(;this.demuxer.loadedSamples.length===0&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(0,e)}}class Ye{}class vn extends Ye{async _getMajorBrand(e){let t=e._reader.requestSlice(0,12);return t instanceof Promise&&(t=await t),!t||(t.skip(4),te(t,4)!=="ftyp")?null:te(t,4)}_createDemuxer(e){return new Ja(e)}}class zo extends vn{async _canReadInput(e){const t=await this._getMajorBrand(e);return!!t&&t!=="qt  "}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class Ro extends vn{async _canReadInput(e){return await this._getMajorBrand(e)==="qt  "}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class In extends Ye{async isSupportedEBMLOfDocType(e,t){let i=e._reader.requestSlice(0,De);if(i instanceof Promise&&(i=await i),!i)return!1;const s=cn(i);if(s===null||s<1||s>8||N(i,s)!==b.EBML)return!1;const a=ln(i);if(a===null)return!1;let o=e._reader.requestSlice(i.filePos,a);if(o instanceof Promise&&(o=await o),!o)return!1;const c=i.filePos;for(;o.filePos<=c+a-Ce;){const l=ze(o);if(!l)break;const{id:u,size:d}=l,h=o.filePos;if(d===null)return!1;switch(u){case b.EBMLVersion:if(N(o,d)!==1)return!1;break;case b.EBMLReadVersion:if(N(o,d)!==1)return!1;break;case b.DocType:if(wt(o,d)!==t)return!1;break;case b.DocTypeVersion:if(N(o,d)>4)return!1;break}o.filePos=h+d}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new uo(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class Mo extends In{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class Do extends Ye{async _canReadInput(e){let t=e._reader.requestSlice(0,10);if(t instanceof Promise&&(t=await t),!t)return!1;let i=0,s=!1;for(;;){let l=e._reader.requestSlice(i,br);if(l instanceof Promise&&(l=await l),!l)break;const u=kr(l);if(!u)break;s=!0,i=l.filePos+u.size}const n=await hi(e._reader,i,i+4096);if(!n)return!1;if(s)return!0;i=n.startPos+n.header.totalSize;const a=await hi(e._reader,i,i+mn);if(!a)return!1;const o=n.header,c=a.header;return!(o.channel!==c.channel||o.sampleRate!==c.sampleRate)}_createDemuxer(e){return new bo(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class Uo extends Ye{async _canReadInput(e){let t=e._reader.requestSlice(0,12);if(t instanceof Promise&&(t=await t),!t)return!1;const i=te(t,4);return i!=="RIFF"&&i!=="RIFX"&&i!=="RF64"?!1:(t.skip(4),te(t,4)==="WAVE")}_createDemuxer(e){return new Co(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class No extends Ye{async _canReadInput(e){let t=e._reader.requestSlice(0,4);return t instanceof Promise&&(t=await t),t?te(t,4)==="OggS":!1}_createDemuxer(e){return new So(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}class Oo extends Ye{async _canReadInput(e){let t=e._reader.requestSlice(0,4);return t instanceof Promise&&(t=await t),t?te(t,4)==="fLaC":!1}get name(){return"FLAC"}get mimeType(){return"audio/flac"}_createDemuxer(e){return new Fo(e)}}class Vo extends Ye{async _canReadInput(e){let t=e._reader.requestSliceRange(0,Tr,yr);if(t instanceof Promise&&(t=await t),!t)return!1;const i=fi(t);if(!i||(t=e._reader.requestSliceRange(i.frameLength,Tr,yr),t instanceof Promise&&(t=await t),!t))return!1;const s=fi(t);return s?i.objectType===s.objectType&&i.samplingFrequencyIndex===s.samplingFrequencyIndex&&i.channelConfiguration===s.channelConfiguration:!1}_createDemuxer(e){return new Po(e)}get name(){return"ADTS"}get mimeType(){return"audio/aac"}}const Wo=new zo,Lo=new Ro,Ho=new In,qo=new Mo,jo=new Do,$o=new Uo,Qo=new No,Ko=new Vo,Go=new Oo,tu=[Wo,Lo,Ho,qo,$o,Qo,Go,jo,Ko],Xo=typeof ur<"u"?ur:void 0;class lt{constructor(){this._disposed=!1,this._sizePromise=null,this.onread=null}async getSizeOrNull(){if(this._disposed)throw new fe;return this._sizePromise??=Promise.resolve(this._retrieveSize())}async getSize(){if(this._disposed)throw new fe;const e=await this.getSizeOrNull();if(e===null)throw new Error("Cannot determine the size of an unsized source.");return e}}class ru extends lt{constructor(e){if(!(e instanceof ArrayBuffer)&&!(typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer)&&!ArrayBuffer.isView(e))throw new TypeError("buffer must be an ArrayBuffer, SharedArrayBuffer, or ArrayBufferView.");super(),this._onreadCalled=!1,this._bytes=K(e),this._view=L(e)}_retrieveSize(){return this._bytes.byteLength}_read(){return this._onreadCalled||(this.onread?.(0,this._bytes.byteLength),this._onreadCalled=!0),{bytes:this._bytes,view:this._view,offset:0}}_dispose(){}}class iu extends lt{constructor(e,t={}){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.maxCacheSize!==void 0&&(!Bt(t.maxCacheSize)||t.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");super(),this._readers=new WeakMap,this._blob=e,this._orchestrator=new zi({maxCacheSize:t.maxCacheSize??8*2**20,maxWorkerCount:4,runWorker:this._runWorker.bind(this),prefetchProfile:Bi.fileSystem})}_retrieveSize(){const e=this._blob.size;return this._orchestrator.fileSize=e,e}_read(e,t){return this._orchestrator.read(e,t)}async _runWorker(e){let t=this._readers.get(e);for(t===void 0&&("stream"in this._blob&&!or()?t=this._blob.slice(e.currentPos).stream().getReader():t=null,this._readers.set(e,t));e.currentPos<e.targetPos&&!e.aborted;)if(t){const{done:i,value:s}=await t.read();if(i)throw this._orchestrator.forgetWorker(e),new Error("Blob reader stopped unexpectedly before all requested data was read.");if(e.aborted)break;this.onread?.(e.currentPos,e.currentPos+s.length),this._orchestrator.supplyWorkerData(e,s)}else{const i=await this._blob.slice(e.currentPos,e.targetPos).arrayBuffer();if(e.aborted)break;this.onread?.(e.currentPos,e.currentPos+i.byteLength),this._orchestrator.supplyWorkerData(e,new Uint8Array(i))}e.running=!1}_dispose(){this._orchestrator.dispose()}}const En=.5*2**20,Yo=(r,e,t)=>{if(e instanceof Error&&(e.message.includes("Failed to fetch")||e.message.includes("Load failed")||e.message.includes("NetworkError when attempting to fetch resource"))){let s=null;try{typeof window<"u"&&typeof window.location<"u"&&(s=new URL(t instanceof Request?t.url:t,window.location.href).origin)}catch{}if((typeof navigator<"u"&&typeof navigator.onLine=="boolean"?navigator.onLine:!0)&&s!==null&&s!==window.location.origin)return console.warn("Request will not be retried because a CORS error was suspected due to different origins. You can modify this behavior by providing your own function for the 'getRetryDelay' option."),null}return Math.min(2**(r-2),16)};class su extends lt{constructor(e,t={}){if(typeof e!="string"&&!(e instanceof URL)&&!(typeof Request<"u"&&e instanceof Request))throw new TypeError("url must be a string, URL or Request.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.requestInit!==void 0&&(!t.requestInit||typeof t.requestInit!="object"))throw new TypeError("options.requestInit, when provided, must be an object.");if(t.getRetryDelay!==void 0&&typeof t.getRetryDelay!="function")throw new TypeError("options.getRetryDelay, when provided, must be a function.");if(t.maxCacheSize!==void 0&&(!Bt(t.maxCacheSize)||t.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");if(t.fetchFn!==void 0&&typeof t.fetchFn!="function")throw new TypeError("options.fetchFn, when provided, must be a function.");super(),this._existingResponses=new WeakMap,this._url=e,this._options=t,this._getRetryDelay=t.getRetryDelay??Yo,this._orchestrator=new zi({maxCacheSize:t.maxCacheSize??64*2**20,maxWorkerCount:2,runWorker:this._runWorker.bind(this),prefetchProfile:Bi.network})}async _retrieveSize(){const e=new AbortController,t=await Yi(this._options.fetchFn??fetch,this._url,Gi(this._options.requestInit??{},{headers:{Range:"bytes=0-"},signal:e.signal}),this._getRetryDelay,()=>this._disposed);if(!t.ok)throw new Error(`Error fetching ${String(this._url)}: ${t.status} ${t.statusText}`);let i,s;if(t.status===206)s=this._getTotalLengthFromRangeResponse(t),i=this._orchestrator.createWorker(0,Math.min(s,En));else{const n=t.headers.get("Content-Length");if(n)s=Number(n),i=this._orchestrator.createWorker(0,s),this._orchestrator.options.maxCacheSize=1/0,console.warn("HTTP server did not respond with 206 Partial Content, meaning the entire remote resource now has to be downloaded. For efficient media file streaming across a network, please make sure your server supports range requests.");else throw new Error(`HTTP response (status ${t.status}) must surface Content-Length header.`)}return this._orchestrator.fileSize=s,this._existingResponses.set(i,{response:t,abortController:e}),this._orchestrator.runWorker(i),s}_read(e,t){return this._orchestrator.read(e,t)}async _runWorker(e){for(;;){const t=this._existingResponses.get(e);this._existingResponses.delete(e);let i=t?.abortController,s=t?.response;if(i||(i=new AbortController,s=await Yi(this._options.fetchFn??fetch,this._url,Gi(this._options.requestInit??{},{headers:{Range:`bytes=${e.currentPos}-`},signal:i.signal}),this._getRetryDelay,()=>this._disposed)),m(s),!s.ok)throw new Error(`Error fetching ${String(this._url)}: ${s.status} ${s.statusText}`);if(e.currentPos>0&&s.status!==206)throw new Error("HTTP server did not respond with 206 Partial Content to a range request. To enable efficient media file streaming across a network, please make sure your server supports range requests.");if(!s.body)throw new Error("Missing HTTP response body stream. The used fetch function must provide the response body as a ReadableStream.");const n=s.body.getReader();for(;;){if(e.currentPos>=e.targetPos||e.aborted){i.abort(),e.running=!1;return}let a;try{a=await n.read()}catch(l){if(this._disposed)throw l;const u=this._getRetryDelay(1,l,this._url);if(u!==null){console.error("Error while reading response stream. Attempting to resume.",l),await new Promise(d=>setTimeout(d,1e3*u));break}else throw l}if(e.aborted)break;const{done:o,value:c}=a;if(o){if(e.currentPos>=e.targetPos){this._orchestrator.forgetWorker(e),e.running=!1;return}break}this.onread?.(e.currentPos,e.currentPos+c.length),this._orchestrator.supplyWorkerData(e,c)}if(e.aborted)break}e.running=!1}_getTotalLengthFromRangeResponse(e){const t=e.headers.get("Content-Range");if(t){const s=/\/(\d+)/.exec(t);if(s)return Number(s[1])}const i=e.headers.get("Content-Length");if(i)return Number(i);throw new Error("Partial HTTP response (status 206) must surface either Content-Range or Content-Length header.")}_dispose(){this._orchestrator.dispose()}}class nu extends lt{constructor(e,t={}){if(typeof e!="string")throw new TypeError("filePath must be a string.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.maxCacheSize!==void 0&&(!Bt(t.maxCacheSize)||t.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");super(),this._fileHandle=null,this._streamSource=new Zo({getSize:async()=>(this._fileHandle=await Xo.fs.open(e,"r"),(await this._fileHandle.stat()).size),read:async(i,s)=>{m(this._fileHandle);const n=new Uint8Array(s-i);return await this._fileHandle.read(n,0,s-i,i),n},maxCacheSize:t.maxCacheSize,prefetchProfile:"fileSystem"})}_read(e,t){return this._streamSource._read(e,t)}_retrieveSize(){return this._streamSource._retrieveSize()}_dispose(){this._streamSource._dispose(),this._fileHandle?.close(),this._fileHandle=null}}class Zo extends lt{constructor(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(typeof e.getSize!="function")throw new TypeError("options.getSize must be a function.");if(typeof e.read!="function")throw new TypeError("options.read must be a function.");if(e.dispose!==void 0&&typeof e.dispose!="function")throw new TypeError("options.dispose, when provided, must be a function.");if(e.maxCacheSize!==void 0&&(!Bt(e.maxCacheSize)||e.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");if(e.prefetchProfile&&!["none","fileSystem","network"].includes(e.prefetchProfile))throw new TypeError("options.prefetchProfile, when provided, must be one of 'none', 'fileSystem' or 'network'.");super(),this._options=e,this._orchestrator=new zi({maxCacheSize:e.maxCacheSize??8*2**20,maxWorkerCount:2,prefetchProfile:Bi[e.prefetchProfile??"none"],runWorker:this._runWorker.bind(this)})}_retrieveSize(){const e=this._options.getSize();if(e instanceof Promise)return e.then(t=>{if(!Number.isInteger(t)||t<0)throw new TypeError("options.getSize must return or resolve to a non-negative integer.");return this._orchestrator.fileSize=t,t});if(!Number.isInteger(e)||e<0)throw new TypeError("options.getSize must return or resolve to a non-negative integer.");return this._orchestrator.fileSize=e,e}_read(e,t){return this._orchestrator.read(e,t)}async _runWorker(e){for(;e.currentPos<e.targetPos&&!e.aborted;){const t=e.currentPos,i=e.targetPos;let s=this._options.read(e.currentPos,i);if(s instanceof Promise&&(s=await s),e.aborted)break;if(s instanceof Uint8Array){if(s=K(s),s.length!==i-e.currentPos)throw new Error(`options.read returned a Uint8Array with unexpected length: Requested ${i-e.currentPos} bytes, but got ${s.length}.`);this.onread?.(e.currentPos,e.currentPos+s.length),this._orchestrator.supplyWorkerData(e,s)}else if(s instanceof ReadableStream){const n=s.getReader();for(;e.currentPos<i&&!e.aborted;){const{done:a,value:o}=await n.read();if(a){if(e.currentPos<i)throw new Error(`ReadableStream returned by options.read ended before supplying enough data. Requested ${i-t} bytes, but got ${e.currentPos-t}`);break}if(!(o instanceof Uint8Array))throw new TypeError("ReadableStream returned by options.read must yield Uint8Array chunks.");if(e.aborted)break;const c=K(o);this.onread?.(e.currentPos,e.currentPos+c.length),this._orchestrator.supplyWorkerData(e,c)}}else throw new TypeError("options.read must return or resolve to a Uint8Array or a ReadableStream.")}e.running=!1}_dispose(){this._orchestrator.dispose(),this._options.dispose?.()}}class au extends lt{constructor(e,t={}){if(!(e instanceof ReadableStream))throw new TypeError("stream must be a ReadableStream.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.maxCacheSize!==void 0&&(!Bt(t.maxCacheSize)||t.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");super(),this._reader=null,this._cache=[],this._pendingSlices=[],this._currentIndex=0,this._targetIndex=0,this._maxRequestedIndex=0,this._endIndex=null,this._pulling=!1,this._stream=e,this._maxCacheSize=t.maxCacheSize??16*2**20}_retrieveSize(){return this._endIndex}_read(e,t){if(this._endIndex!==null&&t>this._endIndex)return null;this._maxRequestedIndex=Math.max(this._maxRequestedIndex,t);const i=H(this._cache,e,u=>u.start),s=i!==-1?this._cache[i]:null;if(s&&s.start<=e&&t<=s.end)return{bytes:s.bytes,view:s.view,offset:s.start};let n=e;const a=new Uint8Array(t-e);if(i!==-1)for(let u=i;u<this._cache.length;u++){const d=this._cache[u];if(d.start>=t)break;const h=Math.max(e,d.start);h>n&&this._throwDueToCacheMiss();const f=Math.min(t,d.end);h<f&&(a.set(d.bytes.subarray(h-d.start,f-d.start),h-e),n=f)}if(n===t)return{bytes:a,view:L(a),offset:e};this._currentIndex>n&&this._throwDueToCacheMiss();const{promise:o,resolve:c,reject:l}=G();return this._pendingSlices.push({start:e,end:t,bytes:a,resolve:c,reject:l}),this._targetIndex=Math.max(this._targetIndex,t),this._pulling||(this._pulling=!0,this._pull().catch(u=>{if(this._pulling=!1,this._pendingSlices.length>0)this._pendingSlices.forEach(d=>d.reject(u)),this._pendingSlices.length=0;else throw u})),o}_throwDueToCacheMiss(){throw new Error("Read is before the cached region. With ReadableStreamSource, you must access the data more sequentially or increase the size of its cache.")}async _pull(){for(this._reader??=this._stream.getReader();this._currentIndex<this._targetIndex&&!this._disposed;){const{done:e,value:t}=await this._reader.read();if(e){for(const n of this._pendingSlices)n.resolve(null);this._pendingSlices.length=0,this._endIndex=this._currentIndex;break}const i=this._currentIndex,s=this._currentIndex+t.byteLength;for(let n=0;n<this._pendingSlices.length;n++){const a=this._pendingSlices[n],o=Math.max(i,a.start),c=Math.min(s,a.end);o<c&&(a.bytes.set(t.subarray(o-i,c-i),o-a.start),c===a.end&&(a.resolve({bytes:a.bytes,view:L(a.bytes),offset:a.start}),this._pendingSlices.splice(n,1),n--))}for(this._cache.push({start:i,end:s,bytes:t,view:L(t),age:0});this._cache.length>0;){const n=this._cache[0];if(this._maxRequestedIndex-n.end<=this._maxCacheSize)break;this._cache.shift()}this._currentIndex+=t.byteLength}this._pulling=!1}_dispose(){this._pendingSlices.length=0,this._cache.length=0}}const Bi={none:(r,e)=>({start:r,end:e}),fileSystem:(r,e)=>(r=Math.floor((r-65536)/65536)*65536,e=Math.ceil((e+65536)/65536)*65536,{start:r,end:e}),network:(r,e,t)=>{r=Math.max(0,Math.floor((r-65536)/65536)*65536);for(const s of t){const a=Math.max((s.startPos+s.targetPos)/2,s.targetPos-8388608);if(Zr(r,e,a,s.targetPos)){const o=s.targetPos-s.startPos,c=Math.ceil((o+1)/8388608)*8388608,l=2**Math.ceil(Math.log2(o+1)),u=Math.min(l,c);e=Math.max(e,s.startPos+u)}}return e=Math.max(e,r+En),{start:r,end:e}}};class zi{constructor(e){this.options=e,this.fileSize=null,this.nextAge=0,this.workers=[],this.cache=[],this.currentCacheSize=0,this.disposed=!1}read(e,t){m(this.fileSize!==null);const i=this.options.prefetchProfile(e,t,this.workers),s=Math.max(i.start,0),n=Math.min(i.end,this.fileSize);m(s<=e&&t<=n);let a=null;const o=H(this.cache,e,k=>k.start),c=o!==-1?this.cache[o]:null;c&&c.start<=e&&t<=c.end&&(c.age=this.nextAge++,a={bytes:c.bytes,view:c.view,offset:c.start});const l=H(this.cache,s,k=>k.start),u=a?null:new Uint8Array(t-e);let d=0,h=s;const f=[];if(l!==-1){for(let k=l;k<this.cache.length;k++){const S=this.cache[k];if(S.start>=n)break;if(S.end<=s)continue;const y=Math.max(s,S.start),x=Math.min(n,S.end);if(m(y<=x),h<y&&f.push({start:h,end:y}),h=x,u){const v=Math.max(e,S.start),C=Math.min(t,S.end);if(v<C){const P=v-e;u.set(S.bytes.subarray(v-S.start,C-S.start),P),P===d&&(d=C-e)}}S.age=this.nextAge++}h<n&&f.push({start:h,end:n})}else f.push({start:s,end:n});if(u&&d>=u.length&&(a={bytes:u,view:L(u),offset:e}),f.length===0)return m(a),a;const{promise:p,resolve:g,reject:w}=G(),T=[];for(const k of f){const S=Math.max(e,k.start),y=Math.min(t,k.end);S===k.start&&y===k.end?T.push(k):S<y&&T.push({start:S,end:y})}for(const k of f){const S=u&&{start:e,bytes:u,holes:T,resolve:g,reject:w};let y=!1;for(const x of this.workers)if(Zr(k.start-131072,k.start,x.currentPos,x.targetPos)){x.targetPos=Math.max(x.targetPos,k.end),y=!0,S&&!x.pendingSlices.includes(S)&&x.pendingSlices.push(S),x.running||this.runWorker(x);break}if(!y){const x=this.createWorker(k.start,k.end);S&&(x.pendingSlices=[S]),this.runWorker(x)}}return a||(m(u),a=p.then(k=>({bytes:k,view:L(k),offset:e}))),a}createWorker(e,t){const i={startPos:e,currentPos:e,targetPos:t,running:!1,aborted:this.disposed,pendingSlices:[],age:this.nextAge++};for(this.workers.push(i);this.workers.length>this.options.maxWorkerCount;){let s=0,n=this.workers[0];for(let a=1;a<this.workers.length;a++){const o=this.workers[a];o.age<n.age&&(s=a,n=o)}if(n.running&&n.pendingSlices.length>0)break;n.aborted=!0,this.workers.splice(s,1)}return i}runWorker(e){m(!e.running),m(e.currentPos<e.targetPos),e.running=!0,e.age=this.nextAge++,this.options.runWorker(e).catch(t=>{if(e.running=!1,e.pendingSlices.length>0)e.pendingSlices.forEach(i=>i.reject(t)),e.pendingSlices.length=0;else throw t})}supplyWorkerData(e,t){m(!e.aborted);const i=e.currentPos,s=i+t.length;this.insertIntoCache({start:i,end:s,bytes:t,view:L(t),age:this.nextAge++}),e.currentPos+=t.length,e.targetPos=Math.max(e.targetPos,e.currentPos);for(let n=0;n<e.pendingSlices.length;n++){const a=e.pendingSlices[n],o=Math.max(i,a.start),c=Math.min(s,a.start+a.bytes.length);o<c&&a.bytes.set(t.subarray(o-i,c-i),o-a.start);for(let l=0;l<a.holes.length;l++){const u=a.holes[l];i<=u.start&&s>u.start&&(u.start=s),u.end<=u.start&&(a.holes.splice(l,1),l--)}a.holes.length===0&&(a.resolve(a.bytes),e.pendingSlices.splice(n,1),n--)}for(let n=0;n<this.workers.length;n++){const a=this.workers[n];e===a||a.running||Zr(i,s,a.currentPos,a.targetPos)&&(this.workers.splice(n,1),n--)}}forgetWorker(e){const t=this.workers.indexOf(e);m(t!==-1),this.workers.splice(t,1)}insertIntoCache(e){if(this.options.maxCacheSize===0)return;let t=H(this.cache,e.start,i=>i.start)+1;if(t>0){const i=this.cache[t-1];if(i.end>=e.end)return;if(i.end>e.start){const s=new Uint8Array(e.end-i.start);s.set(i.bytes,0),s.set(e.bytes,e.start-i.start),this.currentCacheSize+=e.end-i.end,i.bytes=s,i.view=L(s),i.end=e.end,t--,e=i}else this.cache.splice(t,0,e),this.currentCacheSize+=e.bytes.length}else this.cache.splice(t,0,e),this.currentCacheSize+=e.bytes.length;for(let i=t+1;i<this.cache.length;i++){const s=this.cache[i];if(e.end<=s.start)break;if(e.end>=s.end){this.cache.splice(i,1),this.currentCacheSize-=s.bytes.length,i--;continue}const n=new Uint8Array(s.end-e.start);n.set(e.bytes,0),n.set(s.bytes,s.start-e.start),this.currentCacheSize-=e.end-s.start,e.bytes=n,e.view=L(n),e.end=s.end,this.cache.splice(i,1);break}for(;this.currentCacheSize>this.options.maxCacheSize;){let i=0,s=this.cache[0];for(let n=1;n<this.cache.length;n++){const a=this.cache[n];a.age<s.age&&(i=n,s=a)}if(this.currentCacheSize-s.bytes.length<=this.options.maxCacheSize)break;this.cache.splice(i,1),this.currentCacheSize-=s.bytes.length}}dispose(){for(const e of this.workers)e.aborted=!0;this.workers.length=0,this.cache.length=0,this.disposed=!0}}Os();class Jo{get disposed(){return this._disposed}constructor(e){if(this._demuxerPromise=null,this._format=null,this._disposed=!1,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some(t=>!(t instanceof Ye)))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof lt))throw new TypeError("options.source must be a Source.");if(e.source._disposed)throw new Error("options.source must not be disposed.");this._formats=e.formats,this._source=e.source,this._reader=new ec(e.source)}_getDemuxer(){return this._demuxerPromise??=(async()=>{this._reader.fileSize=await this._source.getSizeOrNull();for(const e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unsupported or unrecognizable format.")})()}get source(){return this._source}async getFormat(){return await this._getDemuxer(),m(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(t=>t.isVideoTrack())}async getAudioTracks(){return(await this.getTracks()).filter(t=>t.isAudioTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(t=>t.isVideoTrack())??null}async getPrimaryAudioTrack(){return(await this.getTracks()).find(t=>t.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}async getMetadataTags(){return(await this._getDemuxer()).getMetadataTags()}dispose(){this._disposed||(this._disposed=!0,this._source._disposed=!0,this._source._dispose())}[Symbol.dispose](){this.dispose()}}class fe extends Error{constructor(e="Input has been disposed."){super(e),this.name="InputDisposedError"}}class ec{constructor(e){this.source=e}requestSlice(e,t){if(this.source._disposed)throw new fe;if(this.fileSize!==null&&e+t>this.fileSize)return null;const i=e+t,s=this.source._read(e,i);return s instanceof Promise?s.then(n=>n?new st(n.bytes,n.view,n.offset,e,i):null):s?new st(s.bytes,s.view,s.offset,e,i):null}requestSliceRange(e,t,i){if(this.source._disposed)throw new fe;if(this.fileSize!==null)return this.requestSlice(e,J(this.fileSize-e,t,i));{const s=this.requestSlice(e,i),n=a=>{if(a)return a;const o=l=>(m(l!==null),this.requestSlice(e,J(l-e,t,i))),c=this.source._retrieveSize();return c instanceof Promise?c.then(o):o(c)};return s instanceof Promise?s.then(n):n(s)}}}class st{constructor(e,t,i,s,n){this.bytes=e,this.view=t,this.offset=i,this.start=s,this.end=n,this.bufferPos=s-i}static tempFromBytes(e){return new st(e,L(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}get remainingLength(){return Math.max(this.end-this.filePos,0)}skip(e){this.bufferPos+=e}slice(e,t=this.end-e){if(e<this.start||e+t>this.end)throw new RangeError("Slicing outside of original slice.");return new st(this.bytes,this.view,this.offset,e,e+t)}}const le=(r,e)=>{if(r.filePos<r.start||r.filePos+e>r.end)throw new RangeError(`Tried reading [${r.filePos}, ${r.filePos+e}), but slice is [${r.start}, ${r.end}). This is likely an internal error, please report it alongside the file that caused it.`)},D=(r,e)=>{le(r,e);const t=r.bytes.subarray(r.bufferPos,r.bufferPos+e);return r.bufferPos+=e,t},B=r=>(le(r,1),r.view.getUint8(r.bufferPos++)),Ot=(r,e)=>{le(r,2);const t=r.view.getUint16(r.bufferPos,e);return r.bufferPos+=2,t},re=r=>{le(r,2);const e=r.view.getUint16(r.bufferPos,!1);return r.bufferPos+=2,e},bt=r=>{le(r,3);const e=Pr(r.view,r.bufferPos,!1);return r.bufferPos+=3,e},pi=r=>{le(r,2);const e=r.view.getInt16(r.bufferPos,!1);return r.bufferPos+=2,e},Xe=(r,e)=>{le(r,4);const t=r.view.getUint32(r.bufferPos,e);return r.bufferPos+=4,t},I=r=>{le(r,4);const e=r.view.getUint32(r.bufferPos,!1);return r.bufferPos+=4,e},yt=r=>{le(r,4);const e=r.view.getUint32(r.bufferPos,!0);return r.bufferPos+=4,e},rt=r=>{le(r,4);const e=r.view.getInt32(r.bufferPos,!1);return r.bufferPos+=4,e},tc=r=>{le(r,4);const e=r.view.getInt32(r.bufferPos,!0);return r.bufferPos+=4,e},fs=(r,e)=>{let t,i;return e?(t=Xe(r,!0),i=Xe(r,!0)):(i=Xe(r,!1),t=Xe(r,!1)),i*4294967296+t},xe=r=>{const e=I(r),t=I(r);return e*4294967296+t},rc=r=>{const e=rt(r),t=I(r);return e*4294967296+t},ic=r=>{const e=yt(r);return tc(r)*4294967296+e},sc=r=>{le(r,4);const e=r.view.getFloat32(r.bufferPos,!1);return r.bufferPos+=4,e},An=r=>{le(r,8);const e=r.view.getFloat64(r.bufferPos,!1);return r.bufferPos+=8,e},te=(r,e)=>{le(r,e);let t="";for(let i=0;i<e;i++)t+=String.fromCharCode(r.bytes[r.bufferPos++]);return t},ms=new Uint8Array([102,76,97,67]),nc=38,ac=34;class oc extends ot{constructor(e,t){super(e),this.metadataWritten=!1,this.blockSizes=[],this.frameSizes=[],this.sampleRate=null,this.channels=null,this.bitsPerSample=null,this.writer=e._writer,this.format=t}async start(){this.writer.write(ms)}writeHeader({bitsPerSample:e,minimumBlockSize:t,maximumBlockSize:i,minimumFrameSize:s,maximumFrameSize:n,sampleRate:a,channels:o,totalSamples:c}){m(this.writer.getPos()===4);const l=!fr(this.output._metadataTags),u=new W(new Uint8Array(4));u.writeBits(1,+!l),u.writeBits(7,Ne.STREAMINFO),u.writeBits(24,ac),this.writer.write(u.bytes);const d=new W(new Uint8Array(18));if(d.writeBits(16,t),d.writeBits(16,i),d.writeBits(24,s),d.writeBits(24,n),d.writeBits(20,a),d.writeBits(3,o-1),d.writeBits(5,e-1),c>=2**32)throw new Error("This muxer only supports writing up to 2 ** 32 samples");d.writeBits(4,0),d.writeBits(32,c),this.writer.write(d.bytes),this.writer.write(new Uint8Array(16))}writePictureBlock(e){const t=32+e.mimeType.length+(e.description?.length??0)+e.data.length,i=new Uint8Array(t);let s=0;const n=L(i);n.setUint32(s,e.kind==="coverFront"?3:e.kind==="coverBack"?4:0),s+=4,n.setUint32(s,e.mimeType.length),s+=4,i.set(j.encode(e.mimeType),8),s+=e.mimeType.length,n.setUint32(s,e.description?.length??0),s+=4,i.set(j.encode(e.description??""),s),s+=e.description?.length??0,s+=16,n.setUint32(s,e.data.length),s+=4,i.set(e.data,s),s+=e.data.length,m(s===t);const a=new W(new Uint8Array(4));a.writeBits(1,0),a.writeBits(7,Ne.PICTURE),a.writeBits(24,t),this.writer.write(a.bytes),this.writer.write(i)}writeVorbisCommentAndPictureBlock(){if(this.writer.seek(nc+ms.byteLength),fr(this.output._metadataTags)){this.metadataWritten=!0;return}const e=this.output._metadataTags.images??[];for(const s of e)this.writePictureBlock(s);const t=ti(new Uint8Array(0),this.output._metadataTags,!1),i=new W(new Uint8Array(4));i.writeBits(1,1),i.writeBits(7,Ne.VORBIS_COMMENT),i.writeBits(24,t.length),this.writer.write(i.bytes),this.writer.write(t),this.metadataWritten=!0}async getMimeType(){return"audio/flac"}async addEncodedVideoPacket(){throw new Error("FLAC does not support video.")}async addEncodedAudioPacket(e,t,i){const s=await this.mutex.acquire();Rt(i),m(i),m(i.decoderConfig),m(i.decoderConfig.description);try{if(this.validateAndNormalizeTimestamp(e,t.timestamp,t.type==="key"),this.sampleRate===null&&(this.sampleRate=i.decoderConfig.sampleRate),this.channels===null&&(this.channels=i.decoderConfig.numberOfChannels),this.bitsPerSample===null){const d=new W(K(i.decoderConfig.description));d.skipBits(167);const h=d.readBits(5)+1;this.bitsPerSample=h}this.metadataWritten||this.writeVorbisCommentAndPictureBlock();const n=st.tempFromBytes(t.data);D(n,2);const a=D(n,2),o=new W(a),c=Cn(o.readBits(4));if(c===null)throw new Error("Invalid FLAC frame: Invalid block size.");_n(n);const l=Pn(n,c);this.blockSizes.push(l),this.frameSizes.push(t.data.length);const u=this.writer.getPos();this.writer.write(t.data),this.format._options.onFrame&&this.format._options.onFrame(t.data,u),await this.writer.flush()}finally{s()}}addSubtitleCue(){throw new Error("FLAC does not support subtitles.")}async finalize(){const e=await this.mutex.acquire();let t=1/0,i=0,s=1/0,n=0,a=0;for(let o=0;o<this.blockSizes.length;o++)s=Math.min(s,this.frameSizes[o]),n=Math.max(n,this.frameSizes[o]),i=Math.max(i,this.blockSizes[o]),a+=this.blockSizes[o],o!==this.blockSizes.length-1&&(t=Math.min(t,this.blockSizes[o]));m(this.sampleRate!==null),m(this.channels!==null),m(this.bitsPerSample!==null),this.writer.seek(4),this.writeHeader({minimumBlockSize:t,maximumBlockSize:i,minimumFrameSize:s,maximumFrameSize:n,sampleRate:this.sampleRate,channels:this.channels,bitsPerSample:this.bitsPerSample,totalSamples:a}),e()}}const Vt=/(?:(.+?)\n)?((?:\d{2}:)?\d{2}:\d{2}.\d{3})\s+-->\s+((?:\d{2}:)?\d{2}:\d{2}.\d{3})/g,cc=/^WEBVTT(.|\n)*?\n{2}/,Sr=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g;class lc{constructor(e){this.preambleText=null,this.preambleEmitted=!1,this.options=e}parse(e){e=e.replaceAll(`\r
`,`
`).replaceAll("\r",`
`),Vt.lastIndex=0;let t;if(!this.preambleText){if(!cc.test(e))throw new Error("WebVTT preamble incorrect.");t=Vt.exec(e);const i=e.slice(0,t?.index??e.length).trimEnd();if(!i)throw new Error("No WebVTT preamble provided.");this.preambleText=i,t&&(e=e.slice(t.index),Vt.lastIndex=0)}for(;t=Vt.exec(e);){const i=e.slice(0,t.index),s=t[1],n=t.index+t[0].length,a=e.indexOf(`
`,n)+1,o=e.slice(n,a).trim();let c=e.indexOf(`

`,n);c===-1&&(c=e.length);const l=gi(t[2]),d=gi(t[3])-l,h=e.slice(a,c).trim();e=e.slice(c).trimStart(),Vt.lastIndex=0;const f={timestamp:l/1e3,duration:d/1e3,text:h,identifier:s,settings:o,notes:i},p={};this.preambleEmitted||(p.config={description:this.preambleText},this.preambleEmitted=!0),this.options.output(f,p)}}}const uc=/(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})/,gi=r=>{const e=uc.exec(r);if(!e)throw new Error("Expected match.");return 3600*1e3*Number(e[1]||"0")+60*1e3*Number(e[2])+1e3*Number(e[3])+Number(e[4])},Fn=r=>{const e=Math.floor(r/36e5),t=Math.floor(r%(3600*1e3)/(60*1e3)),i=Math.floor(r%(60*1e3)/1e3),s=r%1e3;return e.toString().padStart(2,"0")+":"+t.toString().padStart(2,"0")+":"+i.toString().padStart(2,"0")+"."+s.toString().padStart(3,"0")};class ps{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let t=0;t<e.length;t++)this.helperView.setUint8(t%8,e.charCodeAt(t)),t%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const t=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const n of e.children)n&&this.writeBox(n);const i=this.writer.getPos(),s=e.size??i-t;this.writer.seek(t),this.writeBoxHeader(e,s),this.writer.seek(i)}}writeBoxHeader(e,t){this.writeU32(e.largeSize?1:t),this.writeAscii(e.type),e.largeSize&&this.writeU64(t)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const t=this.offsets.get(e);m(t!==void 0);const i=this.writer.getPos();this.writer.seek(t),this.writeBox(e),this.writer.seek(i)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let t=this.measureBoxHeader(e);if(e.contents&&(t+=e.contents.byteLength),e.children)for(const i of e.children)i&&(t+=this.measureBox(i));return t}}}const O=new Uint8Array(8),Ee=new DataView(O.buffer),Q=r=>[(r%256+256)%256],z=r=>(Ee.setUint16(0,r,!1),[O[0],O[1]]),Bn=r=>(Ee.setInt16(0,r,!1),[O[0],O[1]]),zn=r=>(Ee.setUint32(0,r,!1),[O[1],O[2],O[3]]),_=r=>(Ee.setUint32(0,r,!1),[O[0],O[1],O[2],O[3]]),Qe=r=>(Ee.setInt32(0,r,!1),[O[0],O[1],O[2],O[3]]),nt=r=>(Ee.setUint32(0,Math.floor(r/2**32),!1),Ee.setUint32(4,r,!1),[O[0],O[1],O[2],O[3],O[4],O[5],O[6],O[7]]),Rn=r=>(Ee.setInt16(0,2**8*r,!1),[O[0],O[1]]),Re=r=>(Ee.setInt32(0,2**16*r,!1),[O[0],O[1],O[2],O[3]]),Wr=r=>(Ee.setInt32(0,2**30*r,!1),[O[0],O[1],O[2],O[3]]),Lr=(r,e)=>{const t=[];let i=r;do{let s=i&127;i>>=7,t.length>0&&(s|=128),t.push(s)}while(i>0||e);return t.reverse()},ie=(r,e=!1)=>{const t=Array(r.length).fill(null).map((i,s)=>r.charCodeAt(s));return e&&t.push(0),t},Ri=r=>{let e=null;for(const t of r)(!e||t.timestamp>e.timestamp)&&(e=t);return e},Mn=r=>{const e=r*(Math.PI/180),t=Math.round(Math.cos(e)),i=Math.round(Math.sin(e));return[t,i,0,-i,t,0,0,0,1]},Dn=Mn(0),Un=r=>[Re(r[0]),Re(r[1]),Wr(r[2]),Re(r[3]),Re(r[4]),Wr(r[5]),Re(r[6]),Re(r[7]),Wr(r[8])],M=(r,e,t)=>({type:r,contents:e&&new Uint8Array(e.flat(10)),children:t}),V=(r,e,t,i,s)=>M(r,[Q(e),zn(t),i??[]],s),dc=r=>r.isQuickTime?M("ftyp",[ie("qt  "),_(512),ie("qt  ")]):r.fragmented?M("ftyp",[ie("iso5"),_(512),ie("iso5"),ie("iso6"),ie("mp41")]):M("ftyp",[ie("isom"),_(512),ie("isom"),r.holdsAvc?ie("avc1"):[],ie("mp41")]),ar=r=>({type:"mdat",largeSize:r}),hc=r=>({type:"free",size:r}),Wt=r=>M("moov",void 0,[fc(r.creationTime,r.trackDatas),...r.trackDatas.map(e=>mc(e,r.creationTime)),r.isFragmented?Gc(r.trackDatas):null,cl(r)]),fc=(r,e)=>{const t=Y(Math.max(0,...e.filter(a=>a.samples.length>0).map(a=>{const o=Ri(a.samples);return o.timestamp+o.duration})),wi),i=Math.max(0,...e.map(a=>a.track.id))+1,s=!_t(r)||!_t(t),n=s?nt:_;return V("mvhd",+s,0,[n(r),n(r),_(wi),n(t),Re(1),Rn(1),Array(10).fill(0),Un(Dn),Array(24).fill(0),_(i)])},mc=(r,e)=>{const t=Pl(r);return M("trak",void 0,[pc(r,e),gc(r,e),t.name!==void 0?M("udta",void 0,[M("name",[...j.encode(t.name)])]):null])},pc=(r,e)=>{const t=Ri(r.samples),i=Y(t?t.timestamp+t.duration:0,wi),s=!_t(e)||!_t(i),n=s?nt:_;let a;if(r.type==="video"){const c=r.track.metadata.rotation;a=Mn(c??0)}else a=Dn;let o=2;return r.track.metadata.disposition?.default!==!1&&(o|=1),V("tkhd",+s,o,[n(e),n(e),_(r.track.id),_(0),n(i),Array(8).fill(0),z(0),z(r.track.id),Rn(r.type==="audio"?1:0),z(0),Un(a),Re(r.type==="video"?r.info.width:0),Re(r.type==="video"?r.info.height:0)])},gc=(r,e)=>M("mdia",void 0,[wc(r,e),Mi(!0,bc[r.type],kc[r.type]),Tc(r)]),wc=(r,e)=>{const t=Ri(r.samples),i=Y(t?t.timestamp+t.duration:0,r.timescale),s=!_t(e)||!_t(i),n=s?nt:_;return V("mdhd",+s,0,[n(e),n(e),_(r.timescale),n(i),z(Wn(r.track.metadata.languageCode??me)),z(0)])},bc={video:"vide",audio:"soun",subtitle:"text"},kc={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},Mi=(r,e,t,i="\0\0\0\0")=>V("hdlr",0,0,[r?ie("mhlr"):_(0),ie(e),ie(i),_(0),_(0),ie(t,!0)]),Tc=r=>M("minf",void 0,[Cc[r.type](),_c(),Ic(r)]),yc=()=>V("vmhd",0,1,[z(0),z(0),z(0),z(0)]),Sc=()=>V("smhd",0,0,[z(0),z(0)]),xc=()=>V("nmhd",0,0),Cc={video:yc,audio:Sc,subtitle:xc},_c=()=>M("dinf",void 0,[Pc()]),Pc=()=>V("dref",0,0,[_(1)],[vc()]),vc=()=>V("url ",0,1),Ic=r=>{const e=r.compositionTimeOffsetTable.length>1||r.compositionTimeOffsetTable.some(t=>t.sampleCompositionTimeOffset!==0);return M("stbl",void 0,[Ec(r),Lc(r),e?Qc(r):null,e?Kc(r):null,qc(r),jc(r),$c(r),Hc(r)])},Ec=r=>{let e;if(r.type==="video")e=Ac(hl(r.track.source._codec,r.info.decoderConfig.codec),r);else if(r.type==="audio"){const t=Vn(r.track.source._codec,r.muxer.isQuickTime);m(t),e=Mc(t,r)}else r.type==="subtitle"&&(e=Vc(pl[r.track.source._codec],r));return m(e),V("stsd",0,0,[_(1)],[e])},Ac=(r,e)=>M(r,[Array(6).fill(0),z(1),z(0),z(0),Array(12).fill(0),z(e.info.width),z(e.info.height),_(4718592),_(4718592),_(0),z(1),Array(32).fill(0),z(24),Bn(65535)],[fl[e.track.source._codec](e),Rs(e.info.decoderConfig.colorSpace)?Fc(e):null]),Fc=r=>M("colr",[ie("nclx"),z(vt[r.info.decoderConfig.colorSpace.primaries]),z(It[r.info.decoderConfig.colorSpace.transfer]),z(Et[r.info.decoderConfig.colorSpace.matrix]),Q((r.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),Bc=r=>r.info.decoderConfig&&M("avcC",[...K(r.info.decoderConfig.description)]),zc=r=>r.info.decoderConfig&&M("hvcC",[...K(r.info.decoderConfig.description)]),gs=r=>{if(!r.info.decoderConfig)return null;const e=r.info.decoderConfig,t=e.codec.split("."),i=Number(t[1]),s=Number(t[2]),n=Number(t[3]),a=t[4]?Number(t[4]):1,o=t[8]?Number(t[8]):Number(e.colorSpace?.fullRange??0),c=(n<<4)+(a<<1)+o,l=t[5]?Number(t[5]):e.colorSpace?.primaries?vt[e.colorSpace.primaries]:2,u=t[6]?Number(t[6]):e.colorSpace?.transfer?It[e.colorSpace.transfer]:2,d=t[7]?Number(t[7]):e.colorSpace?.matrix?Et[e.colorSpace.matrix]:2;return V("vpcC",1,0,[Q(i),Q(s),Q(c),Q(l),Q(u),Q(d),z(0)])},Rc=r=>M("av1C",Vs(r.info.decoderConfig.codec)),Mc=(r,e)=>{let t=0,i,s=16;if(Z.includes(e.track.source._codec)){const n=e.track.source._codec,{sampleSize:a}=Ae(n);s=8*a,s>16&&(t=1)}return t===0?i=[Array(6).fill(0),z(1),z(t),z(0),_(0),z(e.info.numberOfChannels),z(s),z(0),z(0),z(e.info.sampleRate<2**16?e.info.sampleRate:0),z(0)]:i=[Array(6).fill(0),z(1),z(t),z(0),_(0),z(e.info.numberOfChannels),z(Math.min(s,16)),z(0),z(0),z(e.info.sampleRate<2**16?e.info.sampleRate:0),z(0),_(1),_(s/8),_(e.info.numberOfChannels*s/8),_(2)],M(r,i,[ml(e.track.source._codec,e.muxer.isQuickTime)?.(e)??null])},Hr=r=>{let e;switch(r.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${r.track.source._codec}`)}let t=[...Q(e),...Q(21),...zn(0),..._(0),..._(0)];if(r.info.decoderConfig.description){const i=K(r.info.decoderConfig.description);t=[...t,...Q(5),...Lr(i.byteLength),...i]}return t=[...z(1),...Q(0),...Q(4),...Lr(t.length),...t,...Q(6),...Q(1),...Q(2)],t=[...Q(3),...Lr(t.length),...t],V("esds",0,0,t)},Le=r=>M("wave",void 0,[Dc(r),Uc(r),M("\0\0\0\0")]),Dc=r=>M("frma",[ie(Vn(r.track.source._codec,r.muxer.isQuickTime))]),Uc=r=>{const{littleEndian:e}=Ae(r.track.source._codec);return M("enda",[z(+e)])},Nc=r=>{let e=r.info.numberOfChannels,t=3840,i=r.info.sampleRate,s=0,n=0,a=new Uint8Array(0);const o=r.info.decoderConfig?.description;if(o){m(o.byteLength>=18);const c=K(o),l=Er(c);e=l.outputChannelCount,t=l.preSkip,i=l.inputSampleRate,s=l.outputGain,n=l.channelMappingFamily,l.channelMappingTable&&(a=l.channelMappingTable)}return M("dOps",[Q(0),Q(e),z(t),_(i),Bn(s),Q(n),...a])},Oc=r=>{const e=r.info.decoderConfig?.description;m(e);const t=K(e);return V("dfLa",0,0,[...t.subarray(4)])},ve=r=>{const{littleEndian:e,sampleSize:t}=Ae(r.track.source._codec),i=+e;return V("pcmC",0,0,[Q(i),Q(8*t)])},Vc=(r,e)=>M(r,[Array(6).fill(0),z(1)],[gl[e.track.source._codec](e)]),Wc=r=>M("vttC",[...j.encode(r.info.config.description)]),Lc=r=>V("stts",0,0,[_(r.timeToSampleTable.length),r.timeToSampleTable.map(e=>[_(e.sampleCount),_(e.sampleDelta)])]),Hc=r=>{if(r.samples.every(t=>t.type==="key"))return null;const e=[...r.samples.entries()].filter(([,t])=>t.type==="key");return V("stss",0,0,[_(e.length),e.map(([t])=>_(t+1))])},qc=r=>V("stsc",0,0,[_(r.compactlyCodedChunkTable.length),r.compactlyCodedChunkTable.map(e=>[_(e.firstChunk),_(e.samplesPerChunk),_(1)])]),jc=r=>{if(r.type==="audio"&&r.info.requiresPcmTransformation){const{sampleSize:e}=Ae(r.track.source._codec);return V("stsz",0,0,[_(e*r.info.numberOfChannels),_(r.samples.reduce((t,i)=>t+Y(i.duration,r.timescale),0))])}return V("stsz",0,0,[_(0),_(r.samples.length),r.samples.map(e=>_(e.size))])},$c=r=>r.finalizedChunks.length>0&&X(r.finalizedChunks).offset>=2**32?V("co64",0,0,[_(r.finalizedChunks.length),r.finalizedChunks.map(e=>nt(e.offset))]):V("stco",0,0,[_(r.finalizedChunks.length),r.finalizedChunks.map(e=>_(e.offset))]),Qc=r=>V("ctts",1,0,[_(r.compositionTimeOffsetTable.length),r.compositionTimeOffsetTable.map(e=>[_(e.sampleCount),Qe(e.sampleCompositionTimeOffset)])]),Kc=r=>{let e=1/0,t=-1/0,i=1/0,s=-1/0;m(r.compositionTimeOffsetTable.length>0),m(r.samples.length>0);for(let a=0;a<r.compositionTimeOffsetTable.length;a++){const o=r.compositionTimeOffsetTable[a];e=Math.min(e,o.sampleCompositionTimeOffset),t=Math.max(t,o.sampleCompositionTimeOffset)}for(let a=0;a<r.samples.length;a++){const o=r.samples[a];i=Math.min(i,Y(o.timestamp,r.timescale)),s=Math.max(s,Y(o.timestamp+o.duration,r.timescale))}const n=Math.max(-e,0);return s>=2**31?null:V("cslg",0,0,[Qe(n),Qe(e),Qe(t),Qe(i),Qe(s)])},Gc=r=>M("mvex",void 0,r.map(Xc)),Xc=r=>V("trex",0,0,[_(r.track.id),_(1),_(0),_(0),_(0)]),ws=(r,e)=>M("moof",void 0,[Yc(r),...e.map(Zc)]),Yc=r=>V("mfhd",0,0,[_(r)]),Nn=r=>{let e=0,t=0;const i=0,s=0,n=r.type==="delta";return t|=+n,n?e|=1:e|=2,e<<24|t<<16|i<<8|s},Zc=r=>M("traf",void 0,[Jc(r),el(r),tl(r)]),Jc=r=>{m(r.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const t=r.currentChunk.samples[1]??r.currentChunk.samples[0],i={duration:t.timescaleUnitsToNextSample,size:t.size,flags:Nn(t)};return V("tfhd",0,e,[_(r.track.id),_(i.duration),_(i.size),_(i.flags)])},el=r=>(m(r.currentChunk),V("tfdt",1,0,[nt(Y(r.currentChunk.startTimestamp,r.timescale))])),tl=r=>{m(r.currentChunk);const e=r.currentChunk.samples.map(g=>g.timescaleUnitsToNextSample),t=r.currentChunk.samples.map(g=>g.size),i=r.currentChunk.samples.map(Nn),s=r.currentChunk.samples.map(g=>Y(g.timestamp-g.decodeTimestamp,r.timescale)),n=new Set(e),a=new Set(t),o=new Set(i),c=new Set(s),l=o.size===2&&i[0]!==i[1],u=n.size>1,d=a.size>1,h=!l&&o.size>1,f=c.size>1||[...c].some(g=>g!==0);let p=0;return p|=1,p|=4*+l,p|=256*+u,p|=512*+d,p|=1024*+h,p|=2048*+f,V("trun",1,p,[_(r.currentChunk.samples.length),_(r.currentChunk.offset-r.currentChunk.moofOffset||0),l?_(i[0]):[],r.currentChunk.samples.map((g,w)=>[u?_(e[w]):[],d?_(t[w]):[],h?_(i[w]):[],f?Qe(s[w]):[]])])},rl=r=>M("mfra",void 0,[...r.map(il),sl()]),il=(r,e)=>V("tfra",1,0,[_(r.track.id),_(63),_(r.finalizedChunks.length),r.finalizedChunks.map(i=>[nt(Y(i.samples[0].timestamp,r.timescale)),nt(i.moofOffset),_(e+1),_(1),_(1)])]),sl=()=>V("mfro",0,0,[_(0)]),nl=()=>M("vtte"),al=(r,e,t,i,s)=>M("vttc",void 0,[s!==null?M("vsid",[Qe(s)]):null,t!==null?M("iden",[...j.encode(t)]):null,e!==null?M("ctim",[...j.encode(Fn(e))]):null,i!==null?M("sttg",[...j.encode(i)]):null,M("payl",[...j.encode(r)])]),ol=r=>M("vtta",[...j.encode(r)]),cl=r=>{const e=[],t=r.format._options.metadataFormat??"auto",i=r.output._metadataTags;if(t==="mdir"||t==="auto"&&!r.isQuickTime){const s=ul(i);s&&e.push(s)}else if(t==="mdta"){const s=dl(i);s&&e.push(s)}else(t==="udta"||t==="auto"&&r.isQuickTime)&&ll(e,r.output._metadataTags);return e.length===0?null:M("udta",void 0,e)},ll=(r,e)=>{for(const{key:t,value:i}of Ft(e))switch(t){case"title":r.push(Ie("nam",i));break;case"description":r.push(Ie("des",i));break;case"artist":r.push(Ie("ART",i));break;case"album":r.push(Ie("alb",i));break;case"albumArtist":r.push(Ie("albr",i));break;case"genre":r.push(Ie("gen",i));break;case"date":r.push(Ie("day",i.toISOString().slice(0,10)));break;case"comment":r.push(Ie("cmt",i));break;case"lyrics":r.push(Ie("lyr",i));break;case"raw":break;case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:ae(t)}if(e.raw)for(const t in e.raw){const i=e.raw[t];i==null||t.length!==4||r.some(s=>s.type===t)||(typeof i=="string"?r.push(Ie(t,i)):i instanceof Uint8Array&&r.push(M(t,Array.from(i))))}},Ie=(r,e)=>{const t=j.encode(e);return M(r,[z(t.length),z(Wn("und")),Array.from(t)])},bs={"image/jpeg":13,"image/png":14,"image/bmp":27},On=(r,e)=>{const t=[];for(const{key:i,value:s}of Ft(r))switch(i){case"title":t.push({key:e?"title":"nam",value:ye(s)});break;case"description":t.push({key:e?"description":"des",value:ye(s)});break;case"artist":t.push({key:e?"artist":"ART",value:ye(s)});break;case"album":t.push({key:e?"album":"alb",value:ye(s)});break;case"albumArtist":t.push({key:e?"album_artist":"aART",value:ye(s)});break;case"comment":t.push({key:e?"comment":"cmt",value:ye(s)});break;case"genre":t.push({key:e?"genre":"gen",value:ye(s)});break;case"lyrics":t.push({key:e?"lyrics":"lyr",value:ye(s)});break;case"date":t.push({key:e?"date":"day",value:ye(s.toISOString().slice(0,10))});break;case"images":for(const n of s)n.kind==="coverFront"&&t.push({key:"covr",value:M("data",[_(bs[n.mimeType]??0),_(0),Array.from(n.data)])});break;case"trackNumber":if(e){const n=r.tracksTotal!==void 0?`${s}/${r.tracksTotal}`:s.toString();t.push({key:"track",value:ye(n)})}else t.push({key:"trkn",value:M("data",[_(0),_(0),z(0),z(s),z(r.tracksTotal??0),z(0)])});break;case"discNumber":e||t.push({key:"disc",value:M("data",[_(0),_(0),z(0),z(s),z(r.discsTotal??0),z(0)])});break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:ae(i)}if(r.raw)for(const i in r.raw){const s=r.raw[i];s==null||!e&&i.length!==4||t.some(n=>n.key===i)||(typeof s=="string"?t.push({key:i,value:ye(s)}):s instanceof Uint8Array?t.push({key:i,value:M("data",[_(0),_(0),Array.from(s)])}):s instanceof St&&t.push({key:i,value:M("data",[_(bs[s.mimeType]??0),_(0),Array.from(s.data)])}))}return t},ul=r=>{const e=On(r,!1);return e.length===0?null:V("meta",0,0,void 0,[Mi(!1,"mdir","","appl"),M("ilst",void 0,e.map(t=>M(t.key,void 0,[t.value])))])},dl=r=>{const e=On(r,!0);return e.length===0?null:M("meta",void 0,[Mi(!1,"mdta",""),V("keys",0,0,[_(e.length)],e.map(t=>M("mdta",[...j.encode(t.key)]))),M("ilst",void 0,e.map((t,i)=>{const s=String.fromCharCode(..._(i+1));return M(s,void 0,[t.value])}))])},ye=r=>M("data",[_(1),_(0),...j.encode(r)]),hl=(r,e)=>{switch(r){case"avc":return e.startsWith("avc3")?"avc3":"avc1";case"hevc":return"hvc1";case"vp8":return"vp08";case"vp9":return"vp09";case"av1":return"av01"}},fl={avc:Bc,hevc:zc,vp8:gs,vp9:gs,av1:Rc},Vn=(r,e)=>{switch(r){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(r){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(r){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},ml=(r,e)=>{switch(r){case"aac":return Hr;case"mp3":return Hr;case"opus":return Nc;case"vorbis":return Hr;case"flac":return Oc}if(e)switch(r){case"pcm-s24":return Le;case"pcm-s24be":return Le;case"pcm-s32":return Le;case"pcm-s32be":return Le;case"pcm-f32":return Le;case"pcm-f32be":return Le;case"pcm-f64":return Le;case"pcm-f64be":return Le}else switch(r){case"pcm-s16":return ve;case"pcm-s16be":return ve;case"pcm-s24":return ve;case"pcm-s24be":return ve;case"pcm-s32":return ve;case"pcm-s32be":return ve;case"pcm-f32":return ve;case"pcm-f32be":return ve;case"pcm-f64":return ve;case"pcm-f64be":return ve}return null},pl={webvtt:"wvtt"},gl={webvtt:Wc},Wn=r=>{m(r.length===3);let e=0;for(let t=0;t<3;t++)e<<=5,e+=r.charCodeAt(t)-96;return e};class Di{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let t=this.getPos();if(t<this.trackedStart){if(t+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-t),t=0}const i=t+e.byteLength-this.trackedStart;let s=this.trackedWrites.byteLength;for(;s<i;)s*=2;if(s!==this.trackedWrites.byteLength){const n=new Uint8Array(s);n.set(this.trackedWrites,0),this.trackedWrites=n}this.trackedWrites.set(e,t-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,t+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const t={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,t}}const qr=2**16,jr=2**32;class Ln extends Di{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(qr,{maxByteLength:jr})}catch{this.buffer=new ArrayBuffer(qr),this.supportsResize=!1}else this.buffer=new ArrayBuffer(qr);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let t=this.buffer.byteLength;for(;t<e;)t*=2;if(t!==this.buffer.byteLength){if(t>jr)throw new Error(`ArrayBuffer exceeded maximum size of ${jr} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(t);else{const i=new ArrayBuffer(t),s=new Uint8Array(i);s.set(this.bytes,0),this.buffer=i,this.bytes=s}}}write(e){this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,t){return this.bytes.slice(e,t)}}const wl=2**24,bl=2;class kl extends Di{constructor(e){super(),this.pos=0,this.sections=[],this.lastWriteEnd=0,this.lastFlushEnd=0,this.writer=null,this.chunks=[],this.target=e,this.chunked=e._options.chunked??!1,this.chunkSize=e._options.chunkSize??wl}start(){this.writer=this.target._writable.getWriter()}write(e){if(this.pos>this.lastWriteEnd){const t=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(t))}this.maybeTrackWrites(e),this.sections.push({data:e.slice(),start:this.pos}),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.lastWriteEnd=Math.max(this.lastWriteEnd,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){if(this.pos>this.lastWriteEnd){const i=this.pos-this.lastWriteEnd;this.pos=this.lastWriteEnd,this.write(new Uint8Array(i))}if(m(this.writer),this.sections.length===0)return;const e=[],t=[...this.sections].sort((i,s)=>i.start-s.start);e.push({start:t[0].start,size:t[0].data.byteLength});for(let i=1;i<t.length;i++){const s=e[e.length-1],n=t[i];n.start<=s.start+s.size?s.size=Math.max(s.size,n.start+n.data.byteLength-s.start):e.push({start:n.start,size:n.data.byteLength})}for(const i of e){i.data=new Uint8Array(i.size);for(const s of this.sections)i.start<=s.start&&s.start<i.start+i.size&&i.data.set(s.data,s.start-i.start);if(this.writer.desiredSize!==null&&this.writer.desiredSize<=0&&await this.writer.ready,this.chunked)this.writeDataIntoChunks(i.data,i.start),this.tryToFlushChunks();else{if(this.ensureMonotonicity&&i.start!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:i.data,position:i.start}),this.lastFlushEnd=i.start+i.data.byteLength}}this.sections.length=0}writeDataIntoChunks(e,t){let i=this.chunks.findIndex(c=>c.start<=t&&t<c.start+this.chunkSize);i===-1&&(i=this.createChunk(t));const s=this.chunks[i],n=t-s.start,a=e.subarray(0,Math.min(this.chunkSize-n,e.byteLength));s.data.set(a,n);const o={start:n,end:n+a.byteLength};if(this.insertSectionIntoChunk(s,o),s.written[0].start===0&&s.written[0].end===this.chunkSize&&(s.shouldFlush=!0),this.chunks.length>bl){for(let c=0;c<this.chunks.length-1;c++)this.chunks[c].shouldFlush=!0;this.tryToFlushChunks()}a.byteLength<e.byteLength&&this.writeDataIntoChunks(e.subarray(a.byteLength),t+a.byteLength)}insertSectionIntoChunk(e,t){let i=0,s=e.written.length-1,n=-1;for(;i<=s;){const a=Math.floor(i+(s-i+1)/2);e.written[a].start<=t.start?(i=a+1,n=a):s=a-1}for(e.written.splice(n+1,0,t),(n===-1||e.written[n].end<t.start)&&n++;n<e.written.length-1&&e.written[n].end>=e.written[n+1].start;)e.written[n].end=Math.max(e.written[n].end,e.written[n+1].end),e.written.splice(n+1,1)}createChunk(e){const i={start:Math.floor(e/this.chunkSize)*this.chunkSize,data:new Uint8Array(this.chunkSize),written:[],shouldFlush:!1};return this.chunks.push(i),this.chunks.sort((s,n)=>s.start-n.start),this.chunks.indexOf(i)}tryToFlushChunks(e=!1){m(this.writer);for(let t=0;t<this.chunks.length;t++){const i=this.chunks[t];if(!(!i.shouldFlush&&!e)){for(const s of i.written){const n=i.start+s.start;if(this.ensureMonotonicity&&n!==this.lastFlushEnd)throw new Error("Internal error: Monotonicity violation.");this.writer.write({type:"write",data:i.data.subarray(s.start,s.end),position:n}),this.lastFlushEnd=i.start+s.end}this.chunks.splice(t--,1)}}}finalize(){return this.chunked&&this.tryToFlushChunks(!0),m(this.writer),this.writer.close()}async close(){return this.writer?.close()}}class Tl extends Di{constructor(e){super(),this.target=e,this.pos=0}write(e){this.maybeTrackWrites(e),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength}getPos(){return this.pos}seek(e){this.pos=e}async flush(){}async finalize(){}async close(){}}const yl=typeof ur<"u"?ur:void 0;class tr{constructor(){this._output=null,this.onwrite=null}}class Sl extends tr{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new Ln(this)}}class xl extends tr{constructor(e,t={}){if(super(),!(e instanceof WritableStream))throw new TypeError("StreamTarget requires a WritableStream instance.");if(t!=null&&typeof t!="object")throw new TypeError("StreamTarget options, when provided, must be an object.");if(t.chunked!==void 0&&typeof t.chunked!="boolean")throw new TypeError("options.chunked, when provided, must be a boolean.");if(t.chunkSize!==void 0&&(!Number.isInteger(t.chunkSize)||t.chunkSize<1024))throw new TypeError("options.chunkSize, when provided, must be an integer and not smaller than 1024.");this._writable=e,this._options=t}_createWriter(){return new kl(this)}}class ou extends tr{constructor(e,t={}){if(typeof e!="string")throw new TypeError("filePath must be a string.");if(!t||typeof t!="object")throw new TypeError("options must be an object.");super(),this._fileHandle=null;const i=new WritableStream({start:async()=>{this._fileHandle=await yl.fs.open(e,"w")},write:async s=>{m(this._fileHandle),await this._fileHandle.write(s.data,0,s.data.byteLength,s.position)},close:async()=>{this._fileHandle&&(await this._fileHandle.close(),this._fileHandle=null)}});this._streamTarget=new xl(i,{chunked:!0,...t}),this._streamTarget._output=this._output}_createWriter(){return this._streamTarget._createWriter()}}class Cl extends tr{_createWriter(){return new Tl(this)}}const wi=1e3,_l=2082844800,Pl=r=>{const e={},t=r.track;return t.metadata.name!==void 0&&(e.name=t.metadata.name),e},Y=(r,e,t=!0)=>{const i=r*e;return t?Math.round(i):i};class vl extends ot{constructor(e,t){super(e),this.auxTarget=new Sl,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new ps(this.auxWriter),this.mdat=null,this.ftypSize=null,this.trackDatas=[],this.allTracksKnown=G(),this.creationTime=Math.floor(Date.now()/1e3)+_l,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=t,this.writer=e._writer,this.boxWriter=new ps(this.writer),this.isQuickTime=t instanceof jn;const i=this.writer instanceof Ln?"in-memory":!1;this.fastStart=t._options.fastStart??i,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=t._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),t=this.output._tracks.some(i=>i.type==="video"&&i.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(dc({isQuickTime:this.isQuickTime,holdsAvc:t,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:i,start:s}=this.writer.stopTrackingWrites();this.format._options.onFtyp(i,s)}if(this.ftypSize=this.writer.getPos(),this.fastStart!=="in-memory")if(this.fastStart==="reserve"){for(const i of this.output._tracks)if(i.metadata.maximumPacketCount===void 0)throw new Error("All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'.")}else this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=ar(!0),this.boxWriter.writeBox(this.mdat));await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(t=>t.type==="video"||t.type==="audio"?t.info.decoderConfig.codec:{webvtt:"wvtt"}[t.track.source._codec]);return nn({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(t=>t.type==="video"),hasAudio:this.trackDatas.some(t=>t.type==="audio"),codecStrings:e})}getVideoTrackData(e,t,i){const s=this.trackDatas.find(l=>l.track===e);if(s)return s;js(i),m(i),m(i.decoderConfig);const n={...i.decoderConfig};m(n.codedWidth!==void 0),m(n.codedHeight!==void 0);let a=!1;if(e.source._codec==="avc"&&!n.description){const l=Ks(t.data);if(!l)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");n.description=Pa(l),a=!0}else if(e.source._codec==="hevc"&&!n.description){const l=Ys(t.data);if(!l)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");n.description=Ra(l),a=!0}const o=sa(1/(e.metadata.frameRate??57600),1e6).denominator,c={muxer:this,track:e,type:"video",info:{width:n.codedWidth,height:n.codedHeight,decoderConfig:n,requiresAnnexBTransformation:a},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(c),this.trackDatas.sort((l,u)=>l.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),c}getAudioTrackData(e,t){const i=this.trackDatas.find(n=>n.track===e);if(i)return i;Rt(t),m(t),m(t.decoderConfig);const s={muxer:this,track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig,requiresPcmTransformation:!this.isFragmented&&Z.includes(e.source._codec)},timescale:t.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(s),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}getSubtitleTrackData(e,t){const i=this.trackDatas.find(n=>n.track===e);if(i)return i;$s(t),m(t),m(t.config);const s={muxer:this,track:e,type:"subtitle",info:{config:t.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(s),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,t,i){const s=await this.mutex.acquire();try{const n=this.getVideoTrackData(e,t,i);let a=t.data;if(n.info.requiresAnnexBTransformation){const l=Ca(a);if(!l)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");a=l}const o=this.validateAndNormalizeTimestamp(n.track,t.timestamp,t.type==="key"),c=this.createSampleForTrack(n,a,o,t.duration,t.type);await this.registerSample(n,c)}finally{s()}}async addEncodedAudioPacket(e,t,i){const s=await this.mutex.acquire();try{const n=this.getAudioTrackData(e,i),a=this.validateAndNormalizeTimestamp(n.track,t.timestamp,t.type==="key"),o=this.createSampleForTrack(n,t.data,a,t.duration,t.type);n.info.requiresPcmTransformation&&await this.maybePadWithSilence(n,a),await this.registerSample(n,o)}finally{s()}}async maybePadWithSilence(e,t){const i=X(e.samples),s=i?i.timestamp+i.duration:0,n=t-s,a=Y(n,e.timescale);if(a>0){const{sampleSize:o,silentValue:c}=Ae(e.info.decoderConfig.codec),l=a*e.info.numberOfChannels,u=new Uint8Array(o*l).fill(c),d=this.createSampleForTrack(e,new Uint8Array(u.buffer),s,n,"key");await this.registerSample(e,d)}}async addSubtitleCue(e,t,i){const s=await this.mutex.acquire();try{const n=this.getSubtitleTrackData(e,i);this.validateAndNormalizeTimestamp(n.track,t.timestamp,!0),e.source._codec==="webvtt"&&(n.cueQueue.push(t),await this.processWebVTTCues(n,t.timestamp))}finally{s()}}async processWebVTTCues(e,t){for(;e.cueQueue.length>0;){const i=new Set([]);for(const l of e.cueQueue)m(l.timestamp<=t),m(e.lastCueEndTimestamp<=l.timestamp+l.duration),i.add(Math.max(l.timestamp,e.lastCueEndTimestamp)),i.add(l.timestamp+l.duration);const s=[...i].sort((l,u)=>l-u),n=s[0],a=s[1]??n;if(t<a)break;if(e.lastCueEndTimestamp<n){this.auxWriter.seek(0);const l=nl();this.auxBoxWriter.writeBox(l);const u=this.auxWriter.getSlice(0,this.auxWriter.getPos()),d=this.createSampleForTrack(e,u,e.lastCueEndTimestamp,n-e.lastCueEndTimestamp,"key");await this.registerSample(e,d),e.lastCueEndTimestamp=n}this.auxWriter.seek(0);for(let l=0;l<e.cueQueue.length;l++){const u=e.cueQueue[l];if(u.timestamp>=a)break;Sr.lastIndex=0;const d=Sr.test(u.text),h=u.timestamp+u.duration;let f=e.cueToSourceId.get(u);if(f===void 0&&a<h&&(f=e.nextSourceId++,e.cueToSourceId.set(u,f)),u.notes){const g=ol(u.notes);this.auxBoxWriter.writeBox(g)}const p=al(u.text,d?n:null,u.identifier??null,u.settings??null,f??null);this.auxBoxWriter.writeBox(p),h===a&&e.cueQueue.splice(l--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),c=this.createSampleForTrack(e,o,n,a-n,"key");await this.registerSample(e,c),e.lastCueEndTimestamp=a}}createSampleForTrack(e,t,i,s,n){return{timestamp:i,decodeTimestamp:i,duration:s,data:t,size:t.byteLength,type:n,timescaleUnitsToNextSample:Y(s,e.timescale)}}processTimestamps(e,t){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let s=0;for(let n=0;n<e.timestampProcessingQueue.length;n++){const a=e.timestampProcessingQueue[n],o=Y(a.duration,e.timescale);s+=o}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:s,sampleDelta:1});else{const n=X(e.timeToSampleTable);n.sampleCount+=s}e.timestampProcessingQueue.length=0;return}const i=e.timestampProcessingQueue.map(s=>s.timestamp).sort((s,n)=>s-n);for(let s=0;s<e.timestampProcessingQueue.length;s++){const n=e.timestampProcessingQueue[s];n.decodeTimestamp=i[s],!this.isFragmented&&e.lastTimescaleUnits===null&&(n.decodeTimestamp=0);const a=Y(n.timestamp-n.decodeTimestamp,e.timescale),o=Y(n.duration,e.timescale);if(e.lastTimescaleUnits!==null){m(e.lastSample);const c=Y(n.decodeTimestamp,e.timescale,!1),l=Math.round(c-e.lastTimescaleUnits);if(m(l>=0),e.lastTimescaleUnits+=l,e.lastSample.timescaleUnitsToNextSample=l,!this.isFragmented){let u=X(e.timeToSampleTable);if(m(u),u.sampleCount===1){u.sampleDelta=l;const h=e.timeToSampleTable[e.timeToSampleTable.length-2];h&&h.sampleDelta===l&&(h.sampleCount++,e.timeToSampleTable.pop(),u=h)}else u.sampleDelta!==l&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:l}));u.sampleDelta===o?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const d=X(e.compositionTimeOffsetTable);m(d),d.sampleCompositionTimeOffset===a?d.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=Y(n.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=n}if(e.timestampProcessingQueue.length=0,m(e.lastSample),m(e.lastTimescaleUnits!==null),t!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){m(t.type==="key");const s=Y(t.timestamp,e.timescale,!1),n=Math.round(s-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=n}}async registerSample(e,t){t.type==="key"&&this.processTimestamps(e,t),e.timestampProcessingQueue.push(t),this.isFragmented?(e.sampleQueue.push(t),await this.interleaveSamples()):this.fastStart==="reserve"?await this.registerSampleFastStartReserve(e,t):await this.addSampleToTrack(e,t)}async addSampleToTrack(e,t){if(!this.isFragmented&&(e.samples.push(t),this.fastStart==="reserve")){const s=e.track.metadata.maximumPacketCount;if(m(s!==void 0),e.samples.length>s)throw new Error(`Track #${e.track.id} has already reached the maximum packet count (${s}). Either add less packets or increase the maximum packet count.`)}let i=!1;if(!e.currentChunk)i=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,t.timestamp);const s=t.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const n=this.trackDatas.every(a=>{if(e===a)return t.type==="key";const o=a.sampleQueue[0];return o?o.type==="key":a.track.source._closed});s>=this.minimumFragmentDuration&&n&&t.timestamp>this.maxWrittenTimestamp&&(i=!0,await this.finalizeFragment())}else i=s>=.5}i&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:t.timestamp,samples:[],offset:null,moofOffset:null}),m(e.currentChunk),e.currentChunk.samples.push(t),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,t.timestamp))}async finalizeCurrentChunk(e){if(m(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let t=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(t=e.currentChunk.samples.reduce((i,s)=>i+Y(s.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||X(e.compactlyCodedChunkTable).samplesPerChunk!==t)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:t}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const i of e.currentChunk.samples)m(i.data),this.writer.write(i.data),i.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(m(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let t=null,i=1/0;for(const n of this.trackDatas){if(!e&&n.sampleQueue.length===0&&!n.track.source._closed)break e;n.sampleQueue.length>0&&n.sampleQueue[0].timestamp<i&&(t=n,i=n.sampleQueue[0].timestamp)}if(!t)break;const s=t.sampleQueue.shift();await this.addSampleToTrack(t,s)}}async finalizeFragment(e=!0){m(this.isFragmented);const t=this.nextFragmentNumber++;if(t===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const f=Wt(this);if(this.boxWriter.writeBox(f),this.format._options.onMoov){const{data:p,start:g}=this.writer.stopTrackingWrites();this.format._options.onMoov(p,g)}}const i=this.trackDatas.filter(f=>f.currentChunk),s=ws(t,i),n=this.writer.getPos(),a=n+this.boxWriter.measureBox(s);let o=a+Me,c=1/0;for(const f of i){f.currentChunk.offset=o,f.currentChunk.moofOffset=n;for(const p of f.currentChunk.samples)o+=p.size;c=Math.min(c,f.currentChunk.startTimestamp)}const l=o-a,u=l>=2**32;if(u)for(const f of i)f.currentChunk.offset+=et-Me;this.format._options.onMoof&&this.writer.startTrackingWrites();const d=ws(t,i);if(this.boxWriter.writeBox(d),this.format._options.onMoof){const{data:f,start:p}=this.writer.stopTrackingWrites();this.format._options.onMoof(f,p,c)}m(this.writer.getPos()===a),this.format._options.onMdat&&this.writer.startTrackingWrites();const h=ar(u);h.size=l,this.boxWriter.writeBox(h),this.writer.seek(a+(u?et:Me));for(const f of i)for(const p of f.currentChunk.samples)this.writer.write(p.data),p.data=null;if(this.format._options.onMdat){const{data:f,start:p}=this.writer.stopTrackingWrites();this.format._options.onMdat(f,p)}for(const f of i)f.finalizedChunks.push(f.currentChunk),this.finalizedChunks.push(f.currentChunk),f.currentChunk=null;e&&await this.writer.flush()}async registerSampleFastStartReserve(e,t){if(this.allTracksAreKnown()){if(!this.mdat){const i=Wt(this),n=this.boxWriter.measureBox(i)+this.computeSampleTableSizeUpperBound()+4096;m(this.ftypSize!==null),this.writer.seek(this.ftypSize+n),this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=ar(!0),this.boxWriter.writeBox(this.mdat);for(const a of this.trackDatas){for(const o of a.sampleQueue)await this.addSampleToTrack(a,o);a.sampleQueue.length=0}}await this.addSampleToTrack(e,t)}else e.sampleQueue.push(t)}computeSampleTableSizeUpperBound(){m(this.fastStart==="reserve");let e=0;for(const t of this.trackDatas){const i=t.track.metadata.maximumPacketCount;m(i!==void 0),e+=8*Math.ceil(2/3*i),e+=4*i,e+=8*Math.ceil(2/3*i),e+=12*Math.ceil(2/3*i),e+=4*i,e+=8*i}return e}async onTrackClose(e){const t=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const i=this.trackDatas.find(s=>s.track===e);i&&await this.processWebVTTCues(i,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),t()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const t of this.trackDatas)t.type==="subtitle"&&t.track.source._codec==="webvtt"&&await this.processWebVTTCues(t,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const t of this.trackDatas)this.processTimestamps(t);await this.finalizeFragment(!1)}else for(const t of this.trackDatas)this.processTimestamps(t),await this.finalizeCurrentChunk(t);if(this.fastStart==="in-memory"){this.mdat=ar(!1);let t;for(let s=0;s<2;s++){const n=Wt(this),a=this.boxWriter.measureBox(n);t=this.boxWriter.measureBox(this.mdat);let o=this.writer.getPos()+a+t;for(const c of this.finalizedChunks){c.offset=o;for(const{data:l}of c.samples)m(l),o+=l.byteLength,t+=l.byteLength}if(o<2**32)break;t>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const i=Wt(this);if(this.boxWriter.writeBox(i),this.format._options.onMoov){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onMoov(s,n)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=t,this.boxWriter.writeBox(this.mdat);for(const s of this.finalizedChunks)for(const n of s.samples)m(n.data),this.writer.write(n.data),n.data=null;if(this.format._options.onMdat){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onMdat(s,n)}}else if(this.isFragmented){const t=this.writer.getPos(),i=rl(this.trackDatas);this.boxWriter.writeBox(i);const s=this.writer.getPos()-t;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(s)}else{m(this.mdat);const t=this.boxWriter.offsets.get(this.mdat);m(t!==void 0);const i=this.writer.getPos()-t;if(this.mdat.size=i,this.mdat.largeSize=i>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:n,start:a}=this.writer.stopTrackingWrites();this.format._options.onMdat(n,a)}const s=Wt(this);if(this.fastStart==="reserve"){m(this.ftypSize!==null),this.writer.seek(this.ftypSize),this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(s);const n=this.boxWriter.offsets.get(this.mdat)-this.writer.getPos();this.boxWriter.writeBox(hc(n))}else this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(s);if(this.format._options.onMoov){const{data:n,start:a}=this.writer.stopTrackingWrites();this.format._options.onMoov(n,a)}}e()}}const Il=-32768,El=2**15-1,ks="Mediabunny",Ts=6,ys=5,Al={video:1,audio:2,subtitle:17};class Fl extends ot{constructor(e,t){super(e),this.trackDatas=[],this.allTracksKnown=G(),this.segment=null,this.segmentInfo=null,this.seekHead=null,this.tracksElement=null,this.tagsElement=null,this.attachmentsElement=null,this.segmentDuration=null,this.cues=null,this.currentCluster=null,this.currentClusterStartMsTimestamp=null,this.currentClusterMaxMsTimestamp=null,this.trackDatasInCurrentCluster=new Map,this.duration=0,this.writer=e._writer,this.format=t,this.ebmlWriter=new co(this.writer),this.format._options.appendOnly&&(this.writer.ensureMonotonicity=!0)}async start(){const e=await this.mutex.acquire();this.writeEBMLHeader(),this.createSegmentInfo(),this.createCues(),await this.writer.flush(),e()}writeEBMLHeader(){this.format._options.onEbmlHeader&&this.writer.startTrackingWrites();const e={id:b.EBML,data:[{id:b.EBMLVersion,data:1},{id:b.EBMLReadVersion,data:1},{id:b.EBMLMaxIDLength,data:4},{id:b.EBMLMaxSizeLength,data:8},{id:b.DocType,data:this.format instanceof xs?"webm":"matroska"},{id:b.DocTypeVersion,data:2},{id:b.DocTypeReadVersion,data:2}]};if(this.ebmlWriter.writeEBML(e),this.format._options.onEbmlHeader){const{data:t,start:i}=this.writer.stopTrackingWrites();this.format._options.onEbmlHeader(t,i)}}maybeCreateSeekHead(e){if(this.format._options.appendOnly)return;const t=new Uint8Array([28,83,187,107]),i=new Uint8Array([21,73,169,102]),s=new Uint8Array([22,84,174,107]),n=new Uint8Array([25,65,164,105]),a=new Uint8Array([18,84,195,103]),o={id:b.SeekHead,data:[{id:b.Seek,data:[{id:b.SeekID,data:t},{id:b.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.cues)-this.segmentDataOffset:0}]},{id:b.Seek,data:[{id:b.SeekID,data:i},{id:b.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.segmentInfo)-this.segmentDataOffset:0}]},{id:b.Seek,data:[{id:b.SeekID,data:s},{id:b.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.tracksElement)-this.segmentDataOffset:0}]},this.attachmentsElement?{id:b.Seek,data:[{id:b.SeekID,data:n},{id:b.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.attachmentsElement)-this.segmentDataOffset:0}]}:null,this.tagsElement?{id:b.Seek,data:[{id:b.SeekID,data:a},{id:b.SeekPosition,size:5,data:e?this.ebmlWriter.offsets.get(this.tagsElement)-this.segmentDataOffset:0}]}:null]};this.seekHead=o}createSegmentInfo(){const e={id:b.Duration,data:new ai(0)};this.segmentDuration=e;const t={id:b.Info,data:[{id:b.TimestampScale,data:1e6},{id:b.MuxingApp,data:ks},{id:b.WritingApp,data:ks},this.format._options.appendOnly?null:e]};this.segmentInfo=t}createTracks(){const e={id:b.Tracks,data:[]};this.tracksElement=e;for(const t of this.trackDatas){const i=Se[t.track.source._codec];m(i);let s=0;if(t.type==="audio"&&t.track.source._codec==="opus"){s=1e6*80;const n=t.info.decoderConfig.description;if(n){const a=K(n),o=Er(a);s=Math.round(1e9*(o.preSkip/zt))}}e.data.push({id:b.TrackEntry,data:[{id:b.TrackNumber,data:t.track.id},{id:b.TrackUID,data:t.track.id},{id:b.TrackType,data:Al[t.type]},t.track.metadata.disposition?.default===!1?{id:b.FlagDefault,data:0}:null,t.track.metadata.disposition?.forced?{id:b.FlagForced,data:1}:null,t.track.metadata.disposition?.hearingImpaired?{id:b.FlagHearingImpaired,data:1}:null,t.track.metadata.disposition?.visuallyImpaired?{id:b.FlagVisualImpaired,data:1}:null,t.track.metadata.disposition?.original?{id:b.FlagOriginal,data:1}:null,t.track.metadata.disposition?.commentary?{id:b.FlagCommentary,data:1}:null,{id:b.FlagLacing,data:0},{id:b.Language,data:t.track.metadata.languageCode??me},{id:b.CodecID,data:i},{id:b.CodecDelay,data:0},{id:b.SeekPreRoll,data:s},t.track.metadata.name!==void 0?{id:b.Name,data:new He(t.track.metadata.name)}:null,t.type==="video"?this.videoSpecificTrackInfo(t):null,t.type==="audio"?this.audioSpecificTrackInfo(t):null,t.type==="subtitle"?this.subtitleSpecificTrackInfo(t):null]})}}videoSpecificTrackInfo(e){const{frameRate:t,rotation:i}=e.track.metadata,s=[e.info.decoderConfig.description?{id:b.CodecPrivate,data:K(e.info.decoderConfig.description)}:null,t?{id:b.DefaultDuration,data:1e9/t}:null],n=i?xr(-i):0,a=e.info.decoderConfig.colorSpace,o={id:b.Video,data:[{id:b.PixelWidth,data:e.info.width},{id:b.PixelHeight,data:e.info.height},e.info.alphaMode?{id:b.AlphaMode,data:1}:null,Rs(a)?{id:b.Colour,data:[{id:b.MatrixCoefficients,data:Et[a.matrix]},{id:b.TransferCharacteristics,data:It[a.transfer]},{id:b.Primaries,data:vt[a.primaries]},{id:b.Range,data:a.fullRange?2:1}]}:null,n?{id:b.Projection,data:[{id:b.ProjectionType,data:0},{id:b.ProjectionPoseRoll,data:new ni((n+180)%360-180)}]}:null]};return s.push(o),s}audioSpecificTrackInfo(e){const t=Z.includes(e.track.source._codec)?Ae(e.track.source._codec):null;return[e.info.decoderConfig.description?{id:b.CodecPrivate,data:K(e.info.decoderConfig.description)}:null,{id:b.Audio,data:[{id:b.SamplingFrequency,data:new ni(e.info.sampleRate)},{id:b.Channels,data:e.info.numberOfChannels},t?{id:b.BitDepth,data:8*t.sampleSize}:null]}]}subtitleSpecificTrackInfo(e){return[{id:b.CodecPrivate,data:j.encode(e.info.config.description)}]}maybeCreateTags(){const e=[],t=(n,a)=>{e.push({id:b.SimpleTag,data:[{id:b.TagName,data:new He(n)},typeof a=="string"?{id:b.TagString,data:new He(a)}:{id:b.TagBinary,data:a}]})},i=this.output._metadataTags,s=new Set;for(const{key:n,value:a}of Ft(i))switch(n){case"title":t("TITLE",a),s.add("TITLE");break;case"description":t("DESCRIPTION",a),s.add("DESCRIPTION");break;case"artist":t("ARTIST",a),s.add("ARTIST");break;case"album":t("ALBUM",a),s.add("ALBUM");break;case"albumArtist":t("ALBUM_ARTIST",a),s.add("ALBUM_ARTIST");break;case"genre":t("GENRE",a),s.add("GENRE");break;case"comment":t("COMMENT",a),s.add("COMMENT");break;case"lyrics":t("LYRICS",a),s.add("LYRICS");break;case"date":t("DATE",a.toISOString().slice(0,10)),s.add("DATE");break;case"trackNumber":{const o=i.tracksTotal!==void 0?`${a}/${i.tracksTotal}`:a.toString();t("PART_NUMBER",o),s.add("PART_NUMBER")}break;case"discNumber":{const o=i.discsTotal!==void 0?`${a}/${i.discsTotal}`:a.toString();t("DISC",o),s.add("DISC")}break;case"tracksTotal":case"discsTotal":break;case"images":case"raw":break;default:ae(n)}if(i.raw)for(const n in i.raw){const a=i.raw[n];a==null||s.has(n)||(typeof a=="string"||a instanceof Uint8Array)&&t(n,a)}e.length!==0&&(this.tagsElement={id:b.Tags,data:[{id:b.Tag,data:[{id:b.Targets,data:[{id:b.TargetTypeValue,data:50},{id:b.TargetType,data:"MOVIE"}]},...e]}]})}maybeCreateAttachments(){const e=this.output._metadataTags,t=[],i=new Set,s=e.images??[];for(const n of s){let a=n.name;a===void 0&&(a=(n.kind==="coverFront"?"cover":n.kind==="coverBack"?"back":"image")+(aa(n.mimeType)??""));let o;for(;;){o=0n;for(let c=0;c<8;c++)o<<=8n,o|=BigInt(Math.floor(Math.random()*256));if(o!==0n&&!i.has(o))break}i.add(o),t.push({id:b.AttachedFile,data:[n.description!==void 0?{id:b.FileDescription,data:new He(n.description)}:null,{id:b.FileName,data:new He(a)},{id:b.FileMediaType,data:n.mimeType},{id:b.FileData,data:n.data},{id:b.FileUID,data:o}]})}for(const[n,a]of Object.entries(e.raw??{}))!(a instanceof Si)||!/^\d+$/.test(n)||s.find(c=>c.mimeType===a.mimeType&&la(c.data,a.data))||t.push({id:b.AttachedFile,data:[a.description!==void 0?{id:b.FileDescription,data:new He(a.description)}:null,{id:b.FileName,data:new He(a.name??"")},{id:b.FileMediaType,data:a.mimeType??""},{id:b.FileData,data:a.data},{id:b.FileUID,data:BigInt(n)}]});t.length!==0&&(this.attachmentsElement={id:b.Attachments,data:t})}createSegment(){this.createTracks(),this.maybeCreateTags(),this.maybeCreateAttachments(),this.maybeCreateSeekHead(!1);const e={id:b.Segment,size:this.format._options.appendOnly?-1:Ts,data:[this.seekHead,this.segmentInfo,this.tracksElement,this.attachmentsElement,this.tagsElement]};if(this.segment=e,this.format._options.onSegmentHeader&&this.writer.startTrackingWrites(),this.ebmlWriter.writeEBML(e),this.format._options.onSegmentHeader){const{data:t,start:i}=this.writer.stopTrackingWrites();this.format._options.onSegmentHeader(t,i)}}createCues(){this.cues={id:b.Cues,data:[]}}get segmentDataOffset(){return m(this.segment),this.ebmlWriter.dataOffsets.get(this.segment)}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(t=>t.type==="video"||t.type==="audio"?t.info.decoderConfig.codec:{webvtt:"wvtt"}[t.track.source._codec]);return dn({isWebM:this.format instanceof xs,hasVideo:this.trackDatas.some(t=>t.type==="video"),hasAudio:this.trackDatas.some(t=>t.type==="audio"),codecStrings:e})}getVideoTrackData(e,t,i){const s=this.trackDatas.find(a=>a.track===e);if(s)return s;js(i),m(i),m(i.decoderConfig),m(i.decoderConfig.codedWidth!==void 0),m(i.decoderConfig.codedHeight!==void 0);const n={track:e,type:"video",info:{width:i.decoderConfig.codedWidth,height:i.decoderConfig.codedHeight,decoderConfig:i.decoderConfig,alphaMode:!!t.sideData.alpha},chunkQueue:[],lastWrittenMsTimestamp:null};return e.source._codec==="vp9"?n.info.decoderConfig={...n.info.decoderConfig,description:new Uint8Array(ha(n.info.decoderConfig.codec))}:e.source._codec==="av1"&&(n.info.decoderConfig={...n.info.decoderConfig,description:new Uint8Array(Vs(n.info.decoderConfig.codec))}),this.trackDatas.push(n),this.trackDatas.sort((a,o)=>a.track.id-o.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),n}getAudioTrackData(e,t){const i=this.trackDatas.find(n=>n.track===e);if(i)return i;Rt(t),m(t),m(t.decoderConfig);const s={track:e,type:"audio",info:{numberOfChannels:t.decoderConfig.numberOfChannels,sampleRate:t.decoderConfig.sampleRate,decoderConfig:t.decoderConfig},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}getSubtitleTrackData(e,t){const i=this.trackDatas.find(n=>n.track===e);if(i)return i;$s(t),m(t),m(t.config);const s={track:e,type:"subtitle",info:{config:t.config},chunkQueue:[],lastWrittenMsTimestamp:null};return this.trackDatas.push(s),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,t,i){const s=await this.mutex.acquire();try{const n=this.getVideoTrackData(e,t,i),a=t.type==="key";let o=this.validateAndNormalizeTimestamp(n.track,t.timestamp,a),c=t.duration;e.metadata.frameRate!==void 0&&(o=Yr(o,1/e.metadata.frameRate),c=Yr(c,1/e.metadata.frameRate));const l=n.info.alphaMode?t.sideData.alpha??null:null,u=this.createInternalChunk(t.data,o,c,t.type,l);e.source._codec==="vp9"&&this.fixVP9ColorSpace(n,u),n.chunkQueue.push(u),await this.interleaveChunks()}finally{s()}}async addEncodedAudioPacket(e,t,i){const s=await this.mutex.acquire();try{const n=this.getAudioTrackData(e,i),a=t.type==="key",o=this.validateAndNormalizeTimestamp(n.track,t.timestamp,a),c=this.createInternalChunk(t.data,o,t.duration,t.type);n.chunkQueue.push(c),await this.interleaveChunks()}finally{s()}}async addSubtitleCue(e,t,i){const s=await this.mutex.acquire();try{const n=this.getSubtitleTrackData(e,i),a=this.validateAndNormalizeTimestamp(n.track,t.timestamp,!0);let o=t.text;const c=Math.round(a*1e3);Sr.lastIndex=0,o=o.replace(Sr,h=>{const p=gi(h.slice(1,-1))-c;return`<${Fn(p)}>`});const l=j.encode(o),u=`${t.settings??""}
${t.identifier??""}
${t.notes??""}`,d=this.createInternalChunk(l,a,t.duration,"key",u.trim()?j.encode(u):null);n.chunkQueue.push(d),await this.interleaveChunks()}finally{s()}}async interleaveChunks(e=!1){if(!(!e&&!this.allTracksAreKnown())){e:for(;;){let t=null,i=1/0;for(const n of this.trackDatas){if(!e&&n.chunkQueue.length===0&&!n.track.source._closed)break e;n.chunkQueue.length>0&&n.chunkQueue[0].timestamp<i&&(t=n,i=n.chunkQueue[0].timestamp)}if(!t)break;const s=t.chunkQueue.shift();this.writeBlock(t,s)}e||await this.writer.flush()}}fixVP9ColorSpace(e,t){if(t.type!=="key"||!e.info.decoderConfig.colorSpace||!e.info.decoderConfig.colorSpace.matrix)return;const i=new W(t.data);i.skipBits(2);const s=i.readBits(1),a=(i.readBits(1)<<1)+s;if(a===3&&i.skipBits(1),i.readBits(1)||i.readBits(1)!==0||(i.skipBits(2),i.readBits(24)!==4817730))return;a>=2&&i.skipBits(1);const u={rgb:7,bt709:2,bt470bg:1,smpte170m:3}[e.info.decoderConfig.colorSpace.matrix];Xn(t.data,i.pos,i.pos+3,u)}createInternalChunk(e,t,i,s,n=null){return{data:e,type:s,timestamp:t,duration:i,additions:n}}writeBlock(e,t){this.segment||this.createSegment();const i=Math.round(1e3*t.timestamp),s=this.trackDatas.every(u=>{if(e===u)return t.type==="key";const d=u.chunkQueue[0];return d?d.type==="key":u.track.source._closed});let n=!1;if(!this.currentCluster)n=!0;else{m(this.currentClusterStartMsTimestamp!==null),m(this.currentClusterMaxMsTimestamp!==null);const u=i-this.currentClusterStartMsTimestamp;n=s&&i>this.currentClusterMaxMsTimestamp&&u>=1e3*(this.format._options.minimumClusterDuration??1)||u>El}n&&this.createNewCluster(i);const a=i-this.currentClusterStartMsTimestamp;if(a<Il)return;const o=new Uint8Array(4),c=new DataView(o.buffer);c.setUint8(0,128|e.track.id),c.setInt16(1,a,!1);const l=Math.round(1e3*t.duration);if(t.additions){const u={id:b.BlockGroup,data:[{id:b.Block,data:[o,t.data]},t.type==="delta"?{id:b.ReferenceBlock,data:new on(e.lastWrittenMsTimestamp-i)}:null,t.additions?{id:b.BlockAdditions,data:[{id:b.BlockMore,data:[{id:b.BlockAddID,data:1},{id:b.BlockAdditional,data:t.additions}]}]}:null,l>0?{id:b.BlockDuration,data:l}:null]};this.ebmlWriter.writeEBML(u)}else{c.setUint8(3,+(t.type==="key")<<7);const u={id:b.SimpleBlock,data:[o,t.data]};this.ebmlWriter.writeEBML(u)}this.duration=Math.max(this.duration,i+l),e.lastWrittenMsTimestamp=i,this.trackDatasInCurrentCluster.has(e)||this.trackDatasInCurrentCluster.set(e,{firstMsTimestamp:i}),this.currentClusterMaxMsTimestamp=Math.max(this.currentClusterMaxMsTimestamp,i)}createNewCluster(e){this.currentCluster&&this.finalizeCurrentCluster(),this.format._options.onCluster&&this.writer.startTrackingWrites(),this.currentCluster={id:b.Cluster,size:this.format._options.appendOnly?-1:ys,data:[{id:b.Timestamp,data:e}]},this.ebmlWriter.writeEBML(this.currentCluster),this.currentClusterStartMsTimestamp=e,this.currentClusterMaxMsTimestamp=e,this.trackDatasInCurrentCluster.clear()}finalizeCurrentCluster(){if(m(this.currentCluster),!this.format._options.appendOnly){const s=this.writer.getPos()-this.ebmlWriter.dataOffsets.get(this.currentCluster),n=this.writer.getPos();this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster)+4),this.ebmlWriter.writeVarInt(s,ys),this.writer.seek(n)}if(this.format._options.onCluster){m(this.currentClusterStartMsTimestamp!==null);const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onCluster(s,n,this.currentClusterStartMsTimestamp/1e3)}const e=this.ebmlWriter.offsets.get(this.currentCluster)-this.segmentDataOffset,t=new Map;for(const[s,{firstMsTimestamp:n}]of this.trackDatasInCurrentCluster)t.has(n)||t.set(n,[]),t.get(n).push(s);const i=[...t.entries()].sort((s,n)=>s[0]-n[0]);for(const[s,n]of i)m(this.cues),this.cues.data.push({id:b.CuePoint,data:[{id:b.CueTime,data:s},...n.map(a=>({id:b.CueTrackPositions,data:[{id:b.CueTrack,data:a.track.id},{id:b.CueClusterPosition,data:e}]}))]})}async onTrackClose(){const e=await this.mutex.acquire();this.allTracksAreKnown()&&this.allTracksKnown.resolve(),await this.interleaveChunks(),e()}async finalize(){const e=await this.mutex.acquire();if(this.allTracksKnown.resolve(),this.segment||this.createSegment(),await this.interleaveChunks(!0),this.currentCluster&&this.finalizeCurrentCluster(),m(this.cues),this.ebmlWriter.writeEBML(this.cues),!this.format._options.appendOnly){const t=this.writer.getPos(),i=this.writer.getPos()-this.segmentDataOffset;this.writer.seek(this.ebmlWriter.offsets.get(this.segment)+4),this.ebmlWriter.writeVarInt(i,Ts),this.segmentDuration.data=new ai(this.duration),this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration)),this.ebmlWriter.writeEBML(this.segmentDuration),m(this.seekHead),this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead)),this.maybeCreateSeekHead(!0),this.ebmlWriter.writeEBML(this.seekHead),this.writer.seek(t)}e()}}class Bl{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer)}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeXingFrame(e){const t=this.writer.getPos(),i=255,s=224|e.mpegVersionId<<3|e.layer<<1;let n;e.mpegVersionId&2?n=e.mpegVersionId&1?0:1:n=1;const a=0,o=155;let c=-1;const l=n*16*4+e.layer*16;for(let w=0;w<16;w++){const T=li[l+w];if(ui(n,e.layer,1e3*T,e.sampleRate,a)>=o){c=w;break}}if(c===-1)throw new Error("No suitable bitrate found.");const u=c<<4|e.frequencyIndex<<2|a<<1,d=e.channel<<6|e.modeExtension<<4|e.copyright<<3|e.original<<2|e.emphasis;this.helper[0]=i,this.helper[1]=s,this.helper[2]=u,this.helper[3]=d,this.writer.write(this.helper.subarray(0,4));const h=Ai(e.mpegVersionId,e.channel);this.writer.seek(t+h),this.writeU32(Ei);let f=0;e.frameCount!==null&&(f|=1),e.fileSize!==null&&(f|=2),e.toc!==null&&(f|=4),this.writeU32(f),this.writeU32(e.frameCount??0),this.writeU32(e.fileSize??0),this.writer.write(e.toc??new Uint8Array(100));const p=li[l+c],g=ui(n,e.layer,1e3*p,e.sampleRate,a);this.writer.seek(t+g)}}class zl extends ot{constructor(e,t){super(e),this.xingFrameData=null,this.frameCount=0,this.framePositions=[],this.xingFramePos=null,this.format=t,this.writer=e._writer,this.mp3Writer=new Bl(e._writer)}async start(){fr(this.output._metadataTags)||new bn(this.writer).writeId3V2Tag(this.output._metadataTags)}async getMimeType(){return"audio/mpeg"}async addEncodedVideoPacket(){throw new Error("MP3 does not support video.")}async addEncodedAudioPacket(e,t){const i=await this.mutex.acquire();try{const s=this.format._options.xingHeader!==!1;if(!this.xingFrameData&&s){const n=L(t.data);if(n.byteLength<4)throw new Error("Invalid MP3 header in sample.");const a=n.getUint32(0,!1),o=gn(a,null).header;if(!o)throw new Error("Invalid MP3 header in sample.");const c=Ai(o.mpegVersionId,o.channel);if(n.byteLength>=c+4){const l=n.getUint32(c,!1);if(l===Ei||l===pn)return}this.xingFrameData={mpegVersionId:o.mpegVersionId,layer:o.layer,frequencyIndex:o.frequencyIndex,sampleRate:o.sampleRate,channel:o.channel,modeExtension:o.modeExtension,copyright:o.copyright,original:o.original,emphasis:o.emphasis,frameCount:null,fileSize:null,toc:null},this.xingFramePos=this.writer.getPos(),this.mp3Writer.writeXingFrame(this.xingFrameData),this.frameCount++}this.validateAndNormalizeTimestamp(e,t.timestamp,t.type==="key"),this.writer.write(t.data),this.frameCount++,await this.writer.flush(),s&&this.framePositions.push(this.writer.getPos())}finally{i()}}async addSubtitleCue(){throw new Error("MP3 does not support subtitles.")}async finalize(){if(!this.xingFrameData||this.xingFramePos===null)return;const e=await this.mutex.acquire(),t=this.writer.getPos();this.writer.seek(this.xingFramePos);const i=new Uint8Array(100);for(let s=0;s<100;s++){const n=Math.floor(this.framePositions.length*(s/100));m(n!==-1&&n<this.framePositions.length);const a=this.framePositions[n];i[s]=256*(a/t)}if(this.xingFrameData.frameCount=this.frameCount,this.xingFrameData.fileSize=t,this.xingFrameData.toc=i,this.format._options.onXingFrame&&this.writer.startTrackingWrites(),this.mp3Writer.writeXingFrame(this.xingFrameData),this.format._options.onXingFrame){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onXingFrame(s,n)}this.writer.seek(t),e()}}const Rl=8192;class Ml extends ot{constructor(e,t){super(e),this.trackDatas=[],this.bosPagesWritten=!1,this.allTracksKnown=G(),this.pageBytes=new Uint8Array(xn),this.pageView=new DataView(this.pageBytes.buffer),this.format=t,this.writer=e._writer,this.writer.ensureMonotonicity=!0}async start(){}async getMimeType(){return await this.allTracksKnown.promise,Sn({codecStrings:this.trackDatas.map(e=>e.codecInfo.codec)})}addEncodedVideoPacket(){throw new Error("Video tracks are not supported.")}getTrackData(e,t){const i=this.trackDatas.find(a=>a.track===e);if(i)return i;let s;do s=Math.floor(2**32*Math.random());while(this.trackDatas.some(a=>a.serialNumber===s));m(e.source._codec==="vorbis"||e.source._codec==="opus"),Rt(t),m(t),m(t.decoderConfig);const n={track:e,serialNumber:s,internalSampleRate:e.source._codec==="opus"?zt:t.decoderConfig.sampleRate,codecInfo:{codec:e.source._codec,vorbisInfo:null,opusInfo:null},vorbisLastBlocksize:null,packetQueue:[],currentTimestampInSamples:0,pagesWritten:0,currentGranulePosition:0,currentLacingValues:[],currentPageData:[],currentPageSize:27,currentPageStartsWithFreshPacket:!0};return this.queueHeaderPackets(n,t),this.trackDatas.push(n),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),n}queueHeaderPackets(e,t){if(m(t.decoderConfig),e.track.source._codec==="vorbis"){m(t.decoderConfig.description);const i=K(t.decoderConfig.description);if(i[0]!==2)throw new TypeError("First byte of Vorbis decoder description must be 2.");let s=1;const n=()=>{let g=0;for(;;){const w=i[s++];if(w===void 0)throw new TypeError("Vorbis decoder description is too short.");if(g+=w,w<255)return g}},a=n(),o=n();if(i.length-s<=0)throw new TypeError("Vorbis decoder description is too short.");const l=i.subarray(s,s+=a);s+=o;const u=i.subarray(s),d=new Uint8Array(7);d[0]=3,d[1]=118,d[2]=111,d[3]=114,d[4]=98,d[5]=105,d[6]=115;const h=ti(d,this.output._metadataTags,!0);e.packetQueue.push({data:l,endGranulePosition:0,timestamp:0,forcePageFlush:!0},{data:h,endGranulePosition:0,timestamp:0,forcePageFlush:!1},{data:u,endGranulePosition:0,timestamp:0,forcePageFlush:!0});const p=L(l).getUint8(28);e.codecInfo.vorbisInfo={blocksizes:[1<<(p&15),1<<(p>>4)],modeBlockflags:tn(u).modeBlockflags}}else if(e.track.source._codec==="opus"){if(!t.decoderConfig.description)throw new TypeError("For Ogg, Opus decoder description is required.");const i=K(t.decoderConfig.description),s=new Uint8Array(8),n=L(s);n.setUint32(0,1332770163,!1),n.setUint32(4,1415669619,!1);const a=ti(s,this.output._metadataTags,!0);e.packetQueue.push({data:i,endGranulePosition:0,timestamp:0,forcePageFlush:!0},{data:a,endGranulePosition:0,timestamp:0,forcePageFlush:!0}),e.codecInfo.opusInfo={preSkip:Er(i).preSkip}}}async addEncodedAudioPacket(e,t,i){const s=await this.mutex.acquire();try{const n=this.getTrackData(e,i);this.validateAndNormalizeTimestamp(n.track,t.timestamp,t.type==="key");const a=n.currentTimestampInSamples,{durationInSamples:o,vorbisBlockSize:c}=yn(t.data,n.codecInfo,n.vorbisLastBlocksize);n.currentTimestampInSamples+=o,n.vorbisLastBlocksize=c,n.packetQueue.push({data:t.data,endGranulePosition:n.currentTimestampInSamples,timestamp:a/n.internalSampleRate,forcePageFlush:!1}),await this.interleavePages()}finally{s()}}addSubtitleCue(){throw new Error("Subtitle tracks are not supported.")}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(t=>t.track===e))return!1;return!0}async interleavePages(e=!1){if(!this.bosPagesWritten){if(!this.allTracksAreKnown())return;for(const t of this.trackDatas)for(;t.packetQueue.length>0;){const i=t.packetQueue.shift();if(this.writePacket(t,i,!1),i.forcePageFlush)break}this.bosPagesWritten=!0}e:for(;;){let t=null,i=1/0;for(const a of this.trackDatas){if(!e&&a.packetQueue.length<=1&&!a.track.source._closed)break e;a.packetQueue.length>0&&a.packetQueue[0].timestamp<i&&(t=a,i=a.packetQueue[0].timestamp)}if(!t)break;const s=t.packetQueue.shift(),n=t.packetQueue.length===0;this.writePacket(t,s,n)}e||await this.writer.flush()}writePacket(e,t,i){let s=t.data.length,n=0,a=0;for(;;){e.currentLacingValues.length===0&&n>0&&(e.currentPageStartsWithFreshPacket=!1);const c=Math.min(255,s);e.currentLacingValues.push(c),e.currentPageSize++,a+=c;const l=s<255;if(e.currentLacingValues.length===255){const u=t.data.subarray(n,a);if(n=a,e.currentPageData.push(u),e.currentPageSize+=u.length,this.writePage(e,i&&l),l)return}if(l)break;s-=255}const o=t.data.subarray(n);e.currentPageData.push(o),e.currentPageSize+=o.length,e.currentGranulePosition=t.endGranulePosition,(e.currentPageSize>=Rl||t.forcePageFlush)&&this.writePage(e,i)}writePage(e,t){this.pageView.setUint32(0,Fi,!0),this.pageView.setUint8(4,0);let i=0;e.currentPageStartsWithFreshPacket||(i|=1),e.pagesWritten===0&&(i|=2),t&&(i|=4),this.pageView.setUint8(5,i);const s=e.currentLacingValues.every(c=>c===255)?-1:e.currentGranulePosition;ta(this.pageView,6,s),this.pageView.setUint32(14,e.serialNumber,!0),this.pageView.setUint32(18,e.pagesWritten,!0),this.pageView.setUint32(22,0,!0),this.pageView.setUint8(26,e.currentLacingValues.length),this.pageBytes.set(e.currentLacingValues,27);let n=27+e.currentLacingValues.length;for(const c of e.currentPageData)this.pageBytes.set(c,n),n+=c.length;const a=this.pageBytes.subarray(0,n),o=Tn(a);if(this.pageView.setUint32(22,o,!0),e.pagesWritten++,e.currentLacingValues.length=0,e.currentPageData.length=0,e.currentPageSize=27,e.currentPageStartsWithFreshPacket=!0,this.format._options.onPage&&this.writer.startTrackingWrites(),this.writer.write(a),this.format._options.onPage){const{data:c,start:l}=this.writer.stopTrackingWrites();this.format._options.onPage(c,l,e.track.source)}}async onTrackClose(){const e=await this.mutex.acquire();this.allTracksAreKnown()&&this.allTracksKnown.resolve(),await this.interleavePages(),e()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve(),await this.interleavePages(!0);for(const t of this.trackDatas)t.currentLacingValues.length>0&&this.writePage(t,!0);e()}}class Dl{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer)}writeU16(e){this.helperView.setUint16(0,e,!0),this.writer.write(this.helper.subarray(0,2))}writeU32(e){this.helperView.setUint32(0,e,!0),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,e,!0),this.helperView.setUint32(4,Math.floor(e/2**32),!0),this.writer.write(this.helper)}writeAscii(e){this.writer.write(new TextEncoder().encode(e))}}class Ul extends ot{constructor(e,t){super(e),this.headerWritten=!1,this.dataSize=0,this.sampleRate=null,this.sampleCount=0,this.riffSizePos=null,this.dataSizePos=null,this.ds64RiffSizePos=null,this.ds64DataSizePos=null,this.ds64SampleCountPos=null,this.format=t,this.writer=e._writer,this.riffWriter=new Dl(e._writer),this.isRf64=!!t._options.large}async start(){}async getMimeType(){return"audio/wav"}async addEncodedVideoPacket(){throw new Error("WAVE does not support video.")}async addEncodedAudioPacket(e,t,i){const s=await this.mutex.acquire();try{if(this.headerWritten||(Rt(i),m(i),m(i.decoderConfig),this.writeHeader(e,i.decoderConfig),this.sampleRate=i.decoderConfig.sampleRate,this.headerWritten=!0),this.validateAndNormalizeTimestamp(e,t.timestamp,t.type==="key"),!this.isRf64&&this.writer.getPos()+t.data.byteLength>=2**32)throw new Error("Adding more audio data would exceed the maximum RIFF size of 4 GiB. To write larger files, use RF64 by setting `large: true` in the WavOutputFormatOptions.");this.writer.write(t.data),this.dataSize+=t.data.byteLength,this.sampleCount+=Math.round(t.duration*this.sampleRate),await this.writer.flush()}finally{s()}}async addSubtitleCue(){throw new Error("WAVE does not support subtitles.")}writeHeader(e,t){this.format._options.onHeader&&this.writer.startTrackingWrites();let i;const s=e.source._codec,n=Ae(s);n.dataType==="ulaw"?i=he.MULAW:n.dataType==="alaw"?i=he.ALAW:n.dataType==="float"?i=he.IEEE_FLOAT:i=he.PCM;const a=t.numberOfChannels,o=t.sampleRate,c=n.sampleSize*a;if(this.riffWriter.writeAscii(this.isRf64?"RF64":"RIFF"),this.isRf64?this.riffWriter.writeU32(4294967295):(this.riffSizePos=this.writer.getPos(),this.riffWriter.writeU32(0)),this.riffWriter.writeAscii("WAVE"),this.isRf64&&(this.riffWriter.writeAscii("ds64"),this.riffWriter.writeU32(28),this.ds64RiffSizePos=this.writer.getPos(),this.riffWriter.writeU64(0),this.ds64DataSizePos=this.writer.getPos(),this.riffWriter.writeU64(0),this.ds64SampleCountPos=this.writer.getPos(),this.riffWriter.writeU64(0),this.riffWriter.writeU32(0)),this.riffWriter.writeAscii("fmt "),this.riffWriter.writeU32(16),this.riffWriter.writeU16(i),this.riffWriter.writeU16(a),this.riffWriter.writeU32(o),this.riffWriter.writeU32(o*c),this.riffWriter.writeU16(c),this.riffWriter.writeU16(8*n.sampleSize),!fr(this.output._metadataTags)){const l=this.format._options.metadataFormat??"info";l==="info"?this.writeInfoChunk(this.output._metadataTags):l==="id3"?this.writeId3Chunk(this.output._metadataTags):ae(l)}if(this.riffWriter.writeAscii("data"),this.isRf64?this.riffWriter.writeU32(4294967295):(this.dataSizePos=this.writer.getPos(),this.riffWriter.writeU32(0)),this.format._options.onHeader){const{data:l,start:u}=this.writer.stopTrackingWrites();this.format._options.onHeader(l,u)}}writeInfoChunk(e){const t=this.writer.getPos();this.riffWriter.writeAscii("LIST"),this.riffWriter.writeU32(0),this.riffWriter.writeAscii("INFO");const i=new Set,s=(o,c)=>{if(!pt(c)){console.warn(`Didn't write tag '${o}' because '${c}' is not ISO 8859-1-compatible.`);return}const l=c.length+1,u=new Uint8Array(l);for(let d=0;d<c.length;d++)u[d]=c.charCodeAt(d);this.riffWriter.writeAscii(o),this.riffWriter.writeU32(l),this.writer.write(u),l&1&&this.writer.write(new Uint8Array(1)),i.add(o)};for(const{key:o,value:c}of Ft(e))switch(o){case"title":s("INAM",c),i.add("INAM");break;case"artist":s("IART",c),i.add("IART");break;case"album":s("IPRD",c),i.add("IPRD");break;case"trackNumber":{const l=e.tracksTotal!==void 0?`${c}/${e.tracksTotal}`:c.toString();s("ITRK",l),i.add("ITRK")}break;case"genre":s("IGNR",c),i.add("IGNR");break;case"date":s("ICRD",c.toISOString().slice(0,10)),i.add("ICRD");break;case"comment":s("ICMT",c),i.add("ICMT");break;case"albumArtist":case"discNumber":case"tracksTotal":case"discsTotal":case"description":case"lyrics":case"images":break;case"raw":break;default:ae(o)}if(e.raw)for(const o in e.raw){const c=e.raw[o];c==null||o.length!==4||i.has(o)||typeof c=="string"&&s(o,c)}const n=this.writer.getPos(),a=n-t-8;this.writer.seek(t+4),this.riffWriter.writeU32(a),this.writer.seek(n),a&1&&this.writer.write(new Uint8Array(1))}writeId3Chunk(e){const t=this.writer.getPos();this.riffWriter.writeAscii("ID3 "),this.riffWriter.writeU32(0);const s=new bn(this.writer).writeId3V2Tag(e),n=this.writer.getPos();this.writer.seek(t+4),this.riffWriter.writeU32(s),this.writer.seek(n),s&1&&this.writer.write(new Uint8Array(1))}async finalize(){const e=await this.mutex.acquire(),t=this.writer.getPos();this.isRf64?(m(this.ds64RiffSizePos!==null),this.writer.seek(this.ds64RiffSizePos),this.riffWriter.writeU64(t-8),m(this.ds64DataSizePos!==null),this.writer.seek(this.ds64DataSizePos),this.riffWriter.writeU64(this.dataSize),m(this.ds64SampleCountPos!==null),this.writer.seek(this.ds64SampleCountPos),this.riffWriter.writeU64(this.sampleCount)):(m(this.riffSizePos!==null),this.writer.seek(this.riffSizePos),this.riffWriter.writeU32(t-8),m(this.dataSizePos!==null),this.writer.seek(this.dataSizePos),this.riffWriter.writeU32(this.dataSize)),this.writer.seek(t),e()}}class Ze{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>ce.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>pe.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>Ve.includes(e))}_codecUnsupportedHint(e){return""}}class Hn extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","reserve","fragmented"].includes(e.fastStart))throw new TypeError("options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'.");if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");if(e.metadataFormat!==void 0&&!["mdir","mdta","udta","auto"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:2**32-1}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new vl(e,this)}}class qn extends Hn{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...ce,...xt,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...Ve]}_codecUnsupportedHint(e){return new jn().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class jn extends Hn{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...ce,...pe]}_codecUnsupportedHint(e){return new qn().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}class Ss extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.appendOnly!==void 0&&typeof e.appendOnly!="boolean")throw new TypeError("options.appendOnly, when provided, must be a boolean.");if(e.minimumClusterDuration!==void 0&&(!Number.isFinite(e.minimumClusterDuration)||e.minimumClusterDuration<0))throw new TypeError("options.minimumClusterDuration, when provided, must be a non-negative number.");if(e.onEbmlHeader!==void 0&&typeof e.onEbmlHeader!="function")throw new TypeError("options.onEbmlHeader, when provided, must be a function.");if(e.onSegmentHeader!==void 0&&typeof e.onSegmentHeader!="function")throw new TypeError("options.onHeader, when provided, must be a function.");if(e.onCluster!==void 0&&typeof e.onCluster!="function")throw new TypeError("options.onCluster, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new Fl(e,this)}get _name(){return"Matroska"}getSupportedTrackCounts(){return{video:{min:0,max:1/0},audio:{min:0,max:1/0},subtitle:{min:0,max:1/0},total:{min:1,max:127}}}get fileExtension(){return".mkv"}get mimeType(){return"video/x-matroska"}getSupportedCodecs(){return[...ce,...xt,...Z.filter(e=>!["pcm-s8","pcm-f32be","pcm-f64be","ulaw","alaw"].includes(e)),...Ve]}get supportsVideoRotationMetadata(){return!1}}class xs extends Ss{constructor(e){super(e)}getSupportedCodecs(){return[...ce.filter(e=>["vp8","vp9","av1"].includes(e)),...pe.filter(e=>["opus","vorbis"].includes(e)),...Ve]}get _name(){return"WebM"}get fileExtension(){return".webm"}get mimeType(){return"video/webm"}_codecUnsupportedHint(e){return new Ss().getSupportedCodecs().includes(e)?" Switching to MKV will grant support for this codec.":""}}class cu extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.xingHeader!==void 0&&typeof e.xingHeader!="boolean")throw new TypeError("options.xingHeader, when provided, must be a boolean.");if(e.onXingFrame!==void 0&&typeof e.onXingFrame!="function")throw new TypeError("options.onXingFrame, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new zl(e,this)}get _name(){return"MP3"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".mp3"}get mimeType(){return"audio/mpeg"}getSupportedCodecs(){return["mp3"]}get supportsVideoRotationMetadata(){return!1}}class lu extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.large!==void 0&&typeof e.large!="boolean")throw new TypeError("options.large, when provided, must be a boolean.");if(e.metadataFormat!==void 0&&!["info","id3"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'info' or 'id3'.");if(e.onHeader!==void 0&&typeof e.onHeader!="function")throw new TypeError("options.onHeader, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new Ul(e,this)}get _name(){return"WAVE"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".wav"}get mimeType(){return"audio/wav"}getSupportedCodecs(){return[...Z.filter(e=>["pcm-s16","pcm-s24","pcm-s32","pcm-f32","pcm-u8","ulaw","alaw"].includes(e))]}get supportsVideoRotationMetadata(){return!1}}class uu extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.onPage!==void 0&&typeof e.onPage!="function")throw new TypeError("options.onPage, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new Ml(e,this)}get _name(){return"Ogg"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:0,max:1/0},subtitle:{min:0,max:0},total:{min:1,max:2**32}}}get fileExtension(){return".ogg"}get mimeType(){return"application/ogg"}getSupportedCodecs(){return[...pe.filter(e=>["vorbis","opus"].includes(e))]}get supportsVideoRotationMetadata(){return!1}}class du extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.onFrame!==void 0&&typeof e.onFrame!="function")throw new TypeError("options.onFrame, when provided, must be a function.");super(),this._options=e}_createMuxer(e){return new xa(e,this)}get _name(){return"ADTS"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".aac"}get mimeType(){return"audio/aac"}getSupportedCodecs(){return["aac"]}get supportsVideoRotationMetadata(){return!1}}class hu extends Ze{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");super(),this._options=e}_createMuxer(e){return new oc(e,this)}get _name(){return"FLAC"}getSupportedTrackCounts(){return{video:{min:0,max:0},audio:{min:1,max:1},subtitle:{min:0,max:0},total:{min:1,max:1}}}get fileExtension(){return".flac"}get mimeType(){return"audio/flac"}getSupportedCodecs(){return["flac"]}get supportsVideoRotationMetadata(){return!1}}const Ui=r=>{if(!r||typeof r!="object")throw new TypeError("Encoding config must be an object.");if(!ce.includes(r.codec))throw new TypeError(`Invalid video codec '${r.codec}'. Must be one of: ${ce.join(", ")}.`);if(!(r.bitrate instanceof ge)&&(!Number.isInteger(r.bitrate)||r.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(r.keyFrameInterval!==void 0&&(!Number.isFinite(r.keyFrameInterval)||r.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(r.sizeChangeBehavior!==void 0&&!["deny","passThrough","fill","contain","cover"].includes(r.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(r.onEncodedPacket!==void 0&&typeof r.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(r.onEncoderConfig!==void 0&&typeof r.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");$n(r.codec,r)},$n=(r,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.alpha!==void 0&&!["discard","keep"].includes(e.alpha))throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&qs(e.fullCodecString)!==r)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${r}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},bi=r=>{const e=r.bitrate instanceof ge?r.bitrate._toVideoBitrate(r.codec,r.width,r.height):r.bitrate;return{codec:r.fullCodecString??da(r.codec,r.width,r.height,e),width:r.width,height:r.height,bitrate:e,bitrateMode:r.bitrateMode,alpha:r.alpha??"discard",framerate:r.framerate,latencyMode:r.latencyMode,hardwareAcceleration:r.hardwareAcceleration,scalabilityMode:r.scalabilityMode,contentHint:r.contentHint,...pa(r.codec)}},Ni=r=>{if(!r||typeof r!="object")throw new TypeError("Encoding config must be an object.");if(!pe.includes(r.codec))throw new TypeError(`Invalid audio codec '${r.codec}'. Must be one of: ${pe.join(", ")}.`);if(r.bitrate===void 0&&(!Z.includes(r.codec)||r.codec==="flac"))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(r.bitrate!==void 0&&!(r.bitrate instanceof ge)&&(!Number.isInteger(r.bitrate)||r.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(r.onEncodedPacket!==void 0&&typeof r.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(r.onEncoderConfig!==void 0&&typeof r.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");Qn(r.codec,r)},Qn=(r,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&qs(e.fullCodecString)!==r)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${r}).`)},ki=r=>{const e=r.bitrate instanceof ge?r.bitrate._toAudioBitrate(r.codec):r.bitrate;return{codec:r.fullCodecString??fa(r.codec,r.numberOfChannels,r.sampleRate),numberOfChannels:r.numberOfChannels,sampleRate:r.sampleRate,bitrate:e,bitrateMode:r.bitrateMode,...ga(r.codec)}};class ge{constructor(e){this._factor=e}_toVideoBitrate(e,t,i){const s=t*i,n={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},a=1920*1080,o=3e6,c=Math.pow(s/a,.95),d=o*c*n[e]*this._factor;return Math.ceil(d/1e3)*1e3}_toAudioBitrate(e){if(Z.includes(e)||e==="flac")return;const i={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!i)throw new Error(`Unhandled codec: ${e}`);let s=i*this._factor;return e==="aac"?s=[96e3,128e3,16e4,192e3].reduce((a,o)=>Math.abs(o-s)<Math.abs(a-s)?o:a):e==="opus"||e==="vorbis"?s=Math.max(6e3,s):e==="mp3"&&(s=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((a,o)=>Math.abs(o-s)<Math.abs(a-s)?o:a)),Math.round(s/1e3)*1e3}}const fu=new ge(.3),mu=new ge(.6),pu=new ge(1),Cs=new ge(2),gu=new ge(4),wu=r=>{if(ce.includes(r))return Oi(r);if(pe.includes(r))return Vi(r);if(Ve.includes(r))return Wi(r);throw new TypeError(`Unknown codec '${r}'.`)},Oi=async(r,e={})=>{const{width:t=1280,height:i=720,bitrate:s=1e6,...n}=e;if(!ce.includes(r))return!1;if(!Number.isInteger(t)||t<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(i)||i<=0)throw new TypeError("height must be a positive integer.");if(!(s instanceof ge)&&(!Number.isInteger(s)||s<=0))throw new TypeError("bitrate must be a positive integer or a quality.");$n(r,n);let a=null;return Kt.length>0&&(a??=bi({codec:r,width:t,height:i,bitrate:s,framerate:void 0,...n}),Kt.some(l=>l.supports(r,a)))?!0:typeof VideoEncoder>"u"||(t%2===1||i%2===1)&&(r==="avc"||r==="hevc")||(a??=bi({codec:r,width:t,height:i,bitrate:s,framerate:void 0,...n,alpha:"discard"}),!(await VideoEncoder.isConfigSupported(a)).supported)?!1:Pt()?new Promise(async l=>{try{const u=new VideoEncoder({output:()=>{},error:()=>l(!1)});u.configure(a);const d=new Uint8Array(t*i*4),h=new VideoFrame(d,{format:"RGBA",codedWidth:t,codedHeight:i,timestamp:0});u.encode(h),h.close(),await u.flush(),l(!0)}catch{l(!1)}}):!0},Vi=async(r,e={})=>{const{numberOfChannels:t=2,sampleRate:i=48e3,bitrate:s=128e3,...n}=e;if(!pe.includes(r))return!1;if(!Number.isInteger(t)||t<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(i)||i<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(s instanceof ge)&&(!Number.isInteger(s)||s<=0))throw new TypeError("bitrate must be a positive integer.");Qn(r,n);let a=null;return Gt.length>0&&(a??=ki({codec:r,numberOfChannels:t,sampleRate:i,bitrate:s,...n}),Gt.some(c=>c.supports(r,a)))||Z.includes(r)?!0:typeof AudioEncoder>"u"?!1:(a??=ki({codec:r,numberOfChannels:t,sampleRate:i,bitrate:s,...n}),(await AudioEncoder.isConfigSupported(a)).supported===!0)},Wi=async r=>!!Ve.includes(r),bu=async()=>{const[r,e,t]=await Promise.all([Nl(),Ti(),Ol()]);return[...r,...e,...t]},Nl=async(r=ce,e)=>{const t=await Promise.all(r.map(i=>Oi(i,e)));return r.filter((i,s)=>t[s])},Ti=async(r=pe,e)=>{const t=await Promise.all(r.map(i=>Vi(i,e)));return r.filter((i,s)=>t[s])},Ol=async(r=Ve)=>{const e=await Promise.all(r.map(Wi));return r.filter((t,i)=>e[i])},Vl=async(r,e)=>{for(const t of r)if(await Oi(t,e))return t;return null},ku=async(r,e)=>{for(const t of r)if(await Vi(t,e))return t;return null},Tu=async r=>{for(const e of r)if(await Wi(e))return e;return null};class Li{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise?this._closingPromise:this._flushAndClose(e)}}class rr extends Li{constructor(e){if(super(),this._connectedTrack=null,!ce.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${ce.join(", ")}.`);this._codec=e}}class Wl extends rr{constructor(e){super(e)}add(e,t){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack,e,t)}}class Hi{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new vr,this.customEncoderQueueSize=0,this.alphaEncoder=null,this.splitter=null,this.splitterCreationFailed=!1,this.alphaFrameQueue=[],this.error=null,this.errorNeedsNewStack=!0}async add(e,t,i){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.codedWidth!==null&&this.codedHeight!==null){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const o=this.encodingConfig.sizeChangeBehavior??"deny";if(o!=="passThrough"){if(o==="deny")throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let c=!1;this.resizeCanvas||(typeof document<"u"?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),c=!0);const l=this.resizeCanvas.getContext("2d",{alpha:Pt()});m(l),c||(Pt()?(l.fillStyle="black",l.fillRect(0,0,this.codedWidth,this.codedHeight)):l.clearRect(0,0,this.codedWidth,this.codedHeight)),e.drawWithFit(l,{fit:o}),t&&e.close(),e=new ee(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),t=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized);const s=this.encodingConfig.keyFrameInterval??5,n=Math.floor(e.timestamp/s),a={...i,keyFrame:i?.keyFrame||s===0||n!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=n,this.customEncoder){this.customEncoderQueueSize++;const o=e.clone(),c=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(o,a)).then(()=>this.customEncoderQueueSize--).catch(l=>this.error??=l).finally(()=>{o.close()});this.customEncoderQueueSize>=4&&await c}else{m(this.encoder);const o=e.toVideoFrame();if(!this.alphaEncoder)this.encoder.encode(o,a),o.close();else if(!!o.format&&!o.format.includes("A")||this.splitterCreationFailed)this.alphaFrameQueue.push(null),this.encoder.encode(o,a),o.close();else{const l=o.displayWidth,u=o.displayHeight;if(!this.splitter)try{this.splitter=new Ll(l,u)}catch(d){console.error("Due to an error, only color data will be encoded.",d),this.splitterCreationFailed=!0,this.alphaFrameQueue.push(null),this.encoder.encode(o,a),o.close()}if(this.splitter){const d=this.splitter.extractColor(o),h=this.splitter.extractAlpha(o);this.alphaFrameQueue.push(h),this.encoder.encode(d,a),d.close(),o.close()}}t&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(c=>this.encoder.addEventListener("dequeue",c,{once:!0}))}await this.muxer.mutex.currentPromise}finally{t&&e.close()}}ensureEncoder(e){const t=new Error;this.ensureEncoderPromise=(async()=>{const i=bi({width:e.codedWidth,height:e.codedHeight,...this.encodingConfig,framerate:this.source._connectedTrack?.metadata.frameRate});this.encodingConfig.onEncoderConfig?.(i);const s=Kt.find(n=>n.supports(this.encodingConfig.codec,i));if(s)this.customEncoder=new s,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=i,this.customEncoder.onPacket=(n,a)=>{if(!(n instanceof $))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(a!==void 0&&(!a||typeof a!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(n,a),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,n,a).catch(o=>{this.error??=o,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(i.alpha="discard",this.encodingConfig.alpha==="keep"&&(i.latencyMode="quality"),(i.width%2===1||i.height%2===1)&&(this.encodingConfig.codec==="avc"||this.encodingConfig.codec==="hevc"))throw new Error(`The dimensions ${i.width}x${i.height} are not supported for codec '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to round your dimensions to the nearest even number.`);if(!(await VideoEncoder.isConfigSupported(i)).supported)throw new Error(`This specific encoder configuration (${i.codec}, ${i.bitrate} bps, ${i.width}x${i.height}, hardware acceleration: ${i.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);const o=[],c=[];let l=0,u=0;const d=(h,f,p)=>{const g={};if(f){const T=new Uint8Array(f.byteLength);f.copyTo(T),g.alpha=T}const w=$.fromEncodedChunk(h,g);this.encodingConfig.onEncodedPacket?.(w,p),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,w,p).catch(T=>{this.error??=T,this.errorNeedsNewStack=!1})};this.encoder=new VideoEncoder({output:(h,f)=>{if(!this.alphaEncoder){d(h,null,f);return}const p=this.alphaFrameQueue.shift();m(p!==void 0),p?(this.alphaEncoder.encode(p,{keyFrame:h.type==="key"}),u++,p.close(),o.push({chunk:h,meta:f})):u===0?d(h,null,f):(c.push(l+u),o.push({chunk:h,meta:f}))},error:h=>{h.stack=t.stack,this.error??=h}}),this.encoder.configure(i),this.encodingConfig.alpha==="keep"&&(this.alphaEncoder=new VideoEncoder({output:(h,f)=>{u--;const p=o.shift();for(m(p!==void 0),d(p.chunk,h,p.meta),l++;c.length>0&&c[0]===l;){c.shift();const g=o.shift();m(g!==void 0),d(g.chunk,null,g.meta)}},error:h=>{h.stack=t.stack,this.error??=h}}),this.alphaEncoder.configure(i))}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||(await this.encoder.flush(),await this.alphaEncoder?.flush()),this.encoder.state!=="closed"&&this.encoder.close(),this.alphaEncoder&&this.alphaEncoder.state!=="closed"&&this.alphaEncoder.close(),this.alphaFrameQueue.forEach(t=>t?.close()),this.splitter?.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class Ll{constructor(e,t){this.lastFrame=null,typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(e,t):(this.canvas=document.createElement("canvas"),this.canvas.width=e,this.canvas.height=t);const i=this.canvas.getContext("webgl2",{alpha:!0});if(!i)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=i,this.colorProgram=this.createColorProgram(),this.alphaProgram=this.createAlphaProgram(),this.vao=this.createVAO(),this.sourceTexture=this.createTexture(),this.alphaResolutionLocation=this.gl.getUniformLocation(this.alphaProgram,"u_resolution"),this.gl.useProgram(this.colorProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram,"u_sourceTexture"),0),this.gl.useProgram(this.alphaProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram,"u_sourceTexture"),0)}createVertexShader(){return this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`)}createColorProgram(){const e=this.createVertexShader(),t=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec4 source = texture(u_sourceTexture, v_texCoord);
				fragColor = vec4(source.rgb, 1.0);
			}
		`),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,t),this.gl.linkProgram(i),i}createAlphaProgram(){const e=this.createVertexShader(),t=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			uniform vec2 u_resolution; // The width and height of the canvas
			in vec2 v_texCoord;
			out vec4 fragColor;

			// This function determines the value for a single byte in the YUV stream
			float getByteValue(float byteOffset) {
				float width = u_resolution.x;
				float height = u_resolution.y;

				float yPlaneSize = width * height;

				if (byteOffset < yPlaneSize) {
					// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from
					float y = floor(byteOffset / width);
					float x = mod(byteOffset, width);
					
					// Add 0.5 to sample the center of the texel
					vec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;
					
					// The luma value is the alpha from the source texture
					return texture(u_sourceTexture, sampleCoord).a;
				} else {
					// Write a fixed value for chroma and beyond
					return 128.0 / 255.0;
				}
			}
			
			void main() {
				// Each fragment writes 4 bytes (R, G, B, A)
				float pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);
				float baseByteOffset = pixelIndex * 4.0;

				vec4 result;
				for (int i = 0; i < 4; i++) {
					float currentByteOffset = baseByteOffset + float(i);
					result[i] = getByteValue(currentByteOffset);
				}
				
				fragColor = result;
			}
		`),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,t),this.gl.linkProgram(i),i}createShader(e,t){const i=this.gl.createShader(e);return this.gl.shaderSource(i,t),this.gl.compileShader(i),this.gl.getShaderParameter(i,this.gl.COMPILE_STATUS)||console.error("Shader compile error:",this.gl.getShaderInfoLog(i)),i}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const t=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),i=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,i),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.STATIC_DRAW);const s=this.gl.getAttribLocation(this.colorProgram,"a_position"),n=this.gl.getAttribLocation(this.colorProgram,"a_texCoord");return this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}updateTexture(e){this.lastFrame!==e&&((e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.sourceTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.lastFrame=e)}extractColor(e){return this.updateTexture(e),this.gl.useProgram(this.colorProgram),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),new VideoFrame(this.canvas,{timestamp:e.timestamp,duration:e.duration??void 0,alpha:"discard"})}extractAlpha(e){this.updateTexture(e),this.gl.useProgram(this.alphaProgram),this.gl.uniform2f(this.alphaResolutionLocation,this.canvas.width,this.canvas.height),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const{width:t,height:i}=this.canvas,s=Math.ceil(t/2)*Math.ceil(i/2),n=t*i+s*2,a=Math.ceil(n/(t*4));let o=new Uint8Array(4*t*a);this.gl.readPixels(0,0,t,a,this.gl.RGBA,this.gl.UNSIGNED_BYTE,o),o=o.subarray(0,n),m(o[t*i]===128),m(o[o.length-1]===128);const c={format:"I420",codedWidth:t,codedHeight:i,timestamp:e.timestamp,duration:e.duration??void 0,transfer:[o.buffer]};return new VideoFrame(o,c)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class _s extends rr{constructor(e){Ui(e),super(e.codec),this._encoder=new Hi(this,e)}add(e,t){if(!(e instanceof ee))throw new TypeError("videoSample must be a VideoSample.");return this._encoder.add(e,!1,t)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class yu extends rr{constructor(e,t){if(!(typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement)&&!(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas))throw new TypeError("canvas must be an HTMLCanvasElement or OffscreenCanvas.");Ui(t),super(t.codec),this._encoder=new Hi(this,t),this._canvas=e}add(e,t=0,i){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(t)||t<0)throw new TypeError("duration must be a non-negative number.");const s=new ee(this._canvas,{timestamp:e,duration:t});return this._encoder.add(s,!0,i)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Su extends rr{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="video")throw new TypeError("track must be a video MediaStreamTrack.");Ui(t),t={...t,latencyMode:"realtime"},super(t.codec),this._abortController=null,this._workerTrackId=null,this._workerListener=null,this._promiseWithResolvers=G(),this._errorPromiseAccessed=!1,this._encoder=new Hi(this,t),this._track=e}async _start(){this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController;let e=null,t=!1;const i=s=>{if(t){s.close();return}if(e===null){e=s.timestamp/1e6;const n=this._connectedTrack.output._muxer;n.firstMediaStreamTimestamp===null?(n.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-n.firstMediaStreamTimestamp-e}if(this._encoder.getQueueSize()>=4){s.close();return}this._encoder.add(new ee(s),!0).catch(n=>{t=!0,this._abortController?.abort(),this._promiseWithResolvers.reject(n),this._workerTrackId!==null&&Qr({type:"stopTrack",trackId:this._workerTrackId})})};if(typeof MediaStreamTrackProcessor<"u"){const s=new MediaStreamTrackProcessor({track:this._track}),n=new WritableStream({write:i});s.readable.pipeTo(n,{signal:this._abortController.signal}).catch(a=>{a instanceof DOMException&&a.name==="AbortError"||this._promiseWithResolvers.reject(a)})}else if(await Ql())this._workerTrackId=jl++,Qr({type:"videoTrack",trackId:this._workerTrackId,track:this._track}),this._workerListener=n=>{const a=n.data;a.type==="videoFrame"&&a.trackId===this._workerTrackId?i(a.videoFrame):a.type==="error"&&a.trackId===this._workerTrackId&&this._promiseWithResolvers.reject(a.error)},_e.addEventListener("message",this._workerListener);else throw new Error("MediaStreamTrackProcessor is required but not supported by this browser.")}async _flushAndClose(e){this._abortController&&(this._abortController.abort(),this._abortController=null),this._workerTrackId!==null&&(m(this._workerListener),Qr({type:"stopTrack",trackId:this._workerTrackId}),await new Promise(t=>{const i=s=>{const n=s.data;n.type==="trackStopped"&&n.trackId===this._workerTrackId&&(m(this._workerListener),_e.removeEventListener("message",this._workerListener),_e.removeEventListener("message",i),t())};_e.addEventListener("message",i)})),await this._encoder.flushAndClose(e)}}class ir extends Li{constructor(e){if(super(),this._connectedTrack=null,!pe.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${pe.join(", ")}.`);this._codec=e}}class Hl extends ir{constructor(e){super(e)}add(e,t){if(!(e instanceof $))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack,e,t)}}class qi{constructor(e,t){this.source=e,this.encodingConfig=t,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new vr,this.customEncoderQueueSize=0,this.lastEndSampleIndex=null,this.error=null,this.errorNeedsNewStack=!0}async add(e,t){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized);{const i=Math.round(e.timestamp*e.sampleRate),s=Math.round((e.timestamp+e.duration)*e.sampleRate);if(this.lastEndSampleIndex===null)this.lastEndSampleIndex=s;else{const n=i-this.lastEndSampleIndex;if(n>=64){const a=new ne({data:new Float32Array(n*e.numberOfChannels),format:"f32-planar",sampleRate:e.sampleRate,numberOfChannels:e.numberOfChannels,numberOfFrames:n,timestamp:this.lastEndSampleIndex/e.sampleRate});await this.add(a,!0)}this.lastEndSampleIndex+=e.numberOfFrames}}if(this.customEncoder){this.customEncoderQueueSize++;const i=e.clone(),s=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(i)).then(()=>this.customEncoderQueueSize--).catch(n=>this.error??=n).finally(()=>{i.close()});this.customEncoderQueueSize>=4&&await s,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(e,t);else{m(this.encoder);const i=e.toAudioData();this.encoder.encode(i),i.close(),t&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(s=>this.encoder.addEventListener("dequeue",s,{once:!0})),await this.muxer.mutex.currentPromise}}finally{t&&e.close()}}async doPcmEncoding(e,t){m(this.outputSampleSize),m(this.writeOutputValue);const{numberOfChannels:i,numberOfFrames:s,sampleRate:n,timestamp:a}=e,o=2048,c=[];for(let h=0;h<s;h+=o){const f=Math.min(o,e.numberOfFrames-h),p=f*i*this.outputSampleSize,g=new ArrayBuffer(p),w=new DataView(g);c.push({frameCount:f,view:w})}const l=e.allocationSize({planeIndex:0,format:"f32-planar"}),u=new Float32Array(l/Float32Array.BYTES_PER_ELEMENT);for(let h=0;h<i;h++){e.copyTo(u,{planeIndex:h,format:"f32-planar"});for(let f=0;f<c.length;f++){const{frameCount:p,view:g}=c[f];for(let w=0;w<p;w++)this.writeOutputValue(g,(w*i+h)*this.outputSampleSize,u[f*o+w])}}t&&e.close();const d={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:i,sampleRate:n}};for(let h=0;h<c.length;h++){const{frameCount:f,view:p}=c[h],g=p.buffer,w=h*o,T=new $(new Uint8Array(g),"key",a+w/n,f/n);this.encodingConfig.onEncodedPacket?.(T,d),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,T,d)}}ensureEncoder(e){const t=new Error;this.ensureEncoderPromise=(async()=>{const{numberOfChannels:i,sampleRate:s}=e,n=ki({numberOfChannels:i,sampleRate:s,...this.encodingConfig});this.encodingConfig.onEncoderConfig?.(n);const a=Gt.find(o=>o.supports(this.encodingConfig.codec,n));if(a)this.customEncoder=new a,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=n,this.customEncoder.onPacket=(o,c)=>{if(!(o instanceof $))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(c!==void 0&&(!c||typeof c!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(o,c),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,o,c).catch(l=>{this.error??=l,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else if(Z.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if(typeof AudioEncoder>"u")throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(n)).supported)throw new Error(`This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.numberOfChannels} channels, ${n.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(c,l)=>{if(this.encodingConfig.codec==="aac"&&l?.decoderConfig){let d=!1;if(!l.decoderConfig.description||l.decoderConfig.description.byteLength<2?d=!0:d=Ir(K(l.decoderConfig.description)).objectType===0,d){const h=Number(X(n.codec.split(".")));l.decoderConfig.description=ma({objectType:h,numberOfChannels:l.decoderConfig.numberOfChannels,sampleRate:l.decoderConfig.sampleRate})}}const u=$.fromEncodedChunk(c);this.encodingConfig.onEncodedPacket?.(u,l),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,u,l).catch(d=>{this.error??=d,this.errorNeedsNewStack=!1})},error:c=>{c.stack=t.stack,this.error??=c}}),this.encoder.configure(n)}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:t,sampleSize:i,littleEndian:s}=Ae(e);switch(this.outputSampleSize=i,i){case 1:t==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint8(a,J((o+1)*127.5,0,255)):t==="signed"?this.writeOutputValue=(n,a,o)=>{n.setInt8(a,J(Math.round(o*128),-128,127))}:t==="ulaw"?this.writeOutputValue=(n,a,o)=>{const c=J(Math.floor(o*32767),-32768,32767);n.setUint8(a,Wa(c))}:t==="alaw"?this.writeOutputValue=(n,a,o)=>{const c=J(Math.floor(o*32767),-32768,32767);n.setUint8(a,Ha(c))}:m(!1);break;case 2:t==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint16(a,J((o+1)*32767.5,0,65535),s):t==="signed"?this.writeOutputValue=(n,a,o)=>n.setInt16(a,J(Math.round(o*32767),-32768,32767),s):m(!1);break;case 3:t==="unsigned"?this.writeOutputValue=(n,a,o)=>Us(n,a,J((o+1)*83886075e-1,0,16777215),s):t==="signed"?this.writeOutputValue=(n,a,o)=>ea(n,a,J(Math.round(o*8388607),-8388608,8388607),s):m(!1);break;case 4:t==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint32(a,J((o+1)*21474836475e-1,0,4294967295),s):t==="signed"?this.writeOutputValue=(n,a,o)=>n.setInt32(a,J(Math.round(o*2147483647),-2147483648,2147483647),s):t==="float"?this.writeOutputValue=(n,a,o)=>n.setFloat32(a,o,s):m(!1);break;case 8:t==="float"?this.writeOutputValue=(n,a,o)=>n.setFloat64(a,o,s):m(!1);break;default:ae(i),m(!1)}}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.state!=="closed"&&this.encoder.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class Ps extends ir{constructor(e){Ni(e),super(e.codec),this._encoder=new qi(this,e)}add(e){if(!(e instanceof ne))throw new TypeError("audioSample must be an AudioSample.");return this._encoder.add(e,!1)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class xu extends ir{constructor(e){Ni(e),super(e.codec),this._accumulatedTime=0,this._encoder=new qi(this,e)}async add(e){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const t=ne._fromAudioBuffer(e,this._accumulatedTime);this._accumulatedTime+=e.duration;for(const i of t)await this._encoder.add(i,!0)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class Cu extends ir{get errorPromise(){return this._errorPromiseAccessed=!0,this._promiseWithResolvers.promise}constructor(e,t){if(!(e instanceof MediaStreamTrack)||e.kind!=="audio")throw new TypeError("track must be an audio MediaStreamTrack.");Ni(t),super(t.codec),this._abortController=null,this._audioContext=null,this._scriptProcessorNode=null,this._promiseWithResolvers=G(),this._errorPromiseAccessed=!1,this._encoder=new qi(this,t),this._track=e}async _start(){if(this._errorPromiseAccessed||console.warn("Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal errors get bubbled up properly."),this._abortController=new AbortController,typeof MediaStreamTrackProcessor<"u"){let e=null;const t=new MediaStreamTrackProcessor({track:this._track}),i=new WritableStream({write:s=>{if(e===null){e=s.timestamp/1e6;const n=this._connectedTrack.output._muxer;n.firstMediaStreamTimestamp===null?(n.firstMediaStreamTimestamp=performance.now()/1e3,this._timestampOffset=-e):this._timestampOffset=performance.now()/1e3-n.firstMediaStreamTimestamp-e}if(this._encoder.getQueueSize()>=4){s.close();return}this._encoder.add(new ne(s),!0).catch(n=>{this._abortController?.abort(),this._promiseWithResolvers.reject(n)})}});t.readable.pipeTo(i,{signal:this._abortController.signal}).catch(s=>{s instanceof DOMException&&s.name==="AbortError"||this._promiseWithResolvers.reject(s)})}else{const e=window.AudioContext||window.webkitAudioContext;this._audioContext=new e({sampleRate:this._track.getSettings().sampleRate});const t=this._audioContext.createMediaStreamSource(new MediaStream([this._track]));this._scriptProcessorNode=this._audioContext.createScriptProcessor(4096),this._audioContext.state==="suspended"&&await this._audioContext.resume(),t.connect(this._scriptProcessorNode),this._scriptProcessorNode.connect(this._audioContext.destination);let i=!1,s=0;this._scriptProcessorNode.onaudioprocess=n=>{const a=ne._fromAudioBuffer(n.inputBuffer,s);s+=n.inputBuffer.duration;for(const o of a){if(!i){i=!0;const c=this._connectedTrack.output._muxer;c.firstMediaStreamTimestamp===null?c.firstMediaStreamTimestamp=performance.now()/1e3:this._timestampOffset=performance.now()/1e3-c.firstMediaStreamTimestamp}if(this._encoder.getQueueSize()>=4){o.close();continue}this._encoder.add(o,!0).catch(c=>{this._audioContext.suspend(),this._promiseWithResolvers.reject(c)})}}}}async _flushAndClose(e){this._abortController&&(this._abortController.abort(),this._abortController=null),this._audioContext&&(m(this._scriptProcessorNode),this._scriptProcessorNode.disconnect(),await this._audioContext.suspend()),await this._encoder.flushAndClose(e)}}const ql=()=>{const r=(i,s)=>{s?self.postMessage(i,{transfer:s}):self.postMessage(i)};r({type:"support",supported:typeof MediaStreamTrackProcessor<"u"});const e=new Map,t=new Map;self.addEventListener("message",i=>{const s=i.data;switch(s.type){case"videoTrack":{t.set(s.trackId,s.track);const n=new MediaStreamTrackProcessor({track:s.track}),a=new WritableStream({write:c=>{if(!t.has(s.trackId)){c.close();return}r({type:"videoFrame",trackId:s.trackId,videoFrame:c},[c])}}),o=new AbortController;e.set(s.trackId,o),n.readable.pipeTo(a,{signal:o.signal}).catch(c=>{c instanceof DOMException&&c.name==="AbortError"||r({type:"error",trackId:s.trackId,error:c})})}break;case"stopTrack":{const n=e.get(s.trackId);n&&(n.abort(),e.delete(s.trackId)),t.get(s.trackId)?.stop(),t.delete(s.trackId),r({type:"trackStopped",trackId:s.trackId})}break;default:ae(s)}})};let jl=0,_e=null;const $l=()=>{const r=new Blob([`(${ql.toString()})()`],{type:"application/javascript"}),e=URL.createObjectURL(r);_e=new Worker(e)};let $r=null;const Ql=async()=>$r!==null?$r:(_e||$l(),new Promise(r=>{m(_e);const e=t=>{const i=t.data;i.type==="support"&&($r=i.supported,_e.removeEventListener("message",e),r(i.supported))};_e.addEventListener("message",e)})),Qr=(r,e)=>{m(_e),_e.postMessage(r)};class Kn extends Li{constructor(e){if(super(),this._connectedTrack=null,!Ve.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${Ve.join(", ")}.`);this._codec=e}}class _u extends Kn{constructor(e){super(e),this._error=null,this._parser=new lc({codec:e,output:(t,i)=>{this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack,t,i).catch(s=>{this._error??=s})}})}add(e){if(typeof e!="string")throw new TypeError("text must be a string.");return this._checkForError(),this._ensureValidAdd(),this._parser.parse(e),this._connectedTrack.output._muxer.mutex.currentPromise}_checkForError(){if(this._error)throw this._error}async _flushAndClose(e){e||this._checkForError()}}const Kl=["video","audio","subtitle"],Kr=r=>{if(!r||typeof r!="object")throw new TypeError("metadata must be an object.");if(r.languageCode!==void 0&&!$t(r.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(r.name!==void 0&&typeof r.name!="string")throw new TypeError("metadata.name, when provided, must be a string.");if(r.disposition!==void 0&&ua(r.disposition),r.maximumPacketCount!==void 0&&(!Number.isInteger(r.maximumPacketCount)||r.maximumPacketCount<0))throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.")};class vs{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new At,this._metadataTags={},!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof Ze))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof tr))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,t={}){if(!(e instanceof rr))throw new TypeError("source must be a VideoSource.");if(Kr(t),t.rotation!==void 0&&![0,90,180,270].includes(t.rotation))throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&t.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(t.frameRate!==void 0&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive number.`);this._addTrack("video",e,t)}addAudioTrack(e,t={}){if(!(e instanceof ir))throw new TypeError("source must be an AudioSource.");Kr(t),this._addTrack("audio",e,t)}addSubtitleTrack(e,t={}){if(!(e instanceof Kn))throw new TypeError("source must be a SubtitleSource.");Kr(t),this._addTrack("subtitle",e,t)}setMetadataTags(e){if(Jr(e),this.state!=="pending")throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,t,i){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(t._connectedTrack)throw new Error("Source is already used for a track.");const s=this.format.getSupportedTrackCounts(),n=this._tracks.reduce((l,u)=>l+(u.type===e?1:0),0),a=s[e].max;if(n===a)throw new Error(a===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${a} ${e} track${a===1?"":"s"}.`);const o=s.total.max;if(this._tracks.length===o)throw new Error(`${this.format._name} does not support more than ${o} tracks${o===1?"":"s"} in total.`);const c={id:this._tracks.length+1,output:this,type:e,source:t,metadata:i};if(c.type==="video"){const l=this.format.getSupportedVideoCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="audio"){const l=this.format.getSupportedAudioCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="subtitle"){const l=this.format.getSupportedSubtitleCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}this._tracks.push(c),t._connectedTrack=c}async start(){const e=this.format.getSupportedTrackCounts();for(const i of Kl){const s=this._tracks.reduce((a,o)=>a+(o.type===i?1:0),0),n=e[i].min;if(s<n)throw new Error(n===e[i].max?`${this.format._name} requires exactly ${n} ${i} track${n===1?"":"s"}.`:`${this.format._name} requires at least ${n} ${i} track${n===1?"":"s"}.`)}const t=e.total.min;if(this._tracks.length<t)throw new Error(t===e.total.max?`${this.format._name} requires exactly ${t} track${t===1?"":"s"}.`:`${this.format._name} requires at least ${t} track${t===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const i=await this._mutex.acquire();await this._muxer.start();const s=this._tracks.map(n=>n.source._start());await Promise.all(s),i()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),t=this._tracks.map(i=>i.source._flushOrWaitForOngoingClose(!0));await Promise.all(t),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),t=this._tracks.map(i=>i.source._flushOrWaitForOngoingClose(!1));await Promise.all(t),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}const Is=r=>{if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("options.video, when provided, must be an object.");if(r?.discard!==void 0&&typeof r.discard!="boolean")throw new TypeError("options.video.discard, when provided, must be a boolean.");if(r?.forceTranscode!==void 0&&typeof r.forceTranscode!="boolean")throw new TypeError("options.video.forceTranscode, when provided, must be a boolean.");if(r?.codec!==void 0&&!ce.includes(r.codec))throw new TypeError(`options.video.codec, when provided, must be one of: ${ce.join(", ")}.`);if(r?.bitrate!==void 0&&!(r.bitrate instanceof ge)&&(!Number.isInteger(r.bitrate)||r.bitrate<=0))throw new TypeError("options.video.bitrate, when provided, must be a positive integer or a quality.");if(r?.width!==void 0&&(!Number.isInteger(r.width)||r.width<=0))throw new TypeError("options.video.width, when provided, must be a positive integer.");if(r?.height!==void 0&&(!Number.isInteger(r.height)||r.height<=0))throw new TypeError("options.video.height, when provided, must be a positive integer.");if(r?.fit!==void 0&&!["fill","contain","cover"].includes(r.fit))throw new TypeError("options.video.fit, when provided, must be one of 'fill', 'contain', or 'cover'.");if(r?.width!==void 0&&r.height!==void 0&&r.fit===void 0)throw new TypeError("When both options.video.width and options.video.height are provided, options.video.fit must also be provided.");if(r?.rotate!==void 0&&![0,90,180,270].includes(r.rotate))throw new TypeError("options.video.rotate, when provided, must be 0, 90, 180 or 270.");if(r?.crop!==void 0&&_i(r.crop,"options.video."),r?.frameRate!==void 0&&(!Number.isFinite(r.frameRate)||r.frameRate<=0))throw new TypeError("options.video.frameRate, when provided, must be a finite positive number.");if(r?.alpha!==void 0&&!["discard","keep"].includes(r.alpha))throw new TypeError("options.video.alpha, when provided, must be either 'discard' or 'keep'.");if(r?.keyFrameInterval!==void 0&&(!Number.isFinite(r.keyFrameInterval)||r.keyFrameInterval<0))throw new TypeError("options.video.keyFrameInterval, when provided, must be a non-negative number.");if(r?.process!==void 0&&typeof r.process!="function")throw new TypeError("options.video.process, when provided, must be a function.");if(r?.processedWidth!==void 0&&(!Number.isInteger(r.processedWidth)||r.processedWidth<=0))throw new TypeError("options.video.processedWidth, when provided, must be a positive integer.");if(r?.processedHeight!==void 0&&(!Number.isInteger(r.processedHeight)||r.processedHeight<=0))throw new TypeError("options.video.processedHeight, when provided, must be a positive integer.")},Es=r=>{if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("options.audio, when provided, must be an object.");if(r?.discard!==void 0&&typeof r.discard!="boolean")throw new TypeError("options.audio.discard, when provided, must be a boolean.");if(r?.forceTranscode!==void 0&&typeof r.forceTranscode!="boolean")throw new TypeError("options.audio.forceTranscode, when provided, must be a boolean.");if(r?.codec!==void 0&&!pe.includes(r.codec))throw new TypeError(`options.audio.codec, when provided, must be one of: ${pe.join(", ")}.`);if(r?.bitrate!==void 0&&!(r.bitrate instanceof ge)&&(!Number.isInteger(r.bitrate)||r.bitrate<=0))throw new TypeError("options.audio.bitrate, when provided, must be a positive integer or a quality.");if(r?.numberOfChannels!==void 0&&(!Number.isInteger(r.numberOfChannels)||r.numberOfChannels<=0))throw new TypeError("options.audio.numberOfChannels, when provided, must be a positive integer.");if(r?.sampleRate!==void 0&&(!Number.isInteger(r.sampleRate)||r.sampleRate<=0))throw new TypeError("options.audio.sampleRate, when provided, must be a positive integer.");if(r?.process!==void 0&&typeof r.process!="function")throw new TypeError("options.audio.process, when provided, must be a function.");if(r?.processedNumberOfChannels!==void 0&&(!Number.isInteger(r.processedNumberOfChannels)||r.processedNumberOfChannels<=0))throw new TypeError("options.audio.processedNumberOfChannels, when provided, must be a positive integer.");if(r?.processedSampleRate!==void 0&&(!Number.isInteger(r.processedSampleRate)||r.processedSampleRate<=0))throw new TypeError("options.audio.processedSampleRate, when provided, must be a positive integer.")},Gr=2,Xr=48e3;class Gn{static async init(e){const t=new Gn(e);return await t._init(),t}constructor(e){if(this._addedCounts={video:0,audio:0,subtitle:0},this._totalTrackCount=0,this._trackPromises=[],this._executed=!1,this._synchronizer=new Gl,this._totalDuration=null,this._maxTimestamps=new Map,this._canceled=!1,this.onProgress=void 0,this._computeProgress=!1,this._lastProgress=0,this.isValid=!1,this.utilizedTracks=[],this.discardedTracks=[],!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.input instanceof Jo))throw new TypeError("options.input must be an Input.");if(!(e.output instanceof vs))throw new TypeError("options.output must be an Output.");if(e.output._tracks.length>0||Object.keys(e.output._metadataTags).length>0||e.output.state!=="pending")throw new TypeError("options.output must be fresh: no tracks or metadata tags added and not started.");if(typeof e.video!="function"&&Is(e.video),typeof e.audio!="function"&&Es(e.audio),e.trim!==void 0&&(!e.trim||typeof e.trim!="object"))throw new TypeError("options.trim, when provided, must be an object.");if(e.trim?.start!==void 0&&(!Number.isFinite(e.trim.start)||e.trim.start<0))throw new TypeError("options.trim.start, when provided, must be a non-negative number.");if(e.trim?.end!==void 0&&(!Number.isFinite(e.trim.end)||e.trim.end<0))throw new TypeError("options.trim.end, when provided, must be a non-negative number.");if(e.trim?.start!==void 0&&e.trim.end!==void 0&&e.trim.start>=e.trim.end)throw new TypeError("options.trim.start must be less than options.trim.end.");if(e.tags!==void 0&&(typeof e.tags!="object"||!e.tags)&&typeof e.tags!="function")throw new TypeError("options.tags, when provided, must be an object or a function.");if(typeof e.tags=="object"&&Jr(e.tags),e.showWarnings!==void 0&&typeof e.showWarnings!="boolean")throw new TypeError("options.showWarnings, when provided, must be a boolean.");this._options=e,this.input=e.input,this.output=e.output,this._startTimestamp=e.trim?.start??0,this._endTimestamp=e.trim?.end??1/0;const{promise:t,resolve:i}=G();this._started=t,this._start=i}async _init(){const e=await this.input.getTracks(),t=this.output.format.getSupportedTrackCounts();let i=1,s=1;for(const l of e){let u;if(l.isVideoTrack()?this._options.video&&(typeof this._options.video=="function"?(u=await this._options.video(l,i),Is(u),i++):u=this._options.video):l.isAudioTrack()?this._options.audio&&(typeof this._options.audio=="function"?(u=await this._options.audio(l,s),Es(u),s++):u=this._options.audio):m(!1),u?.discard){this.discardedTracks.push({track:l,reason:"discarded_by_user"});continue}if(this._totalTrackCount===t.total.max){this.discardedTracks.push({track:l,reason:"max_track_count_reached"});continue}if(this._addedCounts[l.type]===t[l.type].max){this.discardedTracks.push({track:l,reason:"max_track_count_of_type_reached"});continue}l.isVideoTrack()?await this._processVideoTrack(l,u??{}):l.isAudioTrack()&&await this._processAudioTrack(l,u??{})}const n=await this.input.getMetadataTags();let a;if(this._options.tags){const l=typeof this._options.tags=="function"?await this._options.tags(n):this._options.tags;Jr(l),a=l}else a=n;const o=(await this.input.getFormat()).mimeType===this.output.format.mimeType,c=n.raw===a.raw;if(n.raw&&c&&!o&&delete a.raw,this.output.setMetadataTags(a),this.isValid=this._totalTrackCount>=t.total.min&&this._addedCounts.video>=t.video.min&&this._addedCounts.audio>=t.audio.min&&this._addedCounts.subtitle>=t.subtitle.min,this._options.showWarnings??!0){const l=[],u=this.discardedTracks.filter(d=>d.reason!=="discarded_by_user");u.length>0&&l.push("Some tracks had to be discarded from the conversion:",u),this.isValid||l.push(`

`+this._getInvalidityExplanation().join("")),l.length>0&&console.warn(...l)}}_getInvalidityExplanation(){const e=[];if(this.discardedTracks.length===0)e.push("Due to missing tracks, this conversion cannot be executed.");else{const t=this.discardedTracks.every(i=>i.reason==="discarded_by_user"||i.reason==="no_encodable_target_codec");if(e.push("Due to discarded tracks, this conversion cannot be executed."),t){const i=this.discardedTracks.flatMap(s=>s.reason==="discarded_by_user"?[]:s.track.type==="video"?this.output.format.getSupportedVideoCodecs():s.track.type==="audio"?this.output.format.getSupportedAudioCodecs():this.output.format.getSupportedSubtitleCodecs());i.length===1?e.push(`
Tracks were discarded because your environment is not able to encode '${i[0]}'.`):e.push(`
Tracks were discarded because your environment is not able to encode any of the following codecs: ${i.map(s=>`'${s}'`).join(", ")}.`),i.includes("mp3")&&e.push(`
The @mediabunny/mp3-encoder extension package provides support for encoding MP3.`)}else e.push(`
Check the discardedTracks field for more info.`)}return e}async execute(){if(!this.isValid)throw new Error(`Cannot execute this conversion because its output configuration is invalid. Make sure to always check the isValid field before executing a conversion.
`+this._getInvalidityExplanation().join(""));if(this._executed)throw new Error("Conversion cannot be executed twice.");if(this._executed=!0,this.onProgress){this._computeProgress=!0,this._totalDuration=Math.min(await this.input.computeDuration()-this._startTimestamp,this._endTimestamp-this._startTimestamp);for(const e of this.utilizedTracks)this._maxTimestamps.set(e.id,0);this.onProgress?.(0)}await this.output.start(),this._start();try{await Promise.all(this._trackPromises)}catch(e){throw this._canceled||this.cancel(),e}this._canceled&&await new Promise(()=>{}),await this.output.finalize(),this._computeProgress&&this.onProgress?.(1)}async cancel(){if(!(this.output.state==="finalizing"||this.output.state==="finalized")){if(this._canceled){console.warn("Conversion already canceled.");return}this._canceled=!0,await this.output.cancel()}}async _processVideoTrack(e,t){const i=e.codec;if(!i){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let s;const n=xr(e.rotation+(t.rotate??0)),a=this.output.format.supportsVideoRotationMetadata,[o,c]=n%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],l=t.crop;l&&Ci(l,o,c);const[u,d]=l?[l.width,l.height]:[o,c];let h=u,f=d;const p=h/f,g=x=>Math.ceil(x/2)*2;t.width!==void 0&&t.height===void 0?(h=g(t.width),f=g(Math.round(h/p))):t.width===void 0&&t.height!==void 0?(f=g(t.height),h=g(Math.round(f*p))):t.width!==void 0&&t.height!==void 0&&(h=g(t.width),f=g(t.height));const w=await e.getFirstTimestamp(),T=!!t.forceTranscode||this._startTimestamp>0||w<0||!!t.frameRate||t.keyFrameInterval!==void 0||t.process!==void 0;let k=h!==u||f!==d||n!==0&&(!a||t.process!==void 0)||!!l;const S=t.alpha??"discard";let y=this.output.format.getSupportedVideoCodecs();if(!T&&!t.bitrate&&!k&&y.includes(i)&&(!t.codec||t.codec===i)){const x=new Wl(i);s=x,this._trackPromises.push((async()=>{await this._started;const v=new Yt(e),P={decoderConfig:await e.getDecoderConfig()??void 0},A=Number.isFinite(this._endTimestamp)?await v.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const R of v.packets(void 0,A,{verifyKeyPackets:!0})){if(this._canceled)return;S==="discard"&&(delete R.sideData.alpha,delete R.sideData.alphaByteLength),this._reportProgress(e.id,R.timestamp),await x.add(R,P),this._synchronizer.shouldWait(e.id,R.timestamp)&&await this._synchronizer.wait(R.timestamp)}x.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}t.codec&&(y=y.filter(R=>R===t.codec));const v=t.bitrate??Cs,C=await Vl(y,{width:t.process&&t.processedWidth?t.processedWidth:h,height:t.process&&t.processedHeight?t.processedHeight:f,bitrate:v});if(!C){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}const P={codec:C,bitrate:v,keyFrameInterval:t.keyFrameInterval,sizeChangeBehavior:t.fit??"passThrough",alpha:S},A=new _s(P);if(s=A,!k){const R=new vs({format:new qn,target:new Cl}),F=new _s(P);R.addVideoTrack(F),await R.start();const q=await new ri(e).getSample(w);if(q)try{await F.add(q),q.close(),await R.finalize()}catch(we){console.info("Error when probing encoder support. Falling back to rerender path.",we),k=!0,R.cancel()}else await R.cancel()}k?this._trackPromises.push((async()=>{await this._started;const F=new Ga(e,{width:h,height:f,fit:t.fit??"fill",rotation:n,crop:t.crop,poolSize:1,alpha:S==="keep"}).canvases(this._startTimestamp,this._endTimestamp),U=t.frameRate;let q=null,we=null,ut=null;const ue=async de=>{m(q),m(U!==void 0);const be=Math.round((de-we)*U);for(let dt=1;dt<be;dt++){const We=new ee(q,{timestamp:we+dt/U,duration:1/U});await this._registerVideoSample(e,t,A,We),We.close()}};for await(const{canvas:de,timestamp:be,duration:dt}of F){if(this._canceled)return;let We=Math.max(be-this._startTimestamp,0);if(ut=We+dt,U!==void 0){const sr=Math.floor(We*U)/U;if(q!==null)if(sr<=we){q=de,we=sr;continue}else await ue(sr);We=sr}const ji=new ee(de,{timestamp:We,duration:U!==void 0?1/U:dt});await this._registerVideoSample(e,t,A,ji),ji.close(),U!==void 0&&(q=de,we=We)}q&&(m(ut!==null),m(U!==void 0),await ue(Math.floor(ut*U)/U)),A.close(),this._synchronizer.closeTrack(e.id)})()):this._trackPromises.push((async()=>{await this._started;const R=new ri(e),F=t.frameRate;let U=null,q=null,we=null;const ut=async ue=>{m(U),m(F!==void 0);const de=Math.round((ue-q)*F);for(let be=1;be<de;be++)U.setTimestamp(q+be/F),U.setDuration(1/F),await this._registerVideoSample(e,t,A,U);U.close()};for await(const ue of R.samples(this._startTimestamp,this._endTimestamp)){if(this._canceled){U?.close();return}let de=Math.max(ue.timestamp-this._startTimestamp,0);if(we=de+ue.duration,F!==void 0){const be=Math.floor(de*F)/F;if(U!==null)if(be<=q){U.close(),U=ue,q=be;continue}else await ut(be);de=be,ue.setDuration(1/F)}ue.setTimestamp(de),await this._registerVideoSample(e,t,A,ue),F!==void 0?(U=ue,q=de):ue.close()}U&&(m(we!==null),m(F!==void 0),await ut(Math.floor(we*F)/F)),A.close(),this._synchronizer.closeTrack(e.id)})())}this.output.addVideoTrack(s,{frameRate:t.frameRate,languageCode:$t(e.languageCode)?e.languageCode:void 0,name:e.name??void 0,disposition:e.disposition,rotation:k?0:n}),this._addedCounts.video++,this._totalTrackCount++,this.utilizedTracks.push(e)}async _registerVideoSample(e,t,i,s){if(this._canceled)return;this._reportProgress(e.id,s.timestamp);let n;if(!t.process)n=[s];else{let a=t.process(s);a instanceof Promise&&(a=await a),Array.isArray(a)||(a=a===null?[]:[a]),n=a.map(o=>o instanceof ee?o:typeof VideoFrame<"u"&&o instanceof VideoFrame?new ee(o):new ee(o,{timestamp:s.timestamp,duration:s.duration}))}for(const a of n){if(this._canceled)break;await i.add(a),this._synchronizer.shouldWait(e.id,a.timestamp)&&await this._synchronizer.wait(a.timestamp)}for(const a of n)a!==s&&a.close()}async _processAudioTrack(e,t){const i=e.codec;if(!i){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let s;const n=e.numberOfChannels,a=e.sampleRate,o=await e.getFirstTimestamp();let c=t.numberOfChannels??n,l=t.sampleRate??a,u=c!==n||l!==a||this._startTimestamp>0||o<0,d=this.output.format.getSupportedAudioCodecs();if(!t.forceTranscode&&!t.bitrate&&!u&&d.includes(i)&&(!t.codec||t.codec===i)&&!t.process){const h=new Hl(i);s=h,this._trackPromises.push((async()=>{await this._started;const f=new Yt(e),g={decoderConfig:await e.getDecoderConfig()??void 0},w=Number.isFinite(this._endTimestamp)?await f.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const T of f.packets(void 0,w)){if(this._canceled)return;this._reportProgress(e.id,T.timestamp),await h.add(T,g),this._synchronizer.shouldWait(e.id,T.timestamp)&&await this._synchronizer.wait(T.timestamp)}h.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}let f=null;t.codec&&(d=d.filter(w=>w===t.codec));const p=t.bitrate??Cs,g=await Ti(d,{numberOfChannels:t.process&&t.processedNumberOfChannels?t.processedNumberOfChannels:c,sampleRate:t.process&&t.processedSampleRate?t.processedSampleRate:l,bitrate:p});if(!g.some(w=>xt.includes(w))&&d.some(w=>xt.includes(w))&&(c!==Gr||l!==Xr)){const T=(await Ti(d,{numberOfChannels:Gr,sampleRate:Xr,bitrate:p})).find(k=>xt.includes(k));T&&(u=!0,f=T,c=Gr,l=Xr)}else f=g[0]??null;if(f===null){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}if(u)s=this._resampleAudio(e,t,f,c,l,p);else{const w=new Ps({codec:f,bitrate:p});s=w,this._trackPromises.push((async()=>{await this._started;const T=new ii(e);for await(const k of T.samples(void 0,this._endTimestamp)){if(this._canceled)return;await this._registerAudioSample(e,t,w,k),k.close()}w.close(),this._synchronizer.closeTrack(e.id)})())}}this.output.addAudioTrack(s,{languageCode:$t(e.languageCode)?e.languageCode:void 0,name:e.name??void 0,disposition:e.disposition}),this._addedCounts.audio++,this._totalTrackCount++,this.utilizedTracks.push(e)}async _registerAudioSample(e,t,i,s){if(this._canceled)return;this._reportProgress(e.id,s.timestamp);let n;if(!t.process)n=[s];else{let a=t.process(s);if(a instanceof Promise&&(a=await a),Array.isArray(a)||(a=a===null?[]:[a]),!a.every(o=>o instanceof ne))throw new TypeError("The audio process function must return an AudioSample, null, or an array of AudioSamples.");n=a}for(const a of n){if(this._canceled)break;await i.add(a),this._synchronizer.shouldWait(e.id,a.timestamp)&&await this._synchronizer.wait(a.timestamp)}for(const a of n)a!==s&&a.close()}_resampleAudio(e,t,i,s,n,a){const o=new Ps({codec:i,bitrate:a});return this._trackPromises.push((async()=>{await this._started;const c=new Xl({targetNumberOfChannels:s,targetSampleRate:n,startTime:this._startTimestamp,endTime:this._endTimestamp,onSample:async d=>{await this._registerAudioSample(e,t,o,d),d.close()}}),u=new ii(e).samples(this._startTimestamp,this._endTimestamp);for await(const d of u){if(this._canceled)return;await c.add(d),d.close()}await c.finalize(),o.close(),this._synchronizer.closeTrack(e.id)})()),o}_reportProgress(e,t){if(!this._computeProgress)return;m(this._totalDuration!==null),this._maxTimestamps.set(e,Math.max(t,this._maxTimestamps.get(e)));const i=Math.min(...this._maxTimestamps.values()),s=J(i/this._totalDuration,0,1);s!==this._lastProgress&&(this._lastProgress=s,this.onProgress?.(s))}}const As=5;class Gl{constructor(){this.maxTimestamps=new Map,this.resolvers=[]}computeMinAndMaybeResolve(){let e=1/0;for(const[,t]of this.maxTimestamps)e=Math.min(e,t);for(let t=0;t<this.resolvers.length;t++){const i=this.resolvers[t];i.timestamp-e<As&&(i.resolve(),this.resolvers.splice(t,1),t--)}return e}shouldWait(e,t){this.maxTimestamps.set(e,Math.max(t,this.maxTimestamps.get(e)??-1/0));const i=this.computeMinAndMaybeResolve();return t-i>=As}wait(e){const{promise:t,resolve:i}=G();return this.resolvers.push({timestamp:e,resolve:i}),t}closeTrack(e){this.maxTimestamps.delete(e),this.computeMinAndMaybeResolve()}}class Xl{constructor(e){this.sourceSampleRate=null,this.sourceNumberOfChannels=null,this.targetSampleRate=e.targetSampleRate,this.targetNumberOfChannels=e.targetNumberOfChannels,this.startTime=e.startTime,this.endTime=e.endTime,this.onSample=e.onSample,this.bufferSizeInFrames=Math.floor(this.targetSampleRate*5),this.bufferSizeInSamples=this.bufferSizeInFrames*this.targetNumberOfChannels,this.outputBuffer=new Float32Array(this.bufferSizeInSamples),this.bufferStartFrame=0,this.maxWrittenFrame=-1}doChannelMixerSetup(){m(this.sourceNumberOfChannels!==null);const e=this.sourceNumberOfChannels,t=this.targetNumberOfChannels;e===1&&t===2?this.channelMixer=(i,s)=>i[s*e]:e===1&&t===4?this.channelMixer=(i,s,n)=>i[s*e]*+(n<2):e===1&&t===6?this.channelMixer=(i,s,n)=>i[s*e]*+(n===2):e===2&&t===1?this.channelMixer=(i,s)=>{const n=s*e;return .5*(i[n]+i[n+1])}:e===2&&t===4?this.channelMixer=(i,s,n)=>i[s*e+n]*+(n<2):e===2&&t===6?this.channelMixer=(i,s,n)=>i[s*e+n]*+(n<2):e===4&&t===1?this.channelMixer=(i,s)=>{const n=s*e;return .25*(i[n]+i[n+1]+i[n+2]+i[n+3])}:e===4&&t===2?this.channelMixer=(i,s,n)=>{const a=s*e;return .5*(i[a+n]+i[a+n+2])}:e===4&&t===6?this.channelMixer=(i,s,n)=>{const a=s*e;return n<2?i[a+n]:n===2||n===3?0:i[a+n-2]}:e===6&&t===1?this.channelMixer=(i,s)=>{const n=s*e;return Math.SQRT1_2*(i[n]+i[n+1])+i[n+2]+.5*(i[n+4]+i[n+5])}:e===6&&t===2?this.channelMixer=(i,s,n)=>{const a=s*e;return i[a+n]+Math.SQRT1_2*(i[a+2]+i[a+n+4])}:e===6&&t===4?this.channelMixer=(i,s,n)=>{const a=s*e;return n<2?i[a+n]+Math.SQRT1_2*i[a+2]:i[a+n+2]}:this.channelMixer=(i,s,n)=>n<e?i[s*e+n]:0}ensureTempBufferSize(e){let t=this.tempSourceBuffer.length;for(;t<e;)t*=2;if(t!==this.tempSourceBuffer.length){const i=new Float32Array(t);i.set(this.tempSourceBuffer),this.tempSourceBuffer=i}}async add(e){this.sourceSampleRate===null&&(this.sourceSampleRate=e.sampleRate,this.sourceNumberOfChannels=e.numberOfChannels,this.tempSourceBuffer=new Float32Array(this.sourceSampleRate*this.sourceNumberOfChannels),this.doChannelMixerSetup());const t=e.numberOfFrames*e.numberOfChannels;this.ensureTempBufferSize(t);const i=e.allocationSize({planeIndex:0,format:"f32"}),s=new Float32Array(this.tempSourceBuffer.buffer,0,i/4);e.copyTo(s,{planeIndex:0,format:"f32"});const n=e.timestamp-this.startTime,a=e.numberOfFrames/this.sourceSampleRate,o=Math.min(n+a,this.endTime-this.startTime),c=Math.floor(n*this.targetSampleRate),l=Math.ceil(o*this.targetSampleRate);for(let u=c;u<l;u++){if(u<this.bufferStartFrame)continue;for(;u>=this.bufferStartFrame+this.bufferSizeInFrames;)await this.finalizeCurrentBuffer(),this.bufferStartFrame+=this.bufferSizeInFrames;const d=u-this.bufferStartFrame;m(d<this.bufferSizeInFrames);const p=(u/this.targetSampleRate-n)*this.sourceSampleRate,g=Math.floor(p),w=Math.ceil(p),T=p-g;for(let k=0;k<this.targetNumberOfChannels;k++){let S=0,y=0;g>=0&&g<e.numberOfFrames&&(S=this.channelMixer(s,g,k)),w>=0&&w<e.numberOfFrames&&(y=this.channelMixer(s,w,k));const x=S+T*(y-S),v=d*this.targetNumberOfChannels+k;this.outputBuffer[v]+=x}this.maxWrittenFrame=Math.max(this.maxWrittenFrame,d)}}async finalizeCurrentBuffer(){if(this.maxWrittenFrame<0)return;const e=(this.maxWrittenFrame+1)*this.targetNumberOfChannels,t=new Float32Array(e);t.set(this.outputBuffer.subarray(0,e));const i=this.bufferStartFrame/this.targetSampleRate,s=new ne({format:"f32",sampleRate:this.targetSampleRate,numberOfChannels:this.targetNumberOfChannels,timestamp:i,data:t});await this.onSample(s),this.outputBuffer.fill(0),this.maxWrittenFrame=-1}finalize(){return this.finalizeCurrentBuffer()}}export{Ko as ADTS,tu as ALL_FORMATS,Kl as ALL_TRACK_TYPES,pe as AUDIO_CODECS,Vo as AdtsInputFormat,du as AdtsOutputFormat,Si as AttachedFile,eu as AudioBufferSink,xu as AudioBufferSource,ne as AudioSample,ii as AudioSampleSink,Ps as AudioSampleSource,ir as AudioSource,sn as BaseMediaSampleSink,iu as BlobSource,ru as BufferSource,Sl as BufferTarget,Ga as CanvasSink,yu as CanvasSource,Gn as Conversion,Na as CustomAudioDecoder,Va as CustomAudioEncoder,Ua as CustomVideoDecoder,Oa as CustomVideoEncoder,Hl as EncodedAudioPacketSource,$ as EncodedPacket,Yt as EncodedPacketSink,Wl as EncodedVideoPacketSource,Go as FLAC,nu as FilePathSource,ou as FilePathTarget,Oo as FlacInputFormat,hu as FlacOutputFormat,Jo as Input,Fe as InputAudioTrack,fe as InputDisposedError,Ye as InputFormat,vi as InputTrack,er as InputVideoTrack,vn as IsobmffInputFormat,Hn as IsobmffOutputFormat,Ho as MATROSKA,jo as MP3,Wo as MP4,In as MatroskaInputFormat,Li as MediaSource,Cu as MediaStreamAudioTrackSource,Su as MediaStreamVideoTrackSource,Ss as MkvOutputFormat,jn as MovOutputFormat,Do as Mp3InputFormat,cu as Mp3OutputFormat,zo as Mp4InputFormat,qn as Mp4OutputFormat,xt as NON_PCM_AUDIO_CODECS,Cl as NullTarget,Qo as OGG,No as OggInputFormat,uu as OggOutputFormat,vs as Output,Ze as OutputFormat,Z as PCM_AUDIO_CODECS,Lo as QTFF,Cs as QUALITY_HIGH,mu as QUALITY_LOW,pu as QUALITY_MEDIUM,gu as QUALITY_VERY_HIGH,fu as QUALITY_VERY_LOW,ge as Quality,Ro as QuickTimeInputFormat,au as ReadableStreamSource,St as RichImageData,Ve as SUBTITLE_CODECS,lt as Source,Zo as StreamSource,xl as StreamTarget,Kn as SubtitleSource,tr as Target,_u as TextSubtitleSource,su as UrlSource,ce as VIDEO_CODECS,ee as VideoSample,ri as VideoSampleSink,_s as VideoSampleSource,rr as VideoSource,$o as WAVE,qo as WEBM,lu as WavOutputFormat,Uo as WaveInputFormat,Mo as WebMInputFormat,xs as WebMOutputFormat,wu as canEncode,Vi as canEncodeAudio,Wi as canEncodeSubtitles,Oi as canEncodeVideo,Ti as getEncodableAudioCodecs,bu as getEncodableCodecs,Ol as getEncodableSubtitleCodecs,Nl as getEncodableVideoCodecs,ku as getFirstEncodableAudioCodec,Tu as getFirstEncodableSubtitleCodec,Vl as getFirstEncodableVideoCodec,Zl as registerDecoder,Jl as registerEncoder};
